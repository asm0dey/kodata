{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"kandy/","title":"Kandy","text":""},{"location":"kandy/#kandy","title":"Kandy","text":"<p>Kandy is an open-source plotting library for Kotlin that provides a powerful and flexible DSL for creating graphs and utilizes various popular engines.</p> <p> </p> <ul> <li>Cross-platform compatibility \u2014 Works effortlessly within Kotlin notebooks on various platforms,   including IntelliJ IDEA, Datalore,   and Jupyter, as well as in standard Kotlin projects.</li> <li>Swing rendering \u2014 Features Swing rendering for outputs in the   Kotlin Notebook plugin.</li> <li>Interactive Chart features \u2014 Includes interactive tooltips for charts rendered in HTML and Swing.</li> <li>Multiple format export \u2014 Allows charts to be saved in various formats like <code>svg</code>, <code>png</code>, <code>html</code>, <code>jpg</code>/<code>jpeg</code>,   and <code>tiff</code>.</li> <li>Kotlin collections and DataFrame support \u2014 Seamlessly integrates with Kotlin collections   and allows graph construction using Kotlin DataFrame,   especially suitable for hierarchical dataframes.</li> <li>Type and null safety \u2014 Ensures type safety and Kotlin null safety.</li> </ul> <p>Inspired by The Grammar of Graphics.</p>"},{"location":"kandy/#quickstart","title":"Quickstart","text":"<p>Inside Kotlin Notebook, Datalore or Jupyter with Kotlin Kernel:</p> <pre><code>%use kandy\n\nplot {\n  bars { \n    x(listOf(\"first\", \"second\", \"third\"))\n    y(listOf(7, 3, 5))\n  }\n}\n</code></pre> <p></p> <p>For guidance on getting started, additional examples, and tutorials, please refer to our documentation.</p>"},{"location":"kandy/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Examples<ul> <li>Lets-Plot</li> <li>Echarts</li> </ul> </li> <li>Using Kandy</li> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"kandy/#overview","title":"Overview","text":"<p>Kandy is a Kotlin library that provides a flexible and idiomatic DSL for creating various types of charts, leveraging different visualization libraries. The library aims to make it easy and quick for users to create both basic and complex charts with many parameters and settings, without the need for lengthy documentation. Depending on the task, users can choose from different engines for the perfect visualization.</p> <p>Kandy integrates with Kotlin DataFrame, another Kotlin library for working with data, allowing for a seamless transition from data processing to final visualization. Additionally, integration with <code>kandy-lets-plot</code> in Kotlin Notebook enables high-speed chart rendering and the ability to work with large amounts of data without delays or waiting.</p> <p>The library comprises the following modules:</p> <ul> <li><code>kandy-api</code> \u2014 This module provides a simple-to-use API for creating charts.</li> <li><code>kandy-lets-plot</code> \u2014 This module offers an implementation of   the Lets-Plot library,   which is based by Leland Wilkinson   work The Grammar of Graphics   and is a proven tool for creating visualizations.</li> <li><code>kandy-echarts</code> \u2014 This module provides an implementation of   the Apache ECharts library,   which is a widely used tool for creating interactive visualizations.</li> </ul>"},{"location":"kandy/#examples","title":"Examples","text":""},{"location":"kandy/#lets-plot","title":"Lets-Plot","text":"<pre><code>val weatherData = mapOf(\n    \"time\" to listOf(0, 1, 2, 4, 5, 7, 8, 9),\n    \"temperature\" to listOf(12.0, 14.2, 15.1, 15.9, 17.9, 15.6, 14.2, 24.3),\n    \"humidity\" to listOf(0.5, 0.32, 0.11, 0.89, 0.68, 0.57, 0.56, 0.5)\n)  // Combine data into a map\n\nplot(weatherData) { // Begin plotting\n    x(\"time\") // Set x-axis with time data\n    y(\"temperature\") { // Set y-axis with temperature data\n        // Define scale for temperature (y-axis)\n        scale = continuous(0.0..25.5)\n    }\n\n    bars { // Add a bar layer\n        fillColor(\"humidity\") { // Customizing bar colors based on humidity\n            // Setting the color range\n            scale = continuous(range = Color.YELLOW..Color.RED)\n        }\n        borderLine.width = 0.0 // Define border line width\n    }\n\n    line {\n        width = 3.0 // Set line width\n        color = Color.hex(\"#6e5596\") // Define line color\n        type = LineType.DOTDASH // Specify the line type\n    }\n\n    layout { // Set plot layout\n        title = \"Simple plot with kandy-lets-plot\" // Add title\n        // Add caption\n        caption = \"See `examples` section for more\\n complicated and interesting examples!\"\n        size = 700 to 450 // Plot dimension settings\n    }\n}\n</code></pre> <p>You can get this example as a notebook, as Datalore notebook, or as a Kotlin project.</p>"},{"location":"kandy/#echarts","title":"ECharts","text":"<pre><code>val dataset = mapOf(\n    \"days_of_week\" to listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"),\n    \"evaporation\" to listOf(2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6),\n    \"precipitation\" to listOf(2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6),\n    \"temp\" to listOf(2.0, 2.2, 3.3, 4.5, 6.3, 10.2, 20.3)\n)\n\nplot(dataset) {\n    x(\"days_of_week\"&lt;String&gt;())\n\n    bars {\n        name = \"Precipitation\"\n        y(\"precipitation\"&lt;Double&gt;()) { scale = continuous(0.0..200.0) }\n        color(\"temp\"&lt;Double&gt;()) { scale = continuous(range = Color.GREY..Color.BLUE) }\n        label {\n            position = LabelPosition.TOP\n            formatter = \"{@precipitation} ml\"\n        }\n    }\n\n    line {\n        name = \"Evaporation\"\n        y(\"evaporation\"&lt;Double&gt;())\n        symbol = Symbol.diamond(20.0)\n    }\n\n    layout {\n        title.text = \"Precipitation and evaporation per week\"\n        legend {\n            left = 50.pct\n            bottom = 0.px\n        }\n    }\n}\n</code></pre> <p>You can get this example as a notebook, as a Datalore notebook, or as a Kotlin project.</p> <p>More examples of working with the library can be found here.</p>"},{"location":"kandy/#using-kandy","title":"Using Kandy","text":""},{"location":"kandy/#kotlin-notebook-datalore-kotlin-jupyter-notebook","title":"Kotlin Notebook, Datalore, Kotlin Jupyter Notebook","text":"<p>For more detailed instructions on how to get started with Kandy, refer to the Getting Started.</p> <p>You can use Kandy in Kotlin-supported notebooks, namely in Kotlin Notebook, Datalore, and Kotlin Jupyter Notebook.</p> <p>You can include all the necessary dependencies and imports in the notebook using line magic:</p> <pre><code>%use kandy\n</code></pre> <p>You can use <code>%useLatestDescriptors</code> to get the latest stable version without updating the Kotlin kernel or manually specify the version:</p> <pre><code>%useLatestDescriptors\n%use kandy\n</code></pre> <p>or</p> <pre><code>%use kandy($kandy_version)\n</code></pre> <p>Refer to the documentation on \"line magic\" for details.</p> <p>Available descriptors:</p> <ul> <li><code>kandy</code> \u2014 includes an API, implementation of Lets-Plot, DSL features, and DataFrame support</li> <li><code>kandy-echarts</code> \u2014 includes an API, implementation of ECharts, DSL features, and DataFrame support</li> </ul>"},{"location":"kandy/#gradle","title":"Gradle","text":"<p>Add dependencies (you can also add other modules that you need):</p> <pre><code>dependencies {\n    implementation(\"org.jetbrains.kotlinx:kandy-lets-plot:$kandy_version\")\n}\n</code></pre> <p>Make sure that you have <code>mavenCentral()</code> in the list of repositories:</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre>"},{"location":"kandy/#contributing","title":"Contributing","text":"<p>Read the Contributing Guidelines.</p>"},{"location":"kandy/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and the corresponding community are governed by the JetBrains Open Source and Community Code of Conduct. Please make sure you read it.</p>"},{"location":"kandy/#license","title":"License","text":"<p>Kandy is licensed under the Apache 2.0 License.</p>"},{"location":"kandy/docs/topics/API/","title":"API","text":"<p>     Browse through Kandy's detailed API documentation, methodically organized to offer a seamless browsing experience.     Each function, class, and method is accompanied by meticulous descriptions and hands-on examples.       Organized documentation, in-depth details, and illustrative examples for Kandy's API.       Kandy API: comprehensive documentation and practical examples. </p>"},{"location":"kandy/docs/topics/Getting-Started/","title":"Getting Started","text":"<p>     Start your journey with Kandy, learning to create engaging visualizations effortlessly.     Explore Kandy's functionalities in various environments including Kotlin Notebook,     Datalore, Jupyter Notebook, and Gradle projects.       Mastering effortless visualization across diverse platforms.       Kandy's introduction and your first plot creation. </p> <p></p> <p>You can utilize Kandy both in Kotlin projects and in interactive editors. For detailed instructions, refer to the respective pages:</p> <ul> <li>{style=\"inline\" width=\"20\"} Kotlin Notebook</li> <li>{style=\"inline\" width=\"22\"} Datalore</li> <li>{style=\"inline\" width=\"24\"} Jupyter Notebook</li> <li>{style=\"inline\" width=\"24\"} Gradle Configuration</li> </ul>"},{"location":"kandy/docs/topics/Getting-Started/#getting-kandy","title":"Getting Kandy","text":"<p>     With Kotlin Notebook, you can enjoy an unparalleled experience in data analysis and visualization.     While this platform offers a premier user experience,     rest assured that Kandy maintains a high standard of functionality and support across all other editors as well. </p> <p> <p>You can find detailed instructions here.</p> Install IntelliJ IDEA Ultimate if you don't already have it. Open your IDE and press  to open the IDE settings. Select Plugins from the menu and install the Kotlin Notebook plugin. Click Ok to apply the changes and restart your IDE if prompted. Create a new Kotlin Notebook file. Run this cell:                              %use kandy                 // If you are using dataframe as data                 %use dataframe              <p>Congratulations, you now have access to the Kandy library in Kotlin Notebook.</p> <p>You can find detailed instructions here.</p> Open Datalore. Register if you don't have an account. Create a new notebook. Select the Kotlin Kernel. Run this cell:                               %use kandy                 // If you are using dataframe as data                 %use dataframe              <p>Congratulations, you now have access to the Kandy library in Datalore.</p> <p>You can find detailed instructions here.</p> Install Jupyter. Install the Kotlin Kernel using one of the following methods:                                           pip install kotlin-jupyter-kernel                                               conda install -c jetbrains kotlin-jupyter-kernel                      Run Jupyter by executing the following command in the terminal: jupyter notebook Create a new notebook by selecting the Kotlin kernel. Run this cell in the notebook:                              %use kandy                 // If you are using dataframe as data                 %use dataframe              <p>Congratulations, you now have access to the Kandy library in Jupyter Notebook.</p> <p>You can find detailed instructions here.</p> Create a JVM project with Kotlin in your IDE. Add the Kandy dependency to your build.gradle.kts file:                                      dependencies {                         implementation(\"org.jetbrains.kotlinx:kandy-lets-plot:%kandy_latest_version%\")                     }                  <p>Congratulations, you now have access to the Kandy library in your Kotlin project.</p> </p>"},{"location":"kandy/docs/topics/Getting-Started/#plotting-a-simple-example","title":"Plotting a Simple Example","text":"<p>In interactive notebooks, the Kotlin DataFrame library employs an on-the-fly generation mechanism for extension properties that correspond to the columns of a data frame. In IntelliJ IDEA, there is a Gradle plugin available for generating properties based on CSV or JSON files. In cases where this mechanism is not utilized, you can still access the columns by passing the column names as string variables.</p> <p>Let's create data that will be used to construct the plot. This data will represent the average annual temperatures in various cities. When working in interactive notebooks, it is advisable to divide the data creation and plot construction into two separate cells. This approach ensures that extension properties are generated for our columns in the DataFrame, allowing us to reference them easily.</p> <p>First, create a DataFrame containing data on the average temperatures in different cities as follows:</p> <pre><code>// Create a DataFrame with data on average temperatures in various cities\nval averageTemperature = dataFrameOf(\n    \"city\" to listOf(\"New York\", \"London\", \"Berlin\", \"Yerevan\", \"Tokyo\"),\n    \"average temperature\" to listOf(12.5, 11.0, 9.6, 11.5, 16.0)\n)\n</code></pre> <p>Next, construct a simple plot using the data from the DataFrame:</p> <pre><code>// Construct a plot using the data from the DataFrame\naverageTemperature.plot {\n    // Add bars to the plot\n    // Each bar represents the average temperature in a city\n    bars {\n        x(city) // Set the cities' data on the X-axis\n        y(`average temperature`) { // Set the temperatures' data on the Y-axis\n            axis.name = \"Average Temperature (\u00b0C)\" // Assign a name to the Y-axis\n        }\n    }\n    // Set the title of the plot\n    layout.title = \"Kandy Getting Started Example\"\n}\n</code></pre> <p>{ border-effect=\"rounded\" }</p> <p>This supplementary schema outlines the key elements of Kandy's DSL, providing a quick reference to assist you in building your visualizations.</p> <p> <li>plot  <li>Data Manipulation  <li>groupBy</li> <li>statBin</li> <li>statDensity</li> <li>statBoxplot</li> <li>statsSmooth</li> <li>statCount</li> <li>statCount2D</li> </li> <li>Layers  <li>abLine</li> <li>area</li> <li>bars</li> <li>boxplot</li> <li>boxes</li> <li>countPlot</li> <li>crossBars</li> <li>densityPlot</li> <li>errorBars</li> <li>hLine</li> <li>heatmap</li> <li>histogram</li> <li>line</li> <li>lineRanges</li> <li>path</li> <li>pie</li> <li>pointRanges</li> <li>path</li> <li>pie</li> <li>pointRanges</li> <li>raster</li> <li>rectangles</li> <li>ribbon</li> <li>segments</li> <li>smoothLine</li> <li>step</li> <li>text</li> <li>tiles</li> <li>vLine</li> </li> <li>Layout</li> </li> <p></p> <p>For more examples, please see the Examples section.</p> <p> User Guide Examples API Reference </p>"},{"location":"kandy/docs/topics/Kandy-in-Datalore/","title":"Kandy in Datalore","text":"<p>     Embark on your journey with the Kandy library in Datalore.     This section guides you through the initial steps of opening and creating a notebook in Datalore     and introduces you to crafting simple graphs with Kandy.       Kickstart your data visualization journey in Datalore with Kandy.     Find a step-by-step guide to setting up a notebook and creating your first graph,     paving the way for more advanced explorations.       Getting Started with Kandy in Datalore: Your First Notebook and Graph </p> <p>Datalore is a collaborative data science platform designed to streamline insight delivery, facilitating more productive collaboration between data science and business teams. This platform is adept for tasks such as data collection, exploration, machine learning, interactive visualization, and reporting.</p> <p>Datalore supports Python, Kotlin, Scala, and R notebooks without the need for preliminary setup, offering computational resources tailored to your requirements.</p>"},{"location":"kandy/docs/topics/Kandy-in-Datalore/#getting-started-with-datalore","title":"Getting Started with Datalore","text":"<ol> <li>Open Datalore.</li> <li>Register if you don't already have an account.</li> <li>On the home page, click on the New Notebook button.</li> </ol> <p> {width=\"200\"}</p> <p>You will be redirected to the New Notebook page where you can set the notebook's title, select a    kernel, choose a computation mode, and configure various other settings.</p> <ol> <li>Select the Kotlin Kernel and click Create Notebook.</li> </ol> <p></p> <ol> <li>In the notebook, execute the following cell to add the Kandy library:</li> </ol> <pre><code>%use kandy\n</code></pre> <p>You now have access to the Kandy library within your Kotlin Notebook in Datalore.</p> <p></p>"},{"location":"kandy/docs/topics/Kandy-in-Jupyter-Notebook/","title":"Kandy in Jupyter Notebook","text":"<p>     Embark on your analytical journey with the Kandy library in the Jupyter Notebook.     In this section, find a comprehensive guide to installing the Kotlin kernel,     creating a Kotlin notebook, importing the Kandy library, and constructing your first simple example.       Begin your data visualization venture with Kandy in the Jupyter Notebook.     This segment equips you with a detailed roadmap for installing the Kotlin kernel     and crafting your initial visualization using Kandy.       Step-by-Step Guide to Unleashing Kandy's Potential in Jupyter Notebook </p> <p>Jupyter is a renowned open-source project offering Jupyter Notebook for interactive computations across various programming languages. Jupyter Notebook facilitates the creation and sharing of documents containing code, equations, visualizations, and narrative text. It has become a staple tool amongst data scientists, researchers, and programmers for data visualization and analytical computations. Notably, the Jupyter project supports the Kotlin language through the Kotlin Kernel.</p>"},{"location":"kandy/docs/topics/Kandy-in-Jupyter-Notebook/#getting-started-with-jupyter-notebook-and-kotlin","title":"Getting Started with Jupyter Notebook and Kotlin","text":"<ol> <li>Jupyter Notebook and the Kotlin Kernel can be installed using either the conda package manager or pip.    Here, we will outline both approaches:</li> </ol> <p> <ul> <li>Jupyter Notebook is included in the Anaconda distribution.   To install Anaconda, download the installer from the official site   and follow the installation instructions.</li> <li>After completing the above step, install the Kotlin Kernel by executing the following command in the terminal:</li> </ul> <pre><code>conda install -c jetbrains kotlin-jupyter-kernel\n</code></pre> <p> <ul> <li>Pip is included with Python. Hence, install Python using a method that suits you,   preferably by downloading the installer from the official site.</li> <li>Next, run the following command in the terminal to install Jupyter Notebook:</li> </ul> <pre><code>pip install notebook\n</code></pre> <ul> <li>Additionally, install the Kotlin Kernel by executing:</li> </ul> <pre><code>pip install kotlin-jupyter-kernel\n</code></pre> <p> </p> <p>You can find instructions for installing, uninstalling, and updating the Kotlin Kernel in the Kotlin Notebook documentation.</p> <ol> <li>After installing both the Jupyter Notebook and Kotlin Kernel,    launch Jupyter Notebook by entering one of the following commands in the terminal:</li> </ol> <pre><code>jupyter notebook\n</code></pre> <p>or</p> <pre><code>jupyter-notebook\n</code></pre> <ol> <li>The Jupyter Notebook will open in your browser.    Create a new notebook in the current folder by clicking the New button located in the upper right    corner and selecting Kotlin from the dropdown menu.</li> </ol> <p> {width=\"250\" border-effect=\"rounded\"}</p> <ol> <li>In the notebook, execute the following cell to add the Kandy library:</li> </ol> <pre><code>%use kandy\n</code></pre> <p>You now have access to the Kandy library within your Kotlin Notebook in Jupyter.</p> <p></p> <p> Jupyter Kotlin Jupyter Kotlin Jupyter Docs </p>"},{"location":"kandy/docs/topics/Kandy-in-Kotlin-Notebook/","title":"Kandy in Kotlin Notebook","text":"<p>     Discover the seamless integration of Kandy in Kotlin Notebook.     Follow our guided steps to set up and start creating immersive data visualizations right within your Kotlin notebook.       Seamlessly integrate Kandy for visualizations in Kotlin Notebook.       Kickstart Your Data Visualization Journey with Kandy in Kotlin Notebook </p> <p>Kotlin Notebook represent interactive notebooks equipped with rich output capabilities, allowing you to explore and experiment with Kotlin code without the need for additional environment setup. The Kotlin Notebook plugin facilitates the creation and editing of notebooks directly within IntelliJ IDEA. This plugin not only encapsulates the various functionalities available in regular Kotlin files in the IDE but also incorporates additional extensions exclusive to Kotlin notebooks. These features include advanced syntax highlighting, code insertion hints, checks, and the utilization of search and refactoring functions, all aiding in enhancing your Kotlin coding efficiency.</p> <p>The Kotlin Notebook plugin infuses IntelliJ IDEA with interactive development capacities, complementing the robust language support Kotlin offers within the IDE, paired with the versatile visualization potentials browsers provide.</p> <p>Check out the blog post for a quick introduction to Kotlin Notebook.</p>"},{"location":"kandy/docs/topics/Kandy-in-Kotlin-Notebook/#install-kotlin-notebook-and-use-kandy","title":"Install Kotlin Notebook and Use Kandy","text":"<ol> <li> <p>To start, install IntelliJ IDEA Ultimate</p> </li> <li> <p>The plugin can be installed through IDEA settings, from the marketplace, or from a local archive file (ZIP or JAR).</p> </li> </ol> <p> <ul> <li>Open IDEA and press  to open the IDE settings</li> <li>Select Plugins</li> <li>Navigate to the Marketplace tab   </li> <li>In the search bar, type <code>Kotlin Notebook</code></li> <li>Locate the plugin and initiate the installation by clicking the Install button   </li> <li>Click Ok to apply the changes and restart your IDE if prompted</li> </ul> <p> <ul> <li>Open the plugin page in JetBrains Marketplace</li> <li>Click on Install to IntelliJ IDEA  { border-effect=\"rounded\" }</li> <li>Restart your IDE if prompted</li> </ul> <p> <ul> <li>Open the plugin page in JetBrains Marketplace</li> <li>Go to the Versions tab</li> <li>Download the specific version of plugin    { border-effect=\"rounded\" }</li> <li>Open IDEA and press  to open the IDE settings</li> <li>Select Plugins</li> <li>On the Plugins page, click on  button and then click on Install Plugin from   Disk\u2026 </li> <li>Restart your IDE if prompted</li> </ul> <p> </p> <ol> <li>Create a New Project in IDEA</li> </ol> <p> <ul> <li>From the main menu, select File | New | Project.</li> <li>In the panel on the left, select New Project.   Select Kotlin language as language for the new project.</li> </ul> <p></p> <ul> <li> <p>Click Create button.</p> </li> <li> <p>In the newly opened project, create a new Kotlin Notebook file.   To do this, press  in the project tree or right-click with your mouse.   Select Kotlin Notebook file.</p> </li> </ul> <p> {width=\"200\"}</p> <p></p> <ol> <li>In the notebook, execute the following cell to add the Kandy library:</li> </ol> <pre><code>%use kandy\n</code></pre> <p>You now have access to the Kandy library within your Kotlin Notebook.</p> <p></p> <p> Kotlin Notebook on Marketplace Introducing Kotlin Notebook Kotlin Notebook Docs </p>"},{"location":"kandy/docs/topics/Kandy-with-Gradle/","title":"Kandy with Gradle","text":"<p>     Dive into the process of setting up a Kotlin JVM project managed with Gradle,     introducing the Kandy library to your workspace.     This section provides a step-by-step guide to initiating a project,     incorporating the Kandy library, and crafting your first plot.       Discover the essentials of starting a Kotlin JVM project with Gradle and integrating the Kandy library.     This segment elucidates the step-by-step procedure     to get your first Kandy visualization up and running in a Gradle managed project.       Your Roadmap to Creating First Visualizations with Kandy in a Gradle Managed Kotlin Project </p> <p>Using the Kandy library is possible in Kotlin projects on the JVM managed by Gradle.</p>"},{"location":"kandy/docs/topics/Kandy-with-Gradle/#getting-started-with-kandy-on-gradle","title":"Getting started with Kandy on Gradle","text":"<ol> <li>Install IntelliJ IDEA</li> <li>From the main menu, select File | New | Project.</li> <li>In the panel on the left, select New Project.</li> <li>Choose Kotlin as the programming language and Gradle as the build system.    </li> <li>Click Create button.</li> <li>Navigate to your Gradle build file, which could either be build.gradle.kts (for Kotlin DSL)    or build.gradle (for Groovy DSL), and add the Kandy library as a dependency:</li> </ol> <p> <pre><code>dependencies {\n    implementation(\"org.jetbrains.kotlinx:kandy-lets-plot:%kandy_latest_version%\")\n}\n</code></pre> <p> <pre><code>dependencies {\n    implementation 'org.jetbrains.kotlinx:kandy-lets-plot:%kandy_latest_version%'\n}\n</code></pre> <p> </p> <p>You now have access to the Kandy library in your Kotlin project.</p>"},{"location":"kandy/docs/topics/Kandy-with-Gradle/#plotting-a-simple-example","title":"Plotting a Simple Example","text":"<pre><code>import org.jetbrains.kotlinx.dataframe.api.dataFrameOf\nimport org.jetbrains.kotlinx.kandy.dsl.plot\nimport org.jetbrains.kotlinx.kandy.letsplot.export.save\nimport org.jetbrains.kotlinx.kandy.letsplot.layers.bars\n\nfun main() {\n    // Create a DataFrame with data on average temperatures in various cities\n    val averageTemperature = dataFrameOf(\n        \"city\" to listOf(\"New York\", \"London\", \"Berlin\", \"Yerevan\", \"Tokyo\"),\n        \"average temperature\" to listOf(12.5, 11.0, 9.6, 11.5, 16.0)\n    )\n\n    // Construct a plot using the data from the DataFrame\n    averageTemperature.plot {\n        // Add bars to the plot\n        // Each bar represents the average temperature in a city\n        bars {\n            x(\"city\") // Set the cities' data on the X-axis\n            y(\"average temperature\") { // Set the temperatures' data on the Y-axis\n                axis.name = \"Average Temperature (\u00b0C)\" // Assign a name to the Y-axis\n            }\n        }\n        // Set the title of the plot\n        layout.title = \"Kandy Getting Started Example\"\n    }.save(\"Started Example.png\") // Save plot as PNG image\n}\n</code></pre> <p>{ border-effect=\"rounded\" }</p> <p>This supplementary schema outlines the key elements of Kandy's DSL, providing a quick reference to assist you in building your visualizations.</p> <p></p> <p>For more examples, please see the Examples section.</p>"},{"location":"kandy/docs/topics/Overview/","title":"Overview","text":"<p>     Get introduced to Kandy, the powerful plotting library for Kotlin.     Understand the philosophy driving its design, its standout features, and the motivations behind its creation.       Dive into Kandy's philosophy, core features, and what makes it a unique choice for plotting in Kotlin.       Kandy Unveiled: Philosophy, Features, and Motivations. </p>"},{"location":"kandy/docs/topics/Overview/#what-is-kandy","title":"What is Kandy?","text":"<p>Kandy is an open-source data visualization library designed for Kotlin. It adopts a modern approach to data visualization, offering an idiomatic and flexible DSL. This DSL, integrating seamlessly with Kotlin's type safety, facilitates quick graph creation with fewer exceptions. Kandy also supports various popular engines, enhancing its versatility and performance for efficient chart-building.</p> <p>Kandy utilizes the Lets-Plot library, which allows it to display in interactive notebooks, saved as standalone HTML files, and export in formats like PNG, SVG, and JPEG. This capability enables the use of Kandy in Kotlin projects.</p> <p>Alongside <code>kandy-lets-plot</code>, there is an ongoing development of <code>kandy-echarts</code>, an experimental module utilizing <code>echarts.js</code> for rendering.</p>"},{"location":"kandy/docs/topics/Overview/#features","title":"Features","text":"<ul> <li>Hierarchical DSL \u2014 Provides an intuitive and straightforward approach to constructing graphs.</li> <li>Support for Kotlin notebooks \u2014 Facilitates working with Kandy on platforms like   IntelliJ IDEA with the   {style=\"inline\" width=\"20\"} Kotlin Notebook plugin,   {style=\"inline\" width=\"22\"} Datalore,   and {style=\"inline\" width=\"24\"} Jupyter Notebook.</li> <li>Swing rendering in Kotlin notebook \u2014 Available in IntelliJ IDEA.</li> <li>Interactive tooltips \u2014 Offers dynamic tooltips during rendering in both Swing and HTML.</li> <li>Kotlin collections support \u2014 Seamlessly works with Kotlin\u2019s standard collections as data sources.</li> <li>Kotlin DataFrame support \u2014 Integrates with Kotlin DataFrame,   utilizing generated extension properties and hierarchical data for plot construction.</li> <li>Type and null safety \u2014 Ensures type safety and Kotlin null safety.</li> </ul>"},{"location":"kandy/docs/topics/Overview/#dsl-and-syntax","title":"DSL and Syntax","text":"<p>Kandy features a common API that facilitates the Plot Intermediate Representation (IR). Both <code>kandy-lets-plot</code> and <code>kandy-echarts</code> are developed to be compatible with this API.</p> <p>Kandy's DSL offers an intuitive, hierarchical approach to creating data visualizations. Its flexible yet structured design is suitable for both beginners and experienced users. Here's a simplified overview of the Kandy DSL structure:</p> <p></p> <ul> <li>Plot \u2014 the <code>plot</code> block forms the foundation of every visualization in Kandy, setting the stage for all other   elements.</li> <li>Data Manipulation \u2014 this block plays a key role in transforming the initial data utilized in <code>plot</code>.<ul> <li>Grouping \u2014 this method groups data according to specified keys,   allowing for organized and structured visualization based on distinct data segments.</li> <li>Statistical \u2014 this set of methods applies statistical operations to the data,   producing new datasets derived from these computations.</li> </ul> </li> <li>Layout \u2014 this part deals with the graph's design, including elements like titles, subtitles, size,   and thematic elements.</li> <li>Layers \u2014 it introduces different types of visual elements, such as lines, points, bars, etc.</li> <li>Aesthetic Mappings / Settings \u2014   This feature enables mapping data attributes to visual properties like color,   shape, and size, offering extensive customization options.</li> <li>Scale Specification \u2014 this aspect is crucial for translating data values into appropriate visual scales on the   graph, including settings for color gradients, size ranges, and positioning.</li> </ul> <p>Kandy's DSL offers a straightforward path for creating visualizations, combining clarity and aesthetic appeal. Its design focuses on ease of use, enabling the efficient crafting of complex charts.</p>"},{"location":"kandy/docs/topics/Overview/#syntax","title":"Syntax","text":"<p>Kandy's API follows the structure outlined below:</p> <ul> <li>Basic plotting with initial data:</li> </ul> <pre><code>plot(data) {\n    // layer (geoms)\n    line[bars | points | area | pie | ...] {\n        ... // aesthetics     \n    }\n\n    line[bars | points | area | pie | ...] {\n        ...\n    }\n\n      ...\n}\n</code></pre> <ul> <li>Transforming data into plotting context:</li> </ul> <pre><code>plot(data) {\n    // data manipulation\n    groupBy(Strings| Columns) [statBin|statBoxplot|statDensity|...] {\n        line[bars | points | area | pie | ...] {\n            ...\n        }\n        line[bars | points | area | pie | ...] {\n            ...\n        }\n\n      ...\n    }\n}\n</code></pre> <ul> <li>Combining original and transformed data:</li> </ul> <pre><code>plot(data) {\n    groupBy(Strings| Columns) [statBin|statBoxplot|statDensity|...] {\n        line[bars | points | area | pie | ...] {\n            ...\n        }\n        line[bars | points | area | pie | ...] {\n            ...\n        }\n      ...\n    }\n\n    line[bars | points | area | pie | ...] {\n        ...\n    }\n    line[bars | points | area | pie | ...] {\n        ...\n    }\n\n      ...\n}\n</code></pre> <ul> <li>Modifying plot layout:</li> </ul> <pre><code>plot(data) {\n    line[bars | points | area | pie | ...] {\n        ...\n    }\n      ...\n\n    layout {\n        title\n        subtitle\n          ...\n        theme { ... }\n        legend { ... }\n        grid { ... }\n          ...\n    }\n}\n</code></pre> <p>For mappings and settings, Kandy uses the following approach:</p> <ul> <li>Mapping to a Collection or Column is done through function calls:</li> </ul> <pre><code>x(\"time\") // map to the column `time`\ny(listOf(1, 2, 3)) // map to a list\ncolor(type) // map to the type column\n</code></pre> <ul> <li>Settings for positional aesthetics:</li> </ul> <pre><code>x.constant(3)\nyIntercept.constant(5.7)\n</code></pre> <ul> <li>Settings for other aesthetics:</li> </ul> <pre><code>color = Color.RED\nsize = 4.5\ntype = LineType.DASHED\n</code></pre> <p>Now that we've covered Kandy's DSL components and structure, let's see how they work together in a practical example. This demonstrates the DSL's capability in crafting a visualization with ease and flexibility:</p> <p> <pre><code>val weatherData = dataFrameOf(\n    \"time\" to listOf(0, 1, 2, 4, 5, 7, 8, 9),\n    \"temperature\" to listOf(12.0, 14.2, 15.1, 15.9, 17.9, 15.6, 14.2, 24.3),\n    \"humidity\" to listOf(0.5, 0.32, 0.11, 0.89, 0.68, 0.57, 0.56, 0.5)\n)\n\nweatherData.plot { // Begin plotting\n    x(time) // Set x-axis with time data\n    y(temperature) { // Set y-axis with temperature data\n        // Define scale for temperature (y-axis)\n        scale = continuous(0.0..25.5)\n    }\n\n    bars { // Add a bar layer\n        fillColor(humidity) { // Customizing bar colors based on humidity\n            // Setting the color range\n            scale = continuous(range = Color.YELLOW..Color.RED)\n        }\n        borderLine.width = 0.0 // Define border line width\n    }\n\n    line {\n        width = 3.0 // Set line width\n        color = Color.hex(\"#6e5596\") // Define line color\n        type = LineType.DOTDASH // Specify the line type\n    }\n\n    layout { // Set plot layout\n        title = \"Simple plot with kandy-lets-plot\" // Add title\n        // Add caption\n        caption = \"See `examples` section for more\\n complicated and interesting examples!\"\n        size = 700 to 450 // Plot dimension settings\n    }\n}\n</code></pre> <p> <pre><code>val weatherData = mapOf(\n    \"time\" to listOf(0, 1, 2, 4, 5, 7, 8, 9),\n    \"temperature\" to listOf(12.0, 14.2, 15.1, 15.9, 17.9, 15.6, 14.2, 24.3),\n    \"humidity\" to listOf(0.5, 0.32, 0.11, 0.89, 0.68, 0.57, 0.56, 0.5)\n)  // Combine data into a map\n\nplot(weatherData) { // Begin plotting\n    x(\"time\") // Set x-axis with time data\n    y(\"temperature\") { // Set y-axis with temperature data\n        // Define scale for temperature (y-axis)\n        scale = continuous(0.0..25.5)\n    }\n\n    bars { // Add a bar layer\n        fillColor(\"humidity\") { // Customizing bar colors based on humidity\n            // Setting the color range\n            scale = continuous(range = Color.YELLOW..Color.RED)\n        }\n        borderLine.width = 0.0 // Define border line width\n    }\n\n    line {\n        width = 3.0 // Set line width\n        color = Color.hex(\"#6e5596\") // Define line color\n        type = LineType.DOTDASH // Specify the line type\n    }\n\n    layout { // Set plot layout\n        title = \"Simple plot with kandy-lets-plot\" // Add title\n        // Add caption\n        caption = \"See `examples` section for more\\n complicated and interesting examples!\"\n        size = 700 to 450 // Plot dimension settings\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p>More examples of working with the library can be found here.</p>"},{"location":"kandy/docs/topics/Quickstart/","title":"Quickstart","text":"<p> Quickly get started with Kandy. This guide provides straightforward steps for integrating Kandy and a basic example to kickstart your journey into advanced data visualization. </p> <p> Discover how to easily integrate this versatile library for data visualization and create your first plot. </p> <p> Kickstart your data visualization with Kandy. Follow easy steps to integrate and explore Kandy's basic plotting capabilities. </p> <p>Kandy can be integrated into Kotlin projects and interactive editors. Learn more in Getting Started.</p> <p>This Quickstart uses Kandy in a Kotlin notebook, demonstrating a swift setup process.</p>"},{"location":"kandy/docs/topics/Quickstart/#integrating-kandy","title":"Integrating Kandy","text":"<p>To include Kandy in your notebook, execute the following code in a cell:</p> <pre><code>%use kandy\n</code></pre> <p>This command makes all necessary classes and methods available for chart construction.</p>"},{"location":"kandy/docs/topics/Quickstart/#crafting-your-first-plot","title":"Crafting Your First Plot","text":"<p>Now, let's create a chart. Use the code below to build your first plot with Kandy:</p> <pre><code>val weatherData = mapOf(\n    \"time\" to listOf(0, 1, 2, 4, 5, 7, 8, 9),\n    \"temperature\" to listOf(12.0, 14.2, 15.1, 15.9, 17.9, 15.6, 14.2, 24.3),\n    \"humidity\" to listOf(0.5, 0.32, 0.11, 0.89, 0.68, 0.57, 0.56, 0.5)\n)  // Combine data into a map\n\nplot(weatherData) { // Begin plotting\n    x(\"time\") // Set x-axis with time data\n    y(\"temperature\") { // Set y-axis with temperature data\n        // Define scale for temperature (y-axis)\n        scale = continuous(0.0..25.5)\n    }\n\n    bars { // Add a bar layer\n        fillColor(\"humidity\") { // Customizing bar colors based on humidity\n            // Setting the color range\n            scale = continuous(range = Color.YELLOW..Color.RED)\n        }\n        borderLine.width = 0.0 // Define border line width\n    }\n\n    line {\n        width = 3.0 // Set line width\n        color = Color.hex(\"#6e5596\") // Define line color\n        type = LineType.DOTDASH // Specify the line type\n    }\n\n    layout { // Set plot layout\n        title = \"Simple plot with kandy-lets-plot\" // Add title\n        // Add caption\n        caption = \"See `examples` section for more\\n complicated and interesting examples!\"\n        size = 700 to 450 // Plot dimension settings\n    }\n}\n</code></pre> <p>This code results in your inaugural plot using Kandy.</p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook Getting Started User Guide Examples API Reference </p>"},{"location":"kandy/docs/topics/guides/Algebraic-Curve/","title":"Algebraic Curve","text":"<p> Discover the elegance of algebraic curves with Kandy's 'Algebraic Curve' example. This interactive exploration in Kotlin illustrates the simplicity of plotting complex mathematical functions using a raster layer, showcasing the curve y\u00b2 = x\u00b3 + ax + b. </p> <p> Explore the beauty of elliptic curves in Kotlin with Kandy's 'Algebraic Curve' example. Effortlessly plot complex algebraic functions, demonstrating the power of raster layers in visualizing mathematical concepts. </p> <p> Unveil the beauty of elliptic curves using Kandy's 'Algebraic Curve' in Kotlin. This example adeptly demonstrates plotting intricate algebraic functions with ease. </p> <pre><code>fun linspace(start: Double, stop: Double, num: Int): List&lt;Double&gt; {\n    return List(num) { i -&gt; start + i * ((stop - start) / (num - 1)) }\n}\n</code></pre> <pre><code>fun F(x: Double, y: Double, a: Double = 0.0, b: Double = 0.0): Double {\n    return y.pow(2) - x.pow(3) - a * x - b\n}\n\nfun level(z: Double, c: Double = 1.0): Double {\n    return exp(-c * abs(z))\n}\n</code></pre> <pre><code>val n = 300\nval a = -1.0\nval b = 0.0\nval xRange = linspace(-3.0, 3.0, n + 1)\nval yRange = linspace(-3.0, 3.0, n + 1)\nval zippedData = xRange.map { x -&gt;\n    yRange.map { y -&gt; Triple(x, y, level(F(x, y, a = a, b = b), c = 10.0)) }\n}.flatten()\nval dataset = mapOf(\n    \"x\" to zippedData.map { it.first },\n    \"y\" to zippedData.map { it.second },\n    \"z\" to zippedData.map { it.third },\n)\n</code></pre> <pre><code>plot(dataset) {\n    raster {\n        x(\"x\"&lt;Double&gt;())\n        y(\"y\"&lt;Double&gt;())\n        fillColor(\"z\"&lt;Double&gt;()) {\n            scale = continuous(range = Color.hex(\"#253494\")..Color.hex(\"#ffffcc\"))\n            legend.type = LegendType.None\n        }\n    }\n\n    layout {\n        title = \"Elliptic curve with a = $a, b = $b\"\n        subtitle = \"Simple way to draw an algebraic curve - with `raster` layer\"\n        size = 800 to 600\n\n        theme(Theme.Classic) {\n            blankAxes()\n        }\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Anscombes-Quartet-Guide/","title":"Anscombe's quartet","text":"<p> Explore the intriguing Anscombe's Quartet with Kandy. This guide delves into creating visualizations for this famous dataset, demonstrating the importance of graphical representation in statistical analysis. </p> <p> Discover Anscombe's Quartet through Kandy's visualization guide. Learn to graphically represent this unique dataset, highlighting the essence of data visualization. </p> <p> Unravel the mysteries of Anscombe's Quartet with Kandy. This guide offers a clear pathway to visualize and understand this classic example of statistical importance. </p> <pre><code>val df =\n    DataFrame.readCSV(\n        \"https://gist.githubusercontent.com/ericbusboom/b2ac1d366c005cd2ed8c/raw/c92c66e43d144fa9c29dbd602d5af6988e8db533/anscombes.csv\",\n        parserOptions = ParserOptions(locale = Locale.ENGLISH)\n    )\n\ndf.head()\n</code></pre> id dataset x y 0 I 10 8.04 1 I 8 6.95 2 I 13 7.58 3 I 9 8.81 4 I 11 8.33 <pre><code>df.describe()\n</code></pre> name type count unique nulls top freq mean std min median max id Int 44 44 0 0 1 21.5 12.845 0 21 43 dataset String 44 4 0 I 11 null null I II IV x Double 44 12 0 8.0 13 9 3.199 4.0 8.0 19.0 y Double 44 43 0 8.84 2 7.501 1.959 3.1 7.52 12.74 <pre><code>df.plot {\n    points {\n        x(\"x\") {\n            scale = continuous(0.0..20.0)\n        }\n        y(\"y\") {\n            scale = continuous(0.0..20.0)\n        }\n        color(dataset)\n        size = 5.0\n    }\n\n    abLine {\n        slope.constant(0.5)\n        intercept.constant(3)\n\n        width = 1.7\n        alpha = 0.7\n    }\n\n    facetWrap(nCol = 2) {\n        facet(dataset)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/","title":"Boxplot","text":"<p> Unlock the power of boxplot in Kandy's 'Boxplot' guide. This comprehensive resource provides insights into creating boxplot to effectively analyze and compare distributions in your data. </p> <p> Explore boxplot creation with Kandy's detailed guide. Learn to visualize data distributions and identify outliers for comprehensive data analysis. </p> <p> Discover how to create impactful boxplot with Kandy. The 'Boxplot' guide offers step-by-step instructions for visualizing data variations and outliers. </p> <p>A boxplot, alternatively referred to as a whisker plot, serves as a statistical visualization technique, illustrating the distribution and summary statistics of a dataset in a graphical format. It consists of several components:</p> <ol> <li>Median (Q2): the line inside the box represents the median of the dataset, which is the middle value when the data is    sorted in ascending order.    It divides the data into two equal halves, with 50% of the data falling below and 50% above the median.</li> <li>Interquartile Range (IQR): the box itself spans the interquartile range, which is the range between the first    quartile (Q1) and the third quartile (Q3).    The first quartile (Q1) is the 25<sup>th</sup> percentile, meaning that 25% of the    data falls below it, while the third quartile (Q3) is the 75<sup>th</sup> percentile,    indicating that 75% of the data falls below it.    The IQR captures the middle 50% of the data.</li> <li>Whiskers: the whiskers extend from the top and bottom edges of the box to the minimum and maximum non-outlier data    points within a certain range.    The range is typically determined by a multiplier (often 1.5 times the IQR),    and it defines the outer limits for what is considered a potential outlier.</li> <li>Outliers (optional): individual data points that fall outside the whiskers are considered potential outliers.    These are data points that are significantly different from the rest of the data    and may warrant special attention in further analysis.    The auxiliary statistic \"boxplotOutliers\" is used to count outliers.    This statistic is not weighted.</li> </ol> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#usage","title":"Usage","text":"<p>A boxplot is a visual representation of a dataset's distribution, showing the median, quartiles, and potential outliers. It's a useful tool for understanding the spread and central tendency of data, as well as identifying outliers. The compactness of this chart also makes it convenient to visually compare the characteristics of different samples with each other.</p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#arguments","title":"Arguments","text":"<p>Both <code>statBoxplot()</code> and <code>statBoxplotOutliers()</code> (as well as statistical <code>boxplot()</code> layer and plot functions) have the same arguments and signature.</p> <ul> <li>Input (mandatory):<ul> <li><code>x</code> - a categorical variable dividing the data into different groups (in some versions of functions it is absent,   i.e., all calculations will be performed for one sample without a division);</li> <li><code>y</code> - numeric sample on which the statistics are calculated;</li> </ul> </li> <li>Parameters (optional):<ul> <li><code>whiskerIQRRatio: Double</code> - interquartile range multiplier of whiskers lengths.</li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"boxplot\" statistic (which will be discussed further below - different variations of <code>statBoxplot()</code>, <code>statBoxplotOutliers()</code> <code>boxplot()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statBoxplotArgs := \n   x, // not necessarily\n   y, \n   whiskerIQRRatio: Double = 1.5\n</code></pre> <p>The possible types <code>y</code> depend on where a certain function is used. It can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself. It's used only with <code>DataFrame</code> - it's a reference to a column of the same type as an <code>y</code>. <code>x</code> elements are type of <code>X</code> - generic type parameter.</p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#output-statistics","title":"Output statistics","text":""},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#boxplot_1","title":"\"boxplot\"","text":"name type description Stat.x X Boxplot <code>x</code> category Stat.min Double Lower whisker end - the minimum non-outlier data point Stat.lower Double Lower box edge - the first quartile (Q1) Stat.middle Double Median / the second quartile (Q2) Stat.upper Double Upper box edge - the third quartile (Q3) Stat.max Double Upper whisker end - the maximum non-outlier data point"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#boxplotoutliers","title":"\"boxplotOutliers\"","text":"name type description Stat.x X Boxplot <code>x</code> category Stat.y Double Outlier value"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#statboxplot-plots","title":"StatBoxplot plots","text":"<pre><code>// To generate the data, we use a standard java math library\n// https://commons.apache.org/proper/commons-math/\n// Generate sample from normal distribution\nval rateA = NormalDistribution(37.8, 4.3).sample(5000).toList()\n// Generate sample from uniform distribution\nval rateB = UniformRealDistribution(20.0, 50.0).sample(1000).toList()\n// Combine two previous samples and filter them by lower bound for third sample\nval rateC = (rateA + rateB).filter { it &gt;= 36.0 }\n</code></pre> <pre><code>// gather them into the DataFrame in a single column and with corresponding keys in column `cond`\nval df = dataFrameOf(\n    \"rate\" to rateA + rateB + rateC,\n    \"cond\" to List(rateA.size) { \"A\" } + List(rateB.size) { \"B\" } + List(rateC.size) { \"C\" }\n)\ndf.head(5)\n</code></pre> rate cond 38.387 A 33.406 A 33.51 A 36.099 A 38.703 A <p><code>df</code> has a signature</p> rate cond <p>Let's take a look at <code>StatBoxplot</code> output DataFrame:</p> <pre><code>df.statBoxplot(\"cond\", \"rate\")\n</code></pre> Stat xminlowermiddleuppermax A26.24434.84137.7640.61249.267 B20.00127.27334.67142.02549.997 C36.00237.94139.89442.4149.097 <p>It has the following signature:</p> Stat x min lower middle upper max <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statBoxplot</code>, each row corresponds to one boxplot. It's the column with the <code>x</code>-coordinate category. <code>Stat.min</code>, <code>Stat.lower</code>, <code>Stat.upper</code> and <code>Stat.max</code> correspond boxplot statistics\u2014box and whiskers <code>y</code>-coordinates. <code>Stat.middle</code> - median value, middle line <code>y</code>-coordinate.</p> <p><code>DataFrame</code> with \"boxplot\" statistics is called <code>StatBoxplotFrame</code></p> <p>Also, we can calculate outliers of these boxplot:</p> <pre><code>df.statBoxplotOutliers(\"cond\", \"rate\").head(5)\n</code></pre> Stat xy A50.433 A51.032 A49.306 A23.615 A25.988 <p>It has the following signature:</p> Stat x y <p>There are only two columns in <code>Stat</code> group: <code>Stat.x</code> with <code>x</code> boxplot category and <code>Stat.y</code> with <code>y</code> outlier coordinate.</p> <p><code>DataFrame</code> with \"boxplotOutliers\" statistics is called <code>StatBoxplotOutliersFrame</code></p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#statboxplot-and-statboxplotoutliers-transforms","title":"<code>statBoxplot</code> and <code>statBoxplotOutliers</code> transforms","text":"<p><code>statBoxplot(statBoxplotArgs) { /*new plotting context*/ }</code> modifies a plotting context - instead of original data (no matter was it empty or not) new <code>StatBoxplot</code> dataset (calculated on given arguments; inputs and weights can be provided as <code>Iterable</code> or as dataset column reference - by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected - you can add layers using initial dataset outside the <code>statBoxplot</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context.</p> <pre><code>df.plot {\n    statBoxplot(cond, rate) {\n        // New \"StatBoxplot\" dataset here\n        errorBars {\n            // Use `Stat.*` columns for mappings\n            x(Stat.x)\n            yMin(Stat.min)\n            yMax(Stat.max)\n            borderLine.color(Stat.x)\n        }\n    }\n    // Initial dataset here\n    points {\n        x(\"cond\")\n        y(\"rate\")\n        size = 0.5\n        alpha = 0.2\n        color(\"cond\")\n        position = Position.jitter()\n    }\n}\n</code></pre> <p></p> <p><code>statBoxplotOutliers(statBoxplotArgs) { /*new plotting context*/ }</code> works the same way with a new StatBoxplotOutliers` dataset.</p> <pre><code>df.plot {\n    statBoxplotOutliers(cond, rate) {\n        // New \"StatBoxplotOutliers\" dataset here\n        points {\n            x(Stat.x)\n            y(Stat.y)\n            color(Stat.x)\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#boxplot-layer","title":"<code>boxplot</code> layer","text":"<p>To make a boxplot (statistical chart), we need boxplot statistics and <code>boxes</code> geom. Boxes attributes and boxplot statistics match. Also, we can add outliers using <code>boxplotOutliers</code> statistic and <code>points</code> layer.</p> <pre><code>val manualBoxplot = df.plot {\n    statBoxplot(cond, rate) {\n        boxes {\n            // All positional aesthetics match boxplot statistics\n            x(Stat.x)\n            yMin(Stat.min)\n            lower(Stat.lower)\n            middle(Stat.middle)\n            upper(Stat.upper)\n            yMax(Stat.max)\n        }\n    }\n    statBoxplotOutliers(cond, rate) {\n        points {\n            x(Stat.x)\n            y(Stat.y)\n        }\n    }\n    layout {\n        title = \"`statBoxplot` + `boxes` \\n\" +\n                \"and `statBoxplotOutliers` + `points`\"\n    }\n}\nmanualBoxplot\n</code></pre> <p></p> <p>But we can do it much faster with <code>boxplot(statBoxplotArgs)</code> method:</p> <pre><code>val boxplotPlot = df.plot {\n    // Statistical boxplot layer - receives \"statBoxplotArgs\" and has default mappings\n    boxplot(cond, rate)\n    layout.title = \"`boxplot()`\"\n}\nboxplotPlot\n</code></pre> <p></p> <p>Let's compare them:</p> <pre><code>plotGrid(listOf(manualBoxplot, boxplotPlot))\n</code></pre> <p></p> <p>These two plots are identical. Indeed, statistical <code>boxplot</code> just uses the combination of statistics and layers above (<code>statBoxplot</code> + <code>boxes</code> and <code>statBoxplotOutlier</code> + <code>points</code>) and performs coordinates mappings under the hood. And we can customize statistical boxplot layer: <code>boxplot()</code> optionally opens a new context, where we can configure both boxes and outliers (as in usual contexts opened by <code>boxes { ... }</code>/<code>points { ... }</code>). Moreover, <code>Stat.</code> columns of <code>StatBoxplot</code> dataset are available in the context of boxes, exactly as <code>Stat.</code> columns of <code>StatBoxplotOutliers</code> are available in the context of outliers. Also, we can hide outliers.</p> <pre><code>df.plot {\n    boxplot(cond, rate) {\n        boxes {\n            // Boxes context + StatBoxplot context\n            // filling color depends on `x` category\n            fillColor(Stat.x)\n        }\n        // hide outliers\n        outliers.show = false\n    }\n}\n</code></pre> <p></p> <pre><code>df.plot {\n    boxplot(cond, rate) {\n        boxes {\n            fatten = 0.5\n            alpha = 0.6\n            // Border line color depends on `x` category\n            borderLine.color(Stat.x)\n        }\n        outliers {\n            // points context + StatBoxplotOutliers context\n            // color depends on `x` category\n            color(Stat.x)\n            symbol = Symbol.ASTERIX\n        }\n    }\n}\n</code></pre> <p></p> <p>Boxplot layer by a single sample (without <code>x</code> categories) - receives only one sample (<code>Iterable</code> or column reference)</p> <pre><code>plot {\n    boxplot(rateC)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#boxplot-plot","title":"<code>boxplot</code> plot","text":"<p><code>boxplot(statBoxplotArgs)</code> and <code>DataFrame.boxplot(statBoxplotArgs)</code> is a family of functions for fast plotting a boxplot.</p> <pre><code>// There's an additional argument \"showOutliers\"\ndf.boxplot(\"cond\", \"rate\", showOutliers = false)\n</code></pre> <p></p> <p>In case you want to provide inputs and weights using column selection DSL, it's a bit different from the usual one - you should assign <code>x</code> and <code>y</code> inputs throw invocation eponymous functions:</p> <pre><code>df.boxplot(whiskerIQRRatio = 2.0) {\n    x(cond)\n    y(rate)\n}\n</code></pre> <p></p> <p>Boxplot plot can be configured with <code>.configure {}</code> extension - it opens context similar to the one that creates a statistical <code>boxplot</code> layer, where you can configure boxes and outliers the same way, but also can configure any plot adjustments:</p> <pre><code>df.boxplot {\n    x(cond)\n    y(rate)\n}.configure {\n    // BoxplotLayer + PlotContext\n    // can't add new layer but can configure `boxes` and `outliers`\n    boxes {\n        alpha = 0.7\n        fillColor(Stat.middle) { scale = continuous(Color.GREEN..Color.RED) }\n    }\n    outliers {\n        color(Stat.x)\n        // jittered outliers\n        position = Position.jitter(0.1, 0.0)\n    }\n    // can configure general plot adjustments\n    layout {\n        title = \"Configured boxplot\"\n        size = 600 to 350\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#grouped-staboxplot","title":"Grouped <code>staBoxplot</code>","text":"<p>Sometimes you need it to group data within <code>x</code> categories. Can be applied for grouped data \u2014 statistics will be counted on each group independently (each is counted for some <code>x</code> category). This application returns a new <code>GroupBy</code> dataset with the same keys as the old one but with <code>StatBoxplot</code> groups instead of old ones.</p> <pre><code>// Use \"mpg\" dataset\nval mpgDF =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDF.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact <pre><code>// We need only three columns\nval mpgShortDF = mpgDF[\"class\", \"hwy\", \"drv\"]\nmpgShortDF.head(5)\n</code></pre> class hwy drv compact 29 f compact 29 f compact 31 f compact 30 f compact 26 f <pre><code>// group it by \"drv\"\nval groupedDF = mpgShortDF.groupBy { drv }\ngroupedDF\n</code></pre> drv group f {drv: \"f\", hwy: 29, class:...} 4 {drv: \"4\", hwy: 26, class:...} r {drv: \"r\", hwy: 20, class:...} <p>Now we have a <code>GroupBy</code> with a signature</p> key: [drv] group: DataFrame[class|hwy|drv] \"f\" \"f\"-Group \"4\" \"4\"-Group \"r\" \"r\"-Group <pre><code>groupedDF.statBoxplot { x(`class`); y(hwy) }\n</code></pre> drvgroup f{Stat: {min: 23, middle: 29,...} 4{Stat: {min: 25, middle: 25,...} r{Stat: {min: 16, middle: 17,...} <p>After <code>statBoxplot</code> applying it's still a <code>GroupBy</code> but with different signature of <code>group</code> - all groups have the same signature as usual <code>DataFrame</code> after <code>statBoxplot</code> applying (i.e. <code>StatBoxplotFrame</code>):</p> key: [drv] group: StaBoxplotFrame \"f\" \"f\"-Group \"4\" \"4\"-Group \"r\" \"r\"-Group <p>As you can see, we did indeed do a <code>statBoxplot</code> transformation within groups, the grouping keys did not change.</p> <p>The plotting process doesn't change much \u2014 we do everything the same.</p> <pre><code>groupedDF.plot {\n    statBoxplot(`class`, hwy) {\n        errorBars {\n            x(Stat.x)\n            yMin(Stat.min)\n            yMax(Stat.max)\n        }\n    }\n}\n</code></pre> <p></p> <p>As you can see there are two or three error bars in some <code>x</code> categories because we have three groups of data. To distinguish them, we need to adjust position and add mapping to the color from the key. This is convenient \u2014 the key is available in the context</p> <pre><code>groupedDF.plot {\n    statBoxplot(`class`, hwy) {\n        errorBars {\n            x(Stat.x)\n            yMin(Stat.min)\n            yMax(Stat.max)\n            borderLine.color(drv)\n            position = Position.dodge()\n        }\n    }\n}\n</code></pre> <p></p> <p>The statistical <code>boxplot</code> layer also works. Moreover, if we have exactly one grouping key, a mapping from it to <code>fillColor</code> will be created by default.</p> <pre><code>groupedDF.plot {\n    boxplot(`class`, hwy)\n}\n</code></pre> <p></p> <p>We can customize it like we used to. From the differences - access to <code>key</code> columns, and we can customize the <code>position</code> of boxes (within a single x-coordinate), for example - overlap them:</p> <pre><code>groupedDF.plot {\n    boxplot(`class`, hwy) {\n        boxes {\n            borderLine.color(drv)\n            // `identity` position, i.e boxes are overlapping\n            position = Position.identity()\n            alpha = 0.5\n        }\n        outliers.show = false\n    }\n}\n</code></pre> <p></p> <p><code>boxplot</code> plot for <code>GroupBy</code> (i.e. <code>GroupBy.boxplot(statBoxplotArgs)</code> extensions) works as well:</p> <pre><code>groupedDF.boxplot(\"class\", \"hwy\")\n</code></pre> <p></p> <p>... and can be configured the same way:</p> <pre><code>groupedDF.boxplot {\n    x(`class`)\n    y(hwy)\n}.configure {\n    boxes.borderLine.color = Color.hex(\"#000080\")\n    outliers {\n        color(drv)\n    }\n    layout {\n        size = 750 to 450\n        title = \"Configured grouped boxplot\"\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Boxplot-Guide/#inside-groupby-plot-context","title":"Inside <code>groupBy{}</code> plot context","text":"<p>We can apply <code>groupBy</code> modification to the initial dataset and build a boxplot with grouped data the same way:</p> <pre><code>mpgShortDF.plot {\n    groupBy(drv) {\n        boxplot(`class`, hwy)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/","title":"Count Plot","text":"<p> Learn to create compelling count plots with Kandy. This guide introduces you to the techniques for visualizing frequency distributions in datasets, helping you to effectively communicate data patterns and insights. </p> <p> Kandy's Count Plot guide: A straightforward approach to visually representing frequency distributions in your data. </p> <p> Discover Kandy's guide on count plots for a deeper understanding of frequency distributions in datasets, enhancing your data visualization skills. </p> <p>Statistics \"count\" are calculated on the sample of a single categorical variable. It counts the number of observations in each category. It's weighted, it means the weighted count for each category is calculated (each element within a category is counted along with its weight).</p> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#usage","title":"Usage","text":"<p>\"Count\" is one of the most important statistics with different usages. The count plot provides a graphical depiction of how categories are distributed.</p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#arguments","title":"Arguments","text":"<ul> <li>Input (mandatory):<ul> <li><code>x</code> \u2014 discrete sample on which the statistics are calculated</li> </ul> </li> <li>Weights (optional):<ul> <li><code>weights</code> \u2014 set of weights of the same size as the input sample.   <code>null</code> (by default) means all weights are equal to <code>1.0</code> and the weighted count is equal to the normal one</li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"count\" statistic (which will be discussed further below \u2014 different variations of <code>statCount()</code>, <code>countPlot()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statCountArgs := \n   x, \n   weights = null\n</code></pre> <p>The possible types of <code>x</code> and <code>weights</code> depend on where a certain function is used. They can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself. <code>x</code> elements are type of <code>X</code> \u2014 generic type parameter.</p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#output-statistics","title":"Output statistics","text":"name type description Stat.x X Category Stat.count Int Number of observations in this category Stat.countWeighted Double Weighted count (sum of observations weights in this category)"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#statcount-plots","title":"StatCount plots","text":"<pre><code>// Use \"mpg\" dataset\nval mpgDF =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDF.head(5)\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact <pre><code>// We need only three columns\nval df = mpgDF[\"class\", \"drv\", \"hwy\"]\ndf.head(5)\n</code></pre> class drv hwy compact f 29 compact f 29 compact f 31 compact f 30 compact f 26 <p>It has a signature</p> class drv hwy <p>Let's take a look at <code>StatCount</code> output DataFrame:</p> <pre><code>df.statCount(\"class\", \"hwy\")\n</code></pre> Stat xcountcountWeighted compact471330 midsize411119 suv621124 2seater5124 minivan11246 <p>It has the following signature:</p> Stat x count countWeighted <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statCount2D</code>, each row corresponds to one category. <code>Stat.x</code> is the column with this category. <code>Stat.count</code> contains the number of observations in the category. <code>Stat.countWeighted</code> - weighted version of <code>count</code>. <code>DataFrame</code> with \"count\" statistics is called <code>StatCountFrame</code></p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#statcount-transform","title":"<code>statCount</code> transform","text":"<p><code>statCount(statCountArgs) { /*new plotting context*/ }</code> modifies a plotting context - instead of original data (no matter was it empty or not) new <code>StatCount</code> dataset (calculated on given arguments, inputs and weights can be provided as <code>Iterable</code> or as dataset column reference - by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected - you can add layers using initial dataset outside the <code>statCount</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context:</p> <pre><code>plot {\n    statCount(df[\"class\"]) {\n        // New `StatCount` dataset here\n        points {\n            // Use `Stat.*` columns for mappings\n            x(Stat.x)\n            y(Stat.count)\n            size(Stat.count)\n            color(Stat.x)\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#countplot-layer","title":"CountPlot layer","text":"<p>CountPlot is a statistical plot used for visualizing the distribution of categorical variables. It's a bar plot where each bar is representing one of the categories: its <code>x</code> coordinate is corresponding to the category and <code>y</code> to its count. So basically, we can build a histogram with <code>statCount</code> as follows:</p> <pre><code>val statCountAndBarsPlt = df.plot {\n    statCount(\"class\") {\n        bars {\n            x(Stat.x)\n            y(Stat.count)\n        }\n    }\n    layout.title = \"`statCount()` + `bars()` layer\"\n}\nstatCountAndBarsPlt\n</code></pre> <p></p> <p>But we can do it even faster with <code>countPlot(statCountArgs)</code> method:</p> <pre><code>val countPlt = plot {\n    countPlot(df[\"class\"])\n    layout.title = \"`countPlot()` layer\"\n}\ncountPlt\n</code></pre> <p></p> <p>Let's compare them:</p> <pre><code>plotGrid(listOf(statCountAndBarsPlt, countPlt))\n</code></pre> <p></p> <p>These two plots are identical. Indeed, <code>countPlot</code> just uses <code>statCount</code> and <code>bars</code> and performs coordinate mappings under the hood. And we can customize count plot layer: <code>countPlot()</code> optionally opens a new context, where we can configure bars (as in the usual context opened by <code>bars { ... }</code>) \u2014 even change coordinate mappings from default ones. <code>StatCount</code> dataset of count plot is also can be accessed here.</p> <pre><code>df.plot {\n    countPlot(`class`) {\n        // filling color depends on `count` statistic\n        fillColor(Stat.count) {\n            scale = continuous(Color.GREEN..Color.RED)\n        }\n        borderLine.color = Color.BLACK\n    }\n}\n</code></pre> <p></p> <p>If we specify weights, <code>Stat.countWeighted</code> is mapped to <code>y</code> by default:</p> <pre><code>df.plot {\n    countPlot(`class`, hwy)\n    // We can add other layers as well.\n    // Let's add a horizontal mark line with constant y intercept:\n    hLine {\n        val criticalCount = 500\n        yIntercept.constant(criticalCount)\n        tooltips { line(\"Critical count: ${String.format(\"%d\", criticalCount)}\") }\n        color = Color.RED; width = 3.0\n    }\n    x.axis.name = \"Car class\"\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#countplot-plot","title":"<code>countPlot</code> plot","text":"<p><code>countPlot(statCountArgs)</code> and <code>DataFrame.countPlot(statCountArgs)</code> are a family of functions for fast plotting a count plot.</p> <pre><code>countPlot(listOf(\"A\", \"A\", \"A\", \"B\", \"B\", \"C\", \"B\", \"B\"))\n</code></pre> <p></p> <pre><code>df.countPlot(\"class\")\n</code></pre> <p></p> <p>In case you want to provide inputs and weights using column selection DSL, it's a bit different from the usual one - you should assign <code>x</code> input and (optionally) <code>weight</code> throw invocation eponymous functions:</p> <pre><code>df.countPlot {\n    x(`class`)\n    weight(hwy)\n}\n</code></pre> <p></p> <p>CountPlot plot can be configured with <code>.configure {}</code> extension \u2014 it opens a context that combines bars, <code>StatCount</code> and plot context. That means you can configure bars settings, mappings using <code>StatCount</code> dataset and any plot adjustments:</p> <pre><code>df.countPlot {\n    x(`class`)\n}.configure {\n    // Bars + StatCount + PlotContext\n    // can't add new layer\n    // can add bars mapping, including for `Stat.*` columns\n    fillColor(Stat.x)\n    alpha = 0.6\n    // can configure general plot adjustments\n    layout {\n        title = \"Configured `countPlot` plot\"\n        size = 600 to 350\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#grouped-statcount","title":"Grouped <code>statCount</code>","text":"<p><code>statCount</code> can be applied for grouped data \u2014 statistics will be calculated on each group independently but with equal categories. This application returns a new <code>GroupBy</code> dataset with the same keys as the old one but with <code>StatCount</code> groups instead of old ones.</p> <pre><code>// group our dataframe by `drv` column\nval groupedDF = df.groupBy { drv }\ngroupedDF\n</code></pre> drvgroup f classdrvhwy compactf29 compactf29 compactf31 compactf30 compactf26 4 classdrvhwy compact426 compact425 compact428 compact427 compact425 r classdrvhwy compactr20 compactr15 compactr20 compactr17 compactr17 <p>Now we have a <code>GroupBy</code> with a signature</p> key: [drv] group: DataFrame[class|drv|hwy] \"f\" \"f\"-Group \"4\" \"4\"-Group \"r\" \"r\"-Group <pre><code>groupedDF.statCount { x(`class`) }\n</code></pre> drvgroup f Stat { x: compact, count: 35, countWeighted: 35} 4 Stat { x: compact, count: 12, countWeighted: 12} r Stat { x: suv, count: 11, countWeighted: 11} <p>After <code>statCount</code> applying it's still a <code>GroupBy</code> but with different signature of <code>group</code> - all groups have the same signature as usual <code>DataFrame</code> after <code>statCount</code> applying (i.e. <code>StatCountFrame</code>):</p> key: [drv] group: StaCountFrame \"f\" \"f\"-Group \"4\" \"4\"-Group \"r\" \"r\"-Group <p>As you can see, we did indeed do a <code>statCount</code> transformation within groups, the grouping keys did not change.</p> <p>The plotting process doesn't change much \u2014 we do everything the same.</p> <pre><code>groupedDF.plot {\n    statCount(`class`) {\n        bars {\n            x(Stat.x)\n            y(Stat.countWeighted)\n        }\n    }\n}\n</code></pre> <p></p> <p>As you can see, there are several bars in some categories because we have three groups of data. To distinguish them, we need to add mapping to the filling color from the key. This is convenient \u2014 the key is available in the context</p> <pre><code>groupedDF.plot {\n    statCount(`class`) {\n        bars {\n            x(Stat.x)\n            y(Stat.countWeighted)\n            fillColor(drv)\n        }\n    }\n}\n</code></pre> <p></p> <p>The <code>countPlot</code> layer also works. Moreover, if we have exactly one grouping key, a mapping from it to <code>fillColor</code> will be created by default.</p> <pre><code>groupedDF.plot {\n    countPlot(\"class\")\n}\n</code></pre> <p></p> <p>We can customize it like we used to. From the differences - access to <code>key</code> columns, and we can customize the <code>position</code> of bars (within a single x-coordinate), for example \u2014 stack them:</p> <pre><code>groupedDF.plot {\n    countPlot(\"class\") {\n        fillColor(drv) {\n            scale = categorical(listOf(Color.GREEN, Color.ORANGE, Color.LIGHT_PURPLE))\n        }\n        borderLine.width = 0.0\n        width = 1.0\n        // adjust position of bars\n        position = Position.stack()\n    }\n}\n</code></pre> <p></p> <p>CountPlot plot for <code>GroupBy</code> (i.e. <code>GroupBy.countPlot(statCountArgs)</code> extensions) works as well:</p> <pre><code>groupedDF.countPlot(\"class\")\n</code></pre> <p></p> <p>... and can be configured the same way:</p> <pre><code>groupedDF.countPlot { x(`class`) }.configure {\n    alpha = 0.6\n    // make the bars from different groups overlap with each other\n    position = Position.identity()\n    // can access key column by name as `String`\n    fillColor(\"drv\") { scale = categoricalColorBrewer(BrewerPalette.Qualitative.Dark2) }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Count-Plot-Guide/#inside-groupby-plot-context","title":"Inside <code>groupBy{}</code> plot context","text":"<p>We can apply <code>groupBy</code> modification to the initial dataset and count plot a histogram with grouped data the same way:</p> <pre><code>df.plot {\n    groupBy(drv) {\n        countPlot(`class`)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/","title":"Density Plot","text":"<p> Become proficient in creating density plot visualizations with Kandy. This manual offers a detailed exploration into the creation and understanding of density plots, giving you the ability to explicitly and efficiently represent data distributions. </p> <p> Enhance your data analysis skills with Kandy's Density Plot guide. Learn how to visualize and interpret data distributions for insightful analyses. </p> <p> Explore Kandy's Density Plot guide for an in-depth understanding of data distributions. This guide offers essential techniques for creating and analyzing density plots. </p> <p>Statistics \"density\" are calculated on the sample of a single continuous variable. It approximates the Probability Density Function (PDF) of this sample. \"Density\" statistic samples this function point. It's weighted, it means the counted density depends on observation weights.</p> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#usage","title":"Usage","text":"<p>\"Density\" statistic is useful when you have a large dataset, and you want to understand the underlying probability distribution. Density plot visualizes the PDF and also allows you to compare the distribution of different samples. This is a useful alternative to the histogram for continuous data that comes from an underlying smooth distribution.</p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#arguments","title":"Arguments","text":"<ul> <li>Input (mandatory):<ul> <li><code>x</code> \u2014 numeric sample on which the statistics are calculated</li> </ul> </li> <li>Weights (optional):<ul> <li><code>weights</code> \u2014 set of weights of the same size as the input sample.   <code>null</code> (by default) means all weights are equal to <code>1.0</code> and the weighted density is equal to the normal one</li> </ul> </li> <li>Parameters (optional):<ul> <li><code>n: Int</code> \u2014 number of sampled points;</li> <li><code>trim: Boolean</code> \u2014 if <code>false</code>, each density is computed on the full range of the data,   if <code>true</code>, each density is computed over the range of that group (only for grouped inputs).</li> <li><code>adjust: Double</code> \u2014 adjusts the value of bandwidth by multiplying it; changes how smooth the frequency curve is.</li> <li><code>kernel: Kernel</code> \u2014 the kernel used to calculate the density function:<ul> <li><code>Kernel.GAUSSIAN</code></li> <li><code>Kernel.RECTANGULAR</code></li> <li><code>Kernel.TRIANGULAR</code></li> <li><code>Kernel.BIWEIGHT</code></li> <li><code>Kernel.EPANECHNIKOV</code></li> <li><code>Kernel.OPTCOSINE</code></li> </ul> </li> <li><code>fullScanMax: Int</code> \u2014 maximum size of data to use density computation with 'full scan'.   For bigger data, less accurate but more efficient density computation is applied</li> <li><code>bandWidth: BandWidth</code> \u2014 the method (or exact value) of bandwidth:<ul> <li><code>BandWidth.Method.NRD</code></li> <li><code>BandWidth.Method.NRD0</code></li> <li><code>BandWidth.value(value: Double)</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"density\" statistic (which will be discussed further below \u2014 different variations of <code>statDensity()</code>, <code>densityPlot()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statDensityArgs := \n   x, \n   weights = null,\n   n: Int = 512,\n   trim: Boolean = false,\n   adjust: Double = 1.0,\n   kernel: Kernel = Kernel.GAUSSIAN,\n   fullScanMax: Int = 5000,\n   bandWidth: BandWidth = BandWidth.Method.NRD0,\n</code></pre> <p>The possible types of <code>x</code> and <code>weights</code> depend on where a certain function is used. They can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself.</p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#output-statistics","title":"Output statistics","text":"name type description Stat.x Double <code>x</code> coordinate Stat.density Double Density estimate Stat.densityWeighted Double Weighted density Stat.scaled Double Density estimate, scaled to maximin of 1.0. Stat.scaledWeighted Double Weighted scaled"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#statdensity-plots","title":"StatDensity plots","text":"<pre><code>// To generate the data, we use a standard java math library\n// https://commons.apache.org/proper/commons-math/\n// Generate sample from normal distribution\nval depthList = NormalDistribution(500.0, 100.0).sample(1000).toList()\n// Generate sample from uniform distribution\nval coeffList = UniformRealDistribution(0.0, 1.0).sample(1000).toList()\n</code></pre> <pre><code>// Gather them into the DataFrame\nval df = dataFrameOf(\n    \"depth\" to depthList,\n    \"coeff\" to coeffList\n)\ndf.head()\n</code></pre> depth coeff 495.7 0.818 666.918 0.863 466.139 1 488.06 0.489 338.757 0.917 <p><code>df</code> has a signature</p> depth coeff <p>Let's take a look at <code>StatDensity</code> output DataFrame:</p> <pre><code>df.statDensity(\"depth\", \"coeff\").head()\n</code></pre> Stat xdensitydensityWeightedscaledscaledWeighted 181.351000.0110.015 182.64000.0120.016 183.929000.0120.016 185.218000.0120.017 186.506000.0130.017 <p>It has the following signature:</p> Stat x density densityWeighted scaled scaledWeighted <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statDensity</code>, each row corresponds to one PDF point. <code>Stat.x</code> is the column with this point <code>x</code> coordinate. <code>Stat.density</code> contains the estimated density. <code>Stat.densityWeighted</code> \u2014 weighted version of <code>density</code>. <code>Stat.scaled</code> is a density scaled to a maximum of 1.0. <code>Stat.scaledWeighted</code> \u2014 weighted version of <code>scaled</code>. <code>DataFrame</code> with \"density\" statistics is called <code>StatDensityFrame</code></p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#statdensity-transform","title":"<code>statDensity</code> transform","text":"<p><code>statDensity(statDensityArgs) { /*new plotting context*/ }</code> modifies a plotting context \u2014 instead of original data (no matter was it empty or not) new <code>StatDensity</code> dataset (calculated on given arguments, inputs and weights can be provided as <code>Iterable</code> or as dataset column reference \u2014 by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected \u2014 you can add layers using initial dataset outside the <code>statDensity</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context:</p> <pre><code>plot {\n    statDensity(depthList, adjust = 0.2) {\n        // New `StatDensity` dataset here\n        line {\n            // Use `Stat.*` columns for mappings\n            x(Stat.x)\n            y(Stat.density)\n            color(Stat.density)\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#densityplot-layer","title":"DensityPlot layer","text":"<p>Density plot is a statistical plot used for visualizing the distribution of continuous variables. It's an area graph of kernel-estimated PDF. So basically, we can build a histogram with <code>statDensity</code> as follows:</p> <pre><code>val statDensityAndAreaPlot = df.plot {\n    statDensity(\"depth\") {\n        area {\n            x(Stat.x)\n            y(Stat.density)\n        }\n    }\n    layout.title = \"`statDensity()` + `area()` layer\"\n}\nstatDensityAndAreaPlot\n</code></pre> <p></p> <p>But we can do it even faster with <code>densityPlot(statDensityArgs)</code> method:</p> <pre><code>val densityLayerPlot = plot {\n    densityPlot(depthList)\n    layout.title = \"`densityPlot()` layer\"\n}\ndensityLayerPlot\n</code></pre> <p></p> <p>Let's compare them:</p> <pre><code>plotGrid(listOf(statDensityAndAreaPlot, densityLayerPlot))\n</code></pre> <p></p> <p>These two plots are identical. Indeed, <code>densityPlot</code> just uses <code>statDensity</code> and <code>area</code> and performs coordinate mappings under the hood. And we can customize <code>densityPlot</code> layer: <code>densityPlot()</code> optionally opens a new context, where we can configure bars (as in the usual context opened by <code>area { ... }</code>) \u2014 even change coordinate mappings from default ones. <code>StatDensity</code> dataset of <code>densityPlot</code> is also can be accessed here.</p> <pre><code>df.plot {\n    densityPlot(depth) {\n        // Change a column mapped on `y` to `Stat.scaled`\n        y(Stat.scaled)\n        alpha = 0.7\n        fillColor = Color.RED\n        borderLine.color = Color.BLACK\n    }\n}\n</code></pre> <p></p> <p>If we specify weights, <code>Stat.densityWeighted</code> is mapped to <code>y</code> by default:</p> <pre><code>df.plot {\n    densityPlot(depth, coeff, n = 700, adjust = 0.8, bandWidth = BandWidth.value(17.0))\n    // We can add other layers as well.\n    // Let's add a horizontal mark line with constant y intercept:\n    vLine {\n        // Count sample mean\n        val mean = depth.mean()\n        xIntercept.constant(mean)\n        tooltips { line(\"Depth mean: ${String.format(\"%.2f\", mean)}m\") }\n        color = Color.RED; width = 2.0\n    }\n    x.axis.name = \"depth, m\"\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#densityplot-plot","title":"<code>densityPlot</code> plot","text":"<p><code>densityPlot(statDensityArgs)</code> and <code>DataFrame.densityPlot(statDensityArgs)</code> are a family of functions for fast plotting a density plot.</p> <pre><code>densityPlot(depthList, kernel = Kernel.COSINE)\n</code></pre> <p></p> <pre><code>df.densityPlot(\"depth\")\n</code></pre> <p></p> <p>In case you want to provide input and weights using column selection DSL, it's a bit different from the usual one \u2014 you should assign <code>x</code> input and (optionally) <code>weight</code> throw invocation eponymous functions:</p> <pre><code>df.densityPlot(adjust = 0.5) {\n    x(depth)\n    weight(coeff)\n}\n</code></pre> <p></p> <p><code>densityPlot</code> plot can be configured with <code>.configure {}</code> extension \u2014 it opens context that combines area, <code>StatDensity</code> and plot context. That means you can configure bars settings, mappings using <code>StatDensity</code> dataset and any plot adjustments:</p> <pre><code>df.densityPlot {\n    x(depth)\n}.configure {\n    // Area + StatDensity + PlotContext\n    // Can't add new layer\n    // Can add area mapping, including for `Stat.*` columns\n    fillColor(Stat.scaled) // doesn't work properly for now\n    alpha = 0.6\n    // Can configure general plot adjustments\n    layout {\n        title = \"Configured `densityPlot` plot\"\n        size = 600 to 350\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#grouped-statdensity","title":"Grouped <code>statDensity</code>","text":"<p><code>statDensity</code> can be applied for grouped data \u2014 statistics will be calculated on each group independently but with equal categories. This application returns a new <code>GroupBy</code> dataset with the same keys as the old one but with <code>StatDensity</code> groups instead of old ones.</p> <pre><code>// Create two samples from normal distribution with different mean/std\nval rangesA = NormalDistribution(500.0, 100.0).sample(5000).toList()\nval rangesB = NormalDistribution(400.0, 80.0).sample(5000).toList()\n\n// Gather them into `DataFrame` with \"A\" and \"B\" keys in the \"category\" column\nval rangesDF = dataFrameOf(\n    \"range\" to rangesA + rangesB,\n    \"category\" to List(5000) { \"A\" } + List(5000) { \"B\" }\n)\nrangesDF.head()\n</code></pre> range category 503.671 A 560.585 A 525.12 A 488.74 A 357.084 A <p>It has the following signature:</p> range category <pre><code>// Group it by \"category\"\nval groupedRangesDF = rangesDF.groupBy { category }\ngroupedRangesDF\n</code></pre> categorygroup A rangecategory 503.671A 560.585A 525.12A 488.74A 357.084A B rangecategory 391.811B 291.449B 378.368B 408.26B 388.129B <p>Now we have a <code>GroupBy</code> with a signature</p> key: [category] group: DataFrame[range|category] A A-Group B B-Group <pre><code>groupedRangesDF.statDensity { x(range) }\n</code></pre> categorygroup A Stat { x: 107.258, density: 0, densityWeighted: 0, ... } B Stat { x: 117.39, density: 0, densityWeighted: 0, ... } <p>After <code>statDensity</code> applying it's still a <code>GroupBy</code> but with different signature of <code>group</code> - all groups have the same signature as usual <code>DataFrame</code> after <code>statDensity</code> applying (i.e. <code>StatDensityFrame</code>):</p> key: [drv] group: StaDensityFrame \"A\" \"A\"-Group \"B\" \"B\"-Group <p>As you can see, we did indeed do a <code>statDensity</code> transformation within groups, the grouping keys did not change. The plotting process doesn't change much \u2014 we do everything the same.</p> <pre><code>groupedRangesDF.plot {\n    statDensity(range) {\n        line {\n            x(Stat.x)\n            y(Stat.density)\n        }\n    }\n}\n</code></pre> <p></p> <p>As you can see, there are two lines because we have two groups of data. To distinguish them, we need to add mapping to the color from the key. This is convenient \u2014 the key is available in the context</p> <pre><code>groupedRangesDF.plot {\n    statDensity(range) {\n        line {\n            x(Stat.x)\n            y(Stat.density)\n            color(category)\n        }\n    }\n}\n</code></pre> <p></p> <p>The <code>densityPlot()</code> layer also works. Moreover, if we have exactly one grouping key, a mapping from it to <code>fillColor</code> and <code>borderLine.color</code> will be created by default.</p> <pre><code>groupedRangesDF.plot {\n    densityPlot(range)\n}\n</code></pre> <p></p> <p>We can customize it like we used to. From the differences \u2014 access to <code>key</code> columns:</p> <pre><code>groupedRangesDF.plot {\n    densityPlot(range) {\n        // Customize scale of default mapping\n        fillColor(category) {\n            scale = categorical(\"A\" to Color.GREEN, \"B\" to Color.ORANGE)\n        }\n        borderLine.color = Color.BLACK\n        alpha = 0.5\n    }\n}\n</code></pre> <p></p> <p>Also, we can stack areas (for that we need <code>x</code> coordinates to match \u2014 use <code>trim = true</code>):</p> <pre><code>groupedRangesDF.plot {\n    // Use trim\n    densityPlot(range, trim = true) {\n        // Adjust position of areas from different groups\n        position = Position.stack()\n        alpha = 0.8\n    }\n}\n</code></pre> <p></p> <p><code>densityPlot</code> plot for <code>GroupBy</code> (i.e. <code>GroupBy.densityPlot(statDensityArgs)</code> extensions) works as well:</p> <pre><code>groupedRangesDF.densityPlot(\"range\", bandWidth = BandWidth.value(10.0))\n</code></pre> <p></p> <p>... and can be configured the same way:</p> <pre><code>groupedRangesDF.densityPlot(n = 750, trim = true, adjust = 0.75) { x(range) }.configure {\n    alpha = 0.6\n    position = Position.stack()\n    // Can access key column by name as `String`\n    fillColor(\"category\") { scale = categoricalColorBrewer(BrewerPalette.Qualitative.Dark2) }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Density-Plot-Guide/#inside-groupby-plot-context","title":"Inside <code>groupBy{}</code> plot context","text":"<p>We can apply <code>groupBy</code> modification to the initial dataset and build a density plot with grouped data the same way:</p> <pre><code>rangesDF.plot {\n    groupBy(category) {\n        densityPlot(range)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/","title":"ErrorBars","text":"<p> Explore the versatility of Error Bars in Kotlin's Kandy library. This guide presents a comprehensive approach to depicting data variability and precision in your visualizations, enhancing the analytical depth of your charts. </p> <p> Error Bars in Kandy: A detailed guide to effectively representing data variability and precision in Kotlin, enriching your graphical data analysis. </p> <p> Enhance your charts with Error Bars in Kandy, showcasing data variability and precision in Kotlin-based visualizations. </p>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#plotting-means-and-error-ranges","title":"Plotting means and error ranges.","text":"<p>There are several ways to show error ranges on a plot. Among them are</p> <ul> <li><code>errorBars</code></li> <li><code>crossBars</code></li> <li><code>lineRanges</code></li> <li><code>pointRanges</code></li> </ul> <pre><code>// This example was found at: www.cookbook-r.com/Graphs/Plotting_means_and_error_bars_(ggplot2)\nval supp by columnOf(\"OJ\", \"OJ\", \"OJ\", \"VC\", \"VC\", \"VC\")\nval dose by columnOf(0.5, 1.0, 2.0, 0.5, 1.0, 2.0)\nval length by columnOf(13.23, 22.70, 26.06, 7.98, 16.77, 26.14)\nval len_min by columnOf(11.83, 21.2, 24.50, 4.24, 15.26, 23.35)\nval len_max by columnOf(15.63, 24.9, 27.11, 10.72, 19.28, 28.93)\nval dataset = dataFrameOf(supp, dose, length, len_min, len_max)\n</code></pre>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#error-bars-with-lines-and-points","title":"Error Bars with lines and points","text":"<pre><code>plot(dataset) {\n    x(dose)\n    errorBars {\n        yMin(len_min)\n        yMax(len_max)\n        borderLine.color(supp)\n\n        width = .1\n    }\n    line {\n        y(length)\n        color(supp)\n    }\n    points {\n        y(length)\n        color(supp)\n    }\n}\n</code></pre> <pre><code>val posD = Position.dodge(0.1)\nplot(dataset) {\n    x(dose)\n\n    errorBars {\n        yMin(len_min)\n        yMax(len_max)\n        borderLine.color(supp)\n\n        width = .1\n        position = posD\n    }\n\n    line {\n        y(length)\n        color(supp)\n\n        position = posD\n    }\n\n    points {\n        y(length)\n        color(supp)\n\n        position = posD\n    }\n}\n</code></pre> <pre><code>plot(dataset) {\n    x(dose)\n    groupBy(supp) {\n        errorBars {\n            yMin(len_min)\n            yMax(len_max)\n\n            borderLine.color = Color.BLACK\n            width = .1\n            position = posD\n        }\n    }\n\n\n    line {\n        y(length)\n        color(supp)\n\n        position = posD\n    }\n\n    points {\n        y(length)\n        color(supp)\n\n        size = 5.0\n        position = posD\n    }\n}\n</code></pre> <pre><code>val customColorScale = Scale.categorical&lt;Color, String&gt;(\n    range = listOf(Color.ORANGE, Color.named(\"dark_green\"))\n)\n</code></pre> <pre><code>plot(dataset) {\n    x(dose)\n\n    groupBy(supp) {\n        errorBars {\n            yMin(len_min)\n            yMax(len_max)\n\n            borderLine.color = Color.BLACK\n            width = .1\n            position = posD\n        }\n    }\n\n    line {\n        y(length)\n        color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    points {\n        y(length)\n        color(supp) { scale = customColorScale }\n\n        symbol = Symbol.CIRCLE_FILLED\n        size = 5.0\n        fillColor = Color.WHITE\n        position = posD\n    }\n\n    layout {\n        title = \"The Effect of Vitamin C on Tooth Growth in Guinea Pigs\"\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n\n        theme {\n            legend {\n                justification(1.0, 0.0)\n                position(1.0, 0.0)\n            }\n        }\n    }\n\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#error-bars-on-bar-plot","title":"Error Bars on bar plot","text":"<pre><code>plot(dataset) {\n    x(dose)\n\n    bars {\n        y(length)\n        fillColor(supp) { scale = customColorScale }\n\n        borderLine.color = Color.BLACK\n        position = Position.dodge()\n    }\n\n    groupBy(supp) {\n        errorBars {\n            yMin(len_min)\n            yMax(len_max)\n\n            borderLine.color = Color.BLACK\n            width = .1\n            position = Position.dodge(0.9)\n        }\n    }\n\n\n    layout {\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n\n        theme {\n            legend {\n                justification(0.0, 1.0)\n                position(0.0, 1.0)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#crossbars","title":"Crossbars","text":"<pre><code>plot(dataset) {\n    x(dose)\n\n    crossBars {\n        yMin(len_min)\n        yMax(len_max)\n        y(length)\n        borderLine.color(supp) { scale = customColorScale }\n\n        fatten = 5.0\n        position = Position.dodge(0.95)\n    }\n\n    layout {\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#lineranges","title":"LineRanges","text":"<pre><code>plot(dataset) {\n    x(dose)\n\n    lineRanges {\n        yMin(len_min)\n        yMax(len_max)\n        borderLine.color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    line {\n        y(length)\n        color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    layout {\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/ErrorBars-Guide/#pointranges","title":"PointRanges","text":"<pre><code>plot(dataset) {\n    x(dose)\n\n    pointRanges {\n        y(length)\n        yMin(len_min)\n        yMax(len_max)\n        color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    line {\n        y(length)\n        color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    layout {\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n    }\n}\n</code></pre> <pre><code>plot(dataset) {\n    x(dose)\n\n    line {\n        y(length)\n        color(supp) { scale = customColorScale }\n\n        position = posD\n    }\n\n    pointRanges {\n        y(length)\n        yMin(len_min)\n        yMax(len_max)\n\n        innerPoint {\n            fatten = 1.0\n            symbol = Symbol.DIAMOND_FILLED\n            fillColor(supp) { scale = customColorScale }\n        }\n\n        size = 5.0\n        color = Color.rgb(230, 230, 230)\n        position = posD\n    }\n\n    layout {\n        size = 700 to 400\n        xAxisLabel = \"Dose (mg)\"\n        yAxisLabel = \"Tooth length (mm)\"\n    }\n}\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Export-to-File-Guide/","title":"Export to File","text":"<p> Enhance your proficiency in preserving data visualizations using the guide to Kandy Export to File. Learn effective strategies to secure your graphs in a multitude of formats, thereby ensuring that your insights can be shared and remain longstanding. </p> <p> Kandy's Export to File guide: Save and share your visual masterpieces.  earn how to export charts in multiple formats, making your data visualization accessible and durable. </p> <p> Dive into Kandy's Export to File guide to understand the ways of preserving your charts for future reference. </p> <pre><code>// Create random density data\nval rand = java.util.Random(42)\nval n = 500\nval dataset = dataFrameOf(\n    \"rating\" to List(n / 2) { rand.nextGaussian() } + List(n / 2) { rand.nextGaussian() * 1.5 + 1.5 },\n    \"cond\" to List(n / 2) { \"A\" } + List(n / 2) { \"B\" }\n)\n</code></pre> <pre><code>// Density plot\nval myPlot = plot(dataset) {\n    groupBy(cond) {\n        densityPlot(rating, trim = true) {\n            fillColor = Color.GREY\n            alpha = 0.6\n            borderLine.color(\"cond\")\n        }\n    }\n}\n\nmyPlot\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Export-to-File-Guide/#export-png-to-file","title":"Export PNG to file","text":"<pre><code>val pathPNG = myPlot.save(\"myDensity.png\")\n</code></pre> <pre><code>javax.imageio.ImageIO.read(File(pathPNG))\n</code></pre>"},{"location":"kandy/docs/topics/guides/Export-to-File-Guide/#export-svg-to-file","title":"Export SVG to file","text":"<pre><code>val pathSVG = myPlot.save(\"myDensity.svg\")\n</code></pre> <pre><code>HTML(File(pathSVG).readText())\n</code></pre>"},{"location":"kandy/docs/topics/guides/Export-to-File-Guide/#export-html-to-file","title":"Export HTML to file","text":"<pre><code>val pathHTML = myPlot.save(\"myDensity.html\")\n</code></pre> <pre><code>HTML(File(pathHTML).readText())\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/","title":"Facets","text":"<p> Get proficient in presenting multidimensional data with the guide by Kandy on Facets. Discover how to use faceting successfully for a comprehensive comparative analysis among diverse data subsets. </p> <p> Kandy's Facets guide: A deep dive into multi-faceted data visualization. Explore techniques to compare and contrast data segments effectively. </p> <p> Enhance your data analysis with Kandy's Facets guide. Discover advanced strategies for comparative visualization, bringing clarity to complex data sets. </p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#creating-multi-panel-plots-using-facets","title":"Creating multi-panel plots using <code>facets</code>.","text":""},{"location":"kandy/docs/topics/guides/Facets-Guide/#problem","title":"Problem","text":"<p>You want to see more aspects of your data, and it's not practical to use the regular <code>aesthetics</code> approach for that.</p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#solution-facets","title":"Solution - <code>facets</code>","text":"<p>You can add one or more new dimensions to your plot using <code>faceting</code>.</p> <p>This approach allows you to split up your data by one or more variables and plot the subsets of data together.</p> <p>In this demo, we will explore how various faceting functions work, as well as the built-in <code>sorting</code> and <code>formatting</code> options.</p> <p>To learn more about formatting templates, see: Formatting.</p> <pre><code>val dataset = DataFrame.readCSV(\n    \"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg2.csv\",\n    parserOptions = ParserOptions(Locale.ENGLISH)\n)\n\ndataset.head(3)\n</code></pre> miles per gallon number of cylinders engine displacement \\(cu. inches\\) engine horsepower vehicle weight \\(lbs.\\) time to accelerate \\(sec.\\) model year origin of car vehicle name 18 8 307 130 3504 12 70 US chevrolet chevelle malibu 15 8 350 165 3693 11.5 70 US buick skylark 320 18 8 318 150 3436 11 70 US plymouth satellite"},{"location":"kandy/docs/topics/guides/Facets-Guide/#one-plot","title":"One plot","text":"<p>Create a scatter plot to show how <code>mpg</code> is related to a car's <code>engine horsepower</code>.</p> <p>Also use the <code>color</code> aesthetic to visualize the region where a car was designed.</p> <pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(`miles per gallon`)\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 350\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#more-dimensions","title":"More dimensions","text":"<p>There are two functions for faceting:</p> <ul> <li><code>facetGrid()</code></li> <li><code>facetWrap()</code></li> </ul> <p>The former creates 2-D matrix of plot panels, and the latter creates 1-D strip of plot panels.</p> <p>We'll be using the <code>number of cylinders</code> variable as the first faceting variable, and sometimes the <code>origin of car</code> as a second faceting variable.</p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetgrid","title":"facetGrid()","text":"<p>The data can be split up by one or two variables that vary in the X and/or Y direction.</p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#one-facet","title":"One facet","text":"<p>Let's split up the data by <code>number of cylinders</code>.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetGridX(`number of cylinders`)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#two-facets","title":"Two facets","text":"<p>Split up the data by two faceting variables: <code>number of cylinders</code> and <code>origin of car</code>.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetGrid(`number of cylinders`, `origin of car`)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#formatting-and-sorting","title":"Formatting and sorting.","text":"<p>Apply a formatting template to the <code>number of cylinders</code> and sort the <code>origin of car</code> values in descending order.</p> <p>To learn more about formatting templates, see: Formatting.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetGrid(`number of cylinders`, `origin of car`, xFormat = \"{d} cyl\", yOrder = OrderDirection.DESCENDING)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetwrap","title":"facetWrap()","text":"<p>The data can be split up by one or more variables. The panel layout is flexible and controlled by <code>ncol</code>, <code>nrow</code> and <code>dir</code> options.</p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facet-wrap-one-column","title":"Facet Wrap One Column","text":"<p>Split data by the <code>number of cylinders</code> variable and arrange tiles in two rows.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetWrap(nRow = 2) {\n        facet(`number of cylinders`)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facet-wrap-two-columns","title":"Facet Wrap Two Columns","text":"<p>Split data by <code>origin of car</code> and <code>number of cylinders</code> and arrange tiles in five columns.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetWrap(nCol = 5) {\n        facet(`origin of car`)\n        facet(`number of cylinders`)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#arrange-panels-vertically","title":"Arrange panels vertically.","text":"<p>Use the <code>dir</code> parameter to arrange tiles by columns, in three columns (the default tile arrangement is \"by row\").</p> <p>Also, format <code>number of cylinders</code> labels and reverse the sorting direction for this faceting variable.</p> <pre><code>dataset.plot {\n    points {\n        x(`engine horsepower`)\n        y(`miles per gallon`)\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n    }\n    facetWrap(nCol = 3, direction = Direction.VERTICAL) {\n        facet(`origin of car`, OrderDirection.ASCENDING, null)\n        facet(`number of cylinders`, OrderDirection.DESCENDING, \"{} cyl\")\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#free-scales-on-faceted-plot","title":"Free scales on faceted plot","text":"<pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(\"engine displacement (cu. inches)\"&lt;Double&gt;())\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 350\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#faceted-plot","title":"Faceted plot","text":""},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetgrid-with-fixed-scales-the-default","title":"<code>facetGrid()</code> with <code>fixed</code> scales (the default)","text":"<p>Scales are constant across all panels.</p> <pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(\"engine displacement (cu. inches)\"&lt;Double&gt;())\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 500\n    }\n    facetGridY(`origin of car`)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetgrid-with-free-y-scales","title":"<code>facetGrid()</code> with <code>free</code> Y-scales","text":"<pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(\"engine displacement (cu. inches)\"&lt;Double&gt;())\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 500\n    }\n    facetGridY(`origin of car`, scalesSharing = ScalesSharing.FREE_Y)\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetwrap-with-fixed-scales-the-default","title":"<code>facetWrap()</code> with <code>fixed</code> scales (the default)","text":"<p>Scales are constant across all panels.</p> <pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(\"engine displacement (cu. inches)\"&lt;Double&gt;())\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 500\n    }\n    facetWrap {\n        facet(`number of cylinders`, order = OrderDirection.ASCENDING)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Facets-Guide/#facetwrap-with-free-scales-along-both-axes","title":"<code>facetWrap()</code> with <code>free</code> scales along both axes","text":"<pre><code>dataset.plot {\n    x(`engine horsepower`)\n    y(\"engine displacement (cu. inches)\"&lt;Double&gt;())\n    points {\n        color(`origin of car`)\n    }\n    layout {\n        theme(Theme.Grey)\n        size = 800 to 500\n    }\n    facetWrap(scalesSharing = ScalesSharing.FREE) {\n        facet(`number of cylinders`, order = OrderDirection.ASCENDING)\n    }\n}\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/","title":"Formatting","text":"<p> Hone your skills in precise communication through data visualization with Kandy's Label Format guide. Discover how to tailor label formats to improve the clarity and accuracy in your data plots. </p> <p> Enhance your data storytelling with Kandy's Label Format guide. Discover how to format labels for clearer, more precise data representation. </p> <p> Unlock the potential of effective labeling in data visualization with Kandy's Label Format guide. Tailor your plot labels for maximum clarity and impact. </p> <p>This guide is taken from lets-plot: Formatting.</p> <p>Formatting provides the ability to do complex variable substitutions and value formatting.</p>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#number-format","title":"Number format","text":"<p>The numeric format strings are used to format common numeric types. The general form of a format specifier is:</p> <pre><code>[[fill]align][sign][symbol][0][width][,][.precision][type]\n</code></pre> <ul> <li> <p><code>fill</code> \u2014 can be any character, defaults to a space if omitted.   The presence of a fill character is signaled by the <code>*align*</code> character following it,   which must be one of the alignment options.</p> </li> <li> <p><code>align</code> \u2014 the various alignment options are as follows:</p> <ul> <li><code>&gt;</code> \u2014 forces the field to be right-aligned within the available space (default behavior);</li> <li><code>&lt;</code> \u2014 forces the field to be left-aligned within the available space;</li> <li><code>^</code> \u2014 forces the field to be centered within the available space;</li> <li><code>=</code> \u2014 like <code>&gt;</code>, but with any sign and symbol to the left of any padding.</li> </ul> </li> <li> <p><code>sign</code> can be:</p> <ul> <li><code>-</code> \u2014 nothing for zero or positive and a minus sign for negative (default behavior);</li> <li><code>+</code> \u2014 a plus sign for zero or positive and a minus sign for negative;</li> <li><code></code> (space) \u2014 a space for zero or positive and a minus sign for negative.</li> </ul> </li> <li> <p><code>symbol</code> can be:</p> <ul> <li><code>$</code> \u2014 apply currency symbols per the locale definition;</li> <li><code>#</code> \u2014 for binary, octal, or hexadecimal notation, prefix by <code>0b</code>, <code>0o</code>, or <code>0x</code>, respectively.</li> </ul> </li> <li> <p><code>zero</code> (<code>0</code>) option enables zero-padding; this implicitly sets fill to <code>0</code> and align to <code>=</code>.</p> </li> <li> <p><code>width</code> defines the minimum field width; if not specified, then the width will be determined by the content.</p> </li> <li> <p><code>comma</code> (<code>,</code>) option enables the use of a group separator, such as a comma, for thousands.</p> </li> <li> <p><code>precision</code> depending on the <code>type</code>, the <code>precision</code> either indicates the number of digits that follow the   decimal point (types <code>f</code> and <code>%</code>), or the number of significant digits (types <code></code>, <code>e</code>, <code>g</code>, <code>r</code>, <code>s</code> and <code>p</code>).   If the precision is not specified, it defaults to 6 for all types except (none), which defaults to 12.   Precision is ignored for integer formats (types <code>b</code>, <code>o</code>, <code>d</code>, <code>x</code>, <code>X</code> and <code>c</code>).</p> </li> <li> <p><code>type</code> determines how the data should be presented:</p> <ul> <li><code>e</code> \u2014 exponent notation;</li> <li><code>f</code> \u2014 fixed point notation;</li> <li><code>g</code> \u2014 either decimal or exponent notation, rounded to significant digits;</li> <li><code>s</code> \u2014 decimal notation with an SI prefix, rounded to significant digits;</li> <li><code>%</code> \u2014 multiply by 100, and then decimal notation with a percent sign;</li> <li><code>b</code> \u2014 binary notation, rounded to integer;</li> <li><code>o</code> \u2014 octal notation, rounded to integer;</li> <li><code>d</code> \u2014 decimal notation, rounded to integer;</li> <li><code>x</code> \u2014 hexadecimal notation, using lower-case letters, rounded to integer;</li> <li><code>X</code> \u2014 hexadecimal notation, using upper-case letters, rounded to integer;</li> <li><code>c</code> \u2014 simple toString.</li> </ul> </li> </ul> <p>The following SI prefixes are supported for <code>s</code> type:</p> <pre><code>* `y` \u2014 yocto, 10\u207b\u00b2\u2074\n* `z` \u2014 zepto, 10\u207b\u00b2\u00b9\n* `a` \u2014 atto, 10\u207b\u00b9\u2078\n* `f` \u2014 femto, 10\u207b\u00b9\u2075\n* `p` \u2014 pico, 10\u207b\u00b9\u00b2\n* `n` \u2014 nano, 10\u207b\u2079\n* `\u00b5` \u2014 micro, 10\u207b\u2076\n* `m` \u2014 milli, 10\u207b\u00b3\n* ` ` (none) - 10\u2070\n* `k` \u2014 kilo, 10\u00b3\n* `M` \u2014 mega, 10\u2076\n* `G` \u2014 giga, 10\u2079\n* `T` \u2014 tera, 10\u00b9\u00b2\n* `P` \u2014 peta, 10\u00b9\u2075\n* `E` \u2014 exa, 10\u00b9\u2078\n* `Z` \u2014 zetta, 10\u00b2\u00b9\n* `Y` \u2014 yotta, 10\u00b2\u2074\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#examples-of-number-format","title":"Examples of Number Format","text":"<p>Let's format the number <code>42</code>:</p> <pre><code>08d       --&gt;  \"00000042\"\n_&lt;8d      --&gt;  \"______42\"\n_=8d      --&gt;  \"___42___\"\n_=+8d     --&gt;  \"+_____42\"\n_^11.0%   --&gt;  \"____42%____\"\n_^11,.0%  --&gt;  \"__42,200%__\"\n+08,d     --&gt;  \"+0,000,042\"\n.1f       --&gt;  \"42.0\"\n+.3f      --&gt;  \"+42.000\"\nb         --&gt;  \"101010\"\n#b        --&gt;  \"0b101010\"\no         --&gt;  \"52\"\ne         --&gt;  \"4.200000e+1\"\ns         --&gt;  \"42.0000\"\n020,s     --&gt;  \"000,000,000,042.0000\"\n020.0%    --&gt;  \"0000000000000004200%\"\n</code></pre> <p>Some other examples:</p> <pre><code>format   number        result\n.1f      0.42          \"0.4\"\n.3g      0.4449        \"0.445\"\n,.12g    -4200000      \"-4,200,000\" \n0,.2f    1234567.449   \"1,234,567.45\"\n+$,.2f   1e4           \"+$10,000.00\"\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#string-template","title":"String template","text":"<p>The number format can be used in a template to create a string with variable substitution. The string template contains \u201creplacement fields\u201d surrounded by curly braces <code>{}</code>. Anything not contained in braces is considered literal text, which is copied unchanged to the result string. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}. This approach is used in function <code>tooltips()</code> to customize the content of tooltips.</p>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#date-and-time-format","title":"Date and Time Format","text":"<p>Provides formats for date and time values.</p> <p>The list of supported directives to format date/time values:</p> <ul> <li><code>%a</code> \u2014 weekday as an abbreviated name (Sun, Mon, \u2026, Sat);</li> <li><code>%A</code> \u2014 weekday as a full name (Sunday, Monday, \u2026, Saturday)</li> <li><code>%b</code> \u2014 month as an abbreviated name (Jan, Feb, \u2026, Dec);</li> <li><code>%B</code> \u2014 month as a full name (January, February, \u2026, December);</li> <li><code>%d</code> \u2014 day of the month as a zero-padded decimal number (01, 02, \u2026, 31);</li> <li><code>%e</code> \u2014 day of the month as a decimal number (1, 2, \u2026, 31);</li> <li><code>%j</code> \u2014 day of the year as a zero-padded decimal number (001, 002, \u2026, 366).</li> <li><code>%m</code> \u2014 month as a zero-padded decimal number (01, 02, \u2026, 12);</li> <li><code>%w</code> \u2014 weekday as a decimal number, where 0 is Sunday and 6 is Saturday (0, 1, \u2026, 6);</li> <li><code>%y</code> \u2014 year without century as a zero-padded decimal number (00, 01, \u2026, 99);</li> <li><code>%Y</code> \u2014 year with century as a decimal number (0001, 0002, \u2026, 2013, 2014, \u2026, 9998, 9999);</li> <li><code>%H</code> \u2014 hour (24-hour clock) as a zero-padded decimal number (00, 01, \u2026, 23);</li> <li><code>%I</code> \u2014 hour (12-hour clock) as a zero-padded decimal number (01, 02, \u2026, 12);</li> <li><code>%l</code> \u2014 hour (12-hour clock) as a decimal number (1, 2, \u2026, 12);</li> <li><code>%M</code> \u2014 minute as a zero-padded decimal number (00, 01, \u2026, 59);</li> <li><code>%p</code> \u2014 \"AM\" or \"PM\" according to the given time value;</li> <li><code>%P</code> \u2014 like %p but in lowercase: \"am\" or \"pm\";</li> <li><code>%S</code> \u2014 second as a zero-padded decimal number (00, 01, \u2026, 59).</li> </ul>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#examples-of-date-and-time-format","title":"Examples of Date and Time Format","text":"<p>Let's apply the format string to the date <code>Aug 6, 2019</code> and the time <code>4:46:35</code>:</p> <pre><code>%a  --&gt;  \"Tue\"\n%A  --&gt;  \"Tuesday\"\n%b  --&gt;  \"Aug\"\n%B  --&gt;  \"August\"\n%d  --&gt;  \"06\"\n%e  --&gt;  \"6\"\n%j  --&gt;  \"218\"\n%m  --&gt;  \"08\"\n%w  --&gt;  \"2\" \n%y  --&gt;  \"19\"\n%Y  --&gt;  \"2019\"\n%H  --&gt;  \"04\"\n%I  --&gt;  \"04\"\n%l  --&gt;  \"4\"\n%M  --&gt;  \"46\"\n%P  --&gt;  \"am\"\n%p  --&gt;  \"AM\"\n%S  --&gt;  \"35\"\n\n\n%Y-%m-%dT%H:%M:%S      --&gt;  \"2019-08-06T04:46:35\"\n%m/%d/%Y               --&gt;  \"08/06/2019\"\n%m-%d-%Y %H:%M         --&gt;  \"08-06-2019 04:46\"\n%d.%m.%y               --&gt;  \"06.08.19\"\n%A, %b %e, %Y          --&gt;  \"Tuesday, Aug 6, 2019\"\n%b %d, %l:%M %p        --&gt;  \"Aug 06, 4:46 AM\"\n%B %Y                  --&gt;  \"August 2019\"\n%b %e, %Y              --&gt;  \"Aug 6, 2019\"\n%a, %e %b %Y %H:%M:%S  --&gt;  \"Tue, 6 Aug 2019 04:46:35\"\n%B %e %Y %H:%M %p      --&gt;  \"August 6 2019 04:46 AM\"\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#label-format","title":"Label Format","text":"<pre><code>// The US Unemployment Rates 2000-2016\nval economics = DataFrame.readCSV(\n    \"https://vincentarelbundock.github.io/Rdatasets/csv/ggplot2/economics.csv\",\n    parserOptions = ParserOptions(Locale.ENGLISH)\n).filter { \"date\"&lt;LocalDate&gt;() &gt;= LocalDate(2001, 1, 1) }\n\neconomics.head()\n</code></pre> rownames date pce pop psavert uempmed unemploy 403 2001-01-01 6977 283920 4.8 5.8 6023 404 2001-02-01 6995.8 284137 4.9 6.1 6089 405 2001-03-01 6987.9 284350 5.3 6.6 6141 406 2001-04-01 7001.2 284581 5 5.9 6271 407 2001-05-01 7047.1 284810 4.5 6.3 6226"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#default-plot-no-formatting","title":"Default plot (no formatting)","text":"<pre><code>economics.plot {\n    line {\n        x(date)\n        y(uempmed) { axis.name = \"unemployment rate\" }\n    }\n    layout.size = 900 to 400\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#apply-formatting-to-x-and-y-axis-labels","title":"Apply formatting to X and Y axis labels","text":"<p>Use the <code>format</code> parameter in <code>breaks()</code> for axis.</p> <p>Text in tooltips is now also formatted.</p> <p>{style=\"note\"}</p> <pre><code>economics.plot {\n    line {\n        x(date) { axis.breaks(format = \"%b %Y\") }\n        y(uempmed) {\n            axis {\n                name = \"unemployment rate\"\n                breaks(format = \"{} %\")\n            }\n        }\n    }\n    layout.size = 900 to 400\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#format-axis-labels-for-breaks-specified-manually","title":"Format axis labels for breaks specified manually","text":"<pre><code>economics.plot {\n    line {\n        x(date) { axis.breaks(format = \"%b %Y\") }\n        y(uempmed) {\n            axis {\n                name = \"unemployment rate\"\n                breaks(listOf(5.0, 15.0, 25.0), format = \"{} %\")\n            }\n        }\n    }\n    layout.size = 900 to 400\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#configure-tooltips-text-and-location","title":"Configure tooltip's text and location","text":"<pre><code>economics.plot {\n    line {\n        x(date) { axis.breaks(format = \"%b %Y\") }\n        y(uempmed) {\n            axis {\n                name = \"unemployment rate\"\n                breaks(format = \"{} %\")\n            }\n        }\n        tooltips(anchor = Anchor.TOP_CENTER, minWidth = 170.0) {\n            line(\"Unemployment rate:|^y\")\n        }\n    }\n    layout.size = 900 to 400\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#format-value-shown-in-tooltip","title":"Format value shown in tooltip","text":"<pre><code>economics.plot {\n    line {\n        x(date)\n        y(uempmed) {\n            axis {\n                name = \"unemployment rate\"\n            }\n        }\n        tooltips(formats = mapOf(date to \"%B %Y\"), anchor = Anchor.TOP_CENTER, minWidth = 170.0) {\n            line(\"@uempmed % in @date\")\n        }\n    }\n    layout.size = 900 to 400\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#adding-to-the-unemployment-rate-mean","title":"Adding to the unemployment rate mean","text":"<pre><code>val unemploymentMean = economics[uempmed].mean()\n\n\neconomics.plot {\n    x(date)\n    y(uempmed)\n    line {\n        tooltips(formats = mapOf(date to \"%B %Y\"), anchor = Anchor.TOP_CENTER, minWidth = 170.0) {\n            line(\"Unemployment rate:|^y %\")\n        }\n    }\n    hLine {\n        yIntercept.constant(unemploymentMean)\n        color = Color.RED\n        type = LineType.DASHED\n        tooltips(hide = true)\n    }\n    text {\n        label = \"${String.format(\"%.2f\", unemploymentMean)} %\"\n        x.constant(LocalDate(2001, 1, 1).atStartOfDayIn(TimeZone.currentSystemDefault()).toEpochMilliseconds())\n        y.constant(unemploymentMean + 0.5)\n    }\n    layout {\n        title = \"The US Unemployment Rates 2000-2016.\"\n        yAxisLabel = \"unemployment rate\"\n        size = 900 to 400\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Formatting-Guide/#tooltip-customization","title":"Tooltip Customization","text":"<p>You can format text in tooltips, see: Tooltips.</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/","title":"Heatmap","text":"<p> Explore the 'Heatmap' guide in Kandy, a powerful tool for visualizing complex data matrices and uncovering hidden patterns and correlations. With the aid of this guide, you'll be able to manipulate large data sets and unlock insights to drive your decision-making process. </p> <p> Kandy's 'Heatmap' guide simplifies visual analysis of data matrices, making it easier to spot trends and relationships. </p> <p> Explore Kandy's Heatmap guide to become proficient in depicting data matrices.  Effortlessly discover patterns and insights within your data visualizations.  </p> <p>Statistics \"count2d\" are calculated on the sample of two categorical variables (usually provided as two samples of single variable \u2014 <code>x</code> and <code>y</code>). It counts the number of observations in each pair of x-category and y-category. It's weighted, it means the weighted count for each pair is calculated (each element within a pair is counted along with its weight).</p> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#usage","title":"Usage","text":"<p>\"Count2D\" plots give a visual representation of the two-variable discrete sample distribution.</p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#arguments","title":"Arguments","text":"<ul> <li>Input (mandatory):<ul> <li><code>x</code> \u2014 <code>x</code>-part of input sample</li> <li><code>y</code> \u2014 <code>y</code>-part of input sample</li> </ul> </li> <li>Weights (optional):<ul> <li><code>weights</code> \u2014 set of weights of the same size as the input samples.   <code>null</code> (by default) means all weights are equal to <code>1.0</code> and the weighted count is equal to the normal one</li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"count2d\" statistic (which will be discussed further below \u2014 different variations of <code>statCount2D()</code>, <code>heatmap()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statCount2DArgs := \n   x,\n   y, \n   weights = null\n</code></pre> <p>The possible types of <code>x</code>, <code>y</code> and <code>weights</code> depend on where a certain function is used. They can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself. <code>x</code> elements are type of <code>X</code> \u2014 generic type parameter, <code>y</code> elements are type of <code>Y</code> \u2014 generic type parameter.</p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#output-statistics","title":"Output statistics","text":"name type description Stat.x X <code>x</code>-category Stat.y Y <code>y</code>-category Stat.count Int Number of observations in this category Stat.countWeighted Double Weighted count (sum of observations weights in this category)"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#statcount-plots","title":"StatCount plots","text":"<pre><code>// Use \"mpg\" dataset\nval mpgDF =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDF.head(5)\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact <pre><code>// We need only three columns\nval df = mpgDF[\"class\", \"drv\", \"hwy\"]\ndf.head(5)\n</code></pre> class drv hwy compact f 29 compact f 29 compact f 31 compact f 30 compact f 26 <p>It has a signature</p> class drv hwy <p>Let's take a look at <code>StatCount2D</code> output DataFrame:</p> <pre><code>df.statCount2D(\"class\", \"drv\", \"hwy\")\n</code></pre> Stat xycountcountWeighted compactf351020 compact412310 midsize4372 suvr11192 2seaterr5124 <p>It has the following signature:</p> Stat x y count countWeighted <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statCount2D</code>, each row corresponds to one pair of categories. <code>Stat.x</code> is the column with its <code>x</code>-category. <code>Stat.y</code> is the column with its <code>y</code>-category. <code>Stat.count</code> contains the number of observations in the pair. <code>Stat.countWeighted</code> \u2014 weighted version of <code>count</code>. <code>DataFrame</code> with \"count2D\" statistics is called <code>StatCount2DFrame</code></p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#statcount2d-plot-transform","title":"<code>statCount2D</code> plot transform","text":"<p><code>statCount2D(statCount2DArgs) { /*new plotting context*/ }</code> modifies a plotting context \u2014 instead of original data (no matter was it empty or not) new <code>statCount2D</code> dataset (calculated on given arguments; inputs and weights can be provided as <code>Iterable</code> or as dataset column reference - by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected \u2014 you can add layers using initial dataset outside the <code>statCount2D</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context:</p> <pre><code>df.plot {\n    statCount2D(`class`, drv) {\n        // New `StatCount` dataset here\n        points {\n            // Use `Stat.*` columns for mappings\n            x(Stat.x) {\n                axis.expand(0.0, 0.5)\n            }\n            y(Stat.y)\n            size(Stat.count) {\n                scale = continuous(10.0..30.0)\n            }\n            color = Color.RED\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#heatmap-layer","title":"Heatmap layer","text":"<p>Heatmap is a statistical plot used for visualizing the distribution of two categorical variables sample. It's a tile plot where each tile is representing one of a pair of categories: its <code>x</code> coordinate is corresponding to <code>x</code> category, <code>y</code> to <code>y</code> category, and its color is to count of this pair. So basically, we can build a heatmap with <code>statCount2D</code> as follows:</p> <pre><code>val statCount2DAndTilePlot = df.plot {\n    statCount2D(\"class\", \"drv\") {\n        tiles {\n            x(Stat.x)\n            y(Stat.y)\n            fillColor(Stat.count)\n        }\n    }\n    layout.title = \"`statCount2D()` + `tile()` layer\"\n}\nstatCount2DAndTilePlot\n</code></pre> <p></p> <p>But we can do it even faster with <code>heatmap(statCount2DArgs)</code> method:</p> <pre><code>val heatmapLayerPlot = df.plot {\n    heatmap(`class`, drv)\n    layout.title = \"`heatmap()` layer\"\n}\nheatmapLayerPlot\n</code></pre> <p></p> <p>Let's compare them:</p> <pre><code>plotGrid(listOf(statCount2DAndTilePlot, heatmapLayerPlot))\n</code></pre> <p></p> <p>These two plots are identical. Indeed, <code>heatmap</code> just uses <code>statCount2D</code> and <code>tile</code> and performs coordinates and <code>fillColor</code> mappings under the hood. And we can customize heatmap layer: <code>heatmap()</code> optionally opens a new context, where we can configure tiles (as in the usual context opened by <code>tile { ... }</code>) \u2014 even change default mappings. <code>StatCount2D</code> dataset of heatmap also can be accessed here.</p> <pre><code>df.plot {\n    heatmap(`class`, drv) {\n        // Swap coordinate mappings:\n        x(Stat.y)\n        y(Stat.x)\n        // Default mapping but with custom scale\n        fillColor(Stat.count) {\n            scale = continuousColorBrewer(BrewerPalette.Sequential.Reds)\n        }\n    }\n}\n</code></pre> <p></p> <p>If we specify weights, <code>Stat.countWeighted</code> is mapped to <code>fillColor</code> by default:</p> <pre><code>df.plot {\n    heatmap(`class`, drv, hwy)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Heatmap-Guide/#heatmap-plot","title":"<code>heatmap</code> plot","text":"<p><code>heatmap(statCount2DArgs)</code> and <code>DataFrame.heatmap(statCount2DArgs)</code> are a family of functions for fast plotting a heatmap.</p> <pre><code>heatmap(\n    listOf(\"A\", \"A\", \"A\", \"B\", \"B\", \"C\", \"B\", \"B\"),\n    listOf(1, 1, 1, 2, 1, 2, 1, 2),\n)\n</code></pre> <p></p> <pre><code>df.heatmap(\"class\", \"drv\")\n</code></pre> <p></p> <p>In case you want to provide inputs and weights using column selection DSL, it's a bit different from the usual one \u2014 you should assign <code>x</code> and <code>y</code> inputs and (optionally) <code>weight</code> throw invocation eponymous functions:</p> <pre><code>df.heatmap {\n    x(`class`)\n    y(drv)\n    weight(hwy)\n}\n</code></pre> <p></p> <p>Heatmap plot can be configured with <code>.configure {}</code> extension \u2014 it opens context that combines tile, <code>StatCount2D</code> and plot context. That means you can configure tile settings, mappings using <code>StatCount2D</code> dataset and any plot adjustments:</p> <pre><code>df.heatmap {\n    x(`class`)\n    y(drv)\n    weight(hwy)\n}.configure {\n    // Tile + StatCount2D + PlotContext\n    // Can't add new layer\n    // Can add tile mapping, including for `Stat.*` columns\n    fillColor(Stat.count) {\n        scale = continuous(Color.GREEN..Color.RED)\n    }\n    alpha = 0.6\n    // Can configure general plot adjustments\n    layout {\n        title = \"Configured `heatmap` plot\"\n        size = 600 to 350\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/","title":"Histogram","text":"<p> Delve into Kandy's 'Histogram' guide to understand the nuances of visualizing frequency distributions. Learn how to effectively represent data variations and trends. </p> <p> Kandy's 'Histogram' guide offers a deep dive into frequency visualization. Discover how to bring data distributions to life in your plots. </p> <p> Explore Kandy's guide on creating histograms for insightful data analysis. Learn the keys to visualizing and interpreting frequency distributions. </p> <p>Statistics \"bin\" are counted on the sample of a single continuous variable. Firstly, it divides the range of values into bins (sequential, non-overlapping sections), and then it counts the number of observations in each bin. It's weighted, it means the weighted count for each bin is calculated (each element within a bin counted along with its weight). It's really important to carefully choose a bin-constructing method (for example, by the exact number of bins or by their width). This decision has a big impact on how the data is shown and studied. It makes sure that the way the data is shown is natural to understand and gives a true picture of the information.</p> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#usage","title":"Usage","text":"<p>Binning is commonly used in statistics and data analysis to simplify complex data sets and make them easier to interpret. Histogram (or any other plot with \"bin\" statistics) helps to give an overview of the sample distribution.</p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#arguments","title":"Arguments","text":"<ul> <li>Input (mandatory):<ul> <li><code>x</code> \u2014 numeric sample on which the statistics are calculated</li> </ul> </li> <li>Weights (optional):<ul> <li><code>weights</code> \u2014 set of weights of the same size as the input sample.   <code>null</code> (by default) means all weights are equal to <code>1.0</code> and the weighted count is equal to the normal one</li> </ul> </li> <li>Parameters (optional):<ul> <li><code>binsOption: BinsOption</code> \u2014 specifies either the number of bins or their width:<ul> <li><code>BinsOption.byNumber(n: Int)</code> \u2014 values are divided into <code>n</code> bins (bins width is derived)</li> <li><code>BinsOption.byWidth(width: Double)</code> \u2014 values are divided into bins of width <code>width</code>   (the number of bins is derived)</li> </ul> </li> <li><code>binsAlign: BinsAlign</code> \u2014 specifies bins aligning:<ul> <li><code>BinsAlign.center(pos: Double)</code> \u2014 bins are aligned by centering bin in <code>pos</code></li> <li><code>BinsAlign.boundary(pos: Double)</code> \u2014 bins are aligned by boundary between two bins in <code>pos</code></li> <li><code>BinsAlign.none()</code> \u2014 no aligning</li> </ul> </li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"bin\" statistic (which will be discussed further below - different variations of <code>statBin()</code>, <code>histogram()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statBinArgs := \n   x, \n   weights = null, \n   binsOption: BinsOption = BinsOption.byNumber(20), \n   binsAlign: BinsAlign = BinsAlign.center(0.0)\n</code></pre> <p>The possible types of <code>x</code> and <code>weights</code> depend on where a certain function is used. They can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself.</p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#output-statistics","title":"Output statistics","text":"name type description Stat.x Double Center of bin Stat.count Int Number of observations in this bin Stat.countWeighted Double Weighted count (sum of observations weights in this bin) Stat.density Double Empirically estimated density in this bin Stat.densityWeighted Double Weighted density"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#statbin-plots","title":"StatBin plots","text":"<pre><code>// Generate sample from normal distribution\nval depthList = NormalDistribution(500.0, 100.0).sample(1000).toList()\n// Generate sample from uniform distribution\nval coeffList = UniformRealDistribution(0.0, 1.0).sample(1000).toList()\n// gather them into the DataFrame\nval df = dataFrameOf(\n    \"depth\" to depthList,\n    \"coeff\" to coeffList\n)\ndf.head()\n</code></pre> depth coeff 458.195 0.343 336.811 0.807 762.538 0.101 692.733 0.51 424.594 0.873 <p><code>df</code> has a signature</p> depth coeff <p>Let's take a look at <code>StatBin</code> output DataFrame:</p> <pre><code>df.statBin(\"depth\", \"coeff\", binsOption = BinsOption.byNumber(10))\n</code></pre> Stat xcountcountWeighteddensitydensityWeighted 167.13110.32500 233.98483.6800 300.8363318.90100.001 367.68911057.0110.0020.002 434.541216112.5680.0030.003 <p>It has the following signature:</p> Stat x count countWeighted density densityWeighted <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statBin</code>, each row corresponds to one bin. <code>Stat.x</code> is the column with the centers of the bins. <code>Stat.count</code> contains the number of observations in the bin. <code>Stat.countWeighted</code> \u2014 weighted version of <code>count</code>. There are also <code>Stat.density</code> and <code>Stat.densityWeighted</code>. They contain empirically estimated density (both normal and weighted) of the sample in the points corresponding to the centers of bins.</p> <p><code>DataFrame</code> with \"bin\" statistics is called <code>StatBinFrame</code></p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#statbin-context-transform","title":"<code>statBin</code> context transform","text":"<p><code>statBin(statBinArgs) { /*new plotting context*/ }</code> modifies a plotting context \u2014 instead of original data (no matter was it empty or not) new <code>StatBin</code> dataset (calculated on given arguments. Inputs and weights can be provided as <code>Iterable</code> or as dataset column reference \u2014 by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected \u2014 you can add layers using initial dataset outside the <code>statBin</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context:</p> <pre><code>plot {\n    statBin(depthList, binsAlign = BinsAlign.center(500.0)) {\n        // new `StatBin` dataset here\n        area {\n            // use `Stat.*` columns for mappings\n            x(Stat.x)\n            y(Stat.count)\n            fillColor = Color.RED\n            alpha = 0.5\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#histogram-layer","title":"Histogram layer","text":"<p>A histogram is a statistical chart that serves to visually approximate the distribution of a numerical variable. It's a bar plot where each bar is representing a bin: its x coordinate is corresponding to bin range and y to count. So basically, we can build a histogram with <code>statBin</code> as follows:</p> <pre><code>val statBinBarsPlot = df.plot {\n    statBin(\"depth\") {\n        bars {\n            x(Stat.x)\n            y(Stat.count)\n        }\n    }\n    layout.title = \"`statBin` + `bars`\"\n}\nstatBinBarsPlot\n</code></pre> <p></p> <p>But we can do it even faster with <code>histogram(statBinArgs)</code> method:</p> <pre><code>val histogramPlot = plot {\n    histogram(depthList)\n    layout.title = \"`histogram`\"\n}\nhistogramPlot\n</code></pre> <p></p> <p>Let's compare them:</p> <pre><code>plotGrid(listOf(statBinBarsPlot, histogramPlot))\n</code></pre> <p></p> <p>These two plots are identical. Indeed, <code>histogram</code> just uses <code>statBin</code> and <code>bars</code> and performs coordinates mappings under the hood. And we can customize histogram layer: <code>histogram()</code> optionally opens a new context, where we can configure bars (as in the usual context opened by <code>bars { ... }</code>) \u2014 even change coordinate mappings from default ones. <code>StatBin</code> dataset of histogram is also can be accessed here.</p> <pre><code>df.plot {\n    histogram(depth, binsAlign = BinsAlign.center(500.0)) {\n        // Change a column mapped on `y` to `Stat.density`\n        y(Stat.density)\n        // Filling color depends on `density` statistic\n        fillColor(Stat.density) {\n            scale = continuous(Color.YELLOW..Color.RED)\n        }\n        borderLine.color = Color.BLACK\n    }\n}\n</code></pre> <p></p> <p>If we specify weights, <code>Stat.countWeighted</code> is mapped to <code>y</code> by default:</p> <pre><code>df.plot {\n    // Count sample mean\n    val mean = depth.mean()\n    // Add weighted histogram\n    histogram(depth, coeff, binsOption = BinsOption.byNumber(10), binsAlign = BinsAlign.boundary(mean))\n    // We can add other layers as well.\n    // Let's add a vertical mark line in the mean of sample\n    vLine {\n        xIntercept.constant(mean)\n        tooltips { line(\"Depth mean: ${String.format(\"%.2f\", mean)}m\") }\n        color = Color.RED; width = 3.0\n    }\n    x.axis.name = \"depth, m\"\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#histogram-plot","title":"<code>histogram</code> plot","text":"<p><code>histogram(statBinArgs)</code> and <code>DataFrame.histogram(statBinArgs)</code> are a family of functions for fast plotting a histogram.</p> <pre><code>histogram(depthList, binsAlign = BinsAlign.center(500.0))\n</code></pre> <p></p> <pre><code>df.histogram(\"depth\")\n</code></pre> <p></p> <p>In case you want to provide inputs and weights using column selection DSL, it's a bit different from the usual one \u2014 you should assign <code>x</code> input and (optionally) <code>weight</code> throw invocation eponymous functions:</p> <pre><code>df.histogram(binsOption = BinsOption.byNumber(10)) {\n    x(depth)\n    weight(coeff)\n}\n</code></pre> <p></p> <p>Histogram plot can be configured with <code>.configure {}</code> extension \u2014 it opens a context that combines bars, <code>StatBin</code> and plot context. That means you can configure bars settings, mappings using <code>StatBin</code> dataset and any plot adjustments:</p> <pre><code>df.histogram(binsOption = BinsOption.byNumber(15)) {\n    x(depth)\n}.configure {\n    // Bars + StatBin + PlotContext\n    // Can't add a new layer\n    x.limits = 100..900\n    // Can add bar mapping, include on `Stat.*` columns\n    fillColor(Stat.count) { scale = continuous(Color.GREEN..Color.RED) }\n    // Can configure general plot adjustments\n    layout {\n        title = \"Configured histogram plot\"\n        size = 600 to 350\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#grouped-stabin","title":"Grouped <code>staBin</code>","text":"<p><code>statBin</code> can be applied for grouped data \u2014 statistics will be counted on each group independently but with equal bins. This application returns a new <code>GroupBy</code> dataset with the same keys as the old one but with <code>StatBin</code> groups instead of old ones.</p> <pre><code>// Create two samples from normal distribution with different mean/std\nval rangesA = NormalDistribution(500.0, 100.0).sample(5000).toList()\nval rangesB = NormalDistribution(400.0, 80.0).sample(5000).toList()\n\n// Gather them into `DataFrame` with \"A\" and \"B\" keys in the \"category\" column\nval rangesDF = dataFrameOf(\n    \"range\" to rangesA + rangesB,\n    \"category\" to List(5000) { \"A\" } + List(5000) { \"B\" }\n)\nrangesDF.head(5)\n</code></pre> range category 347.452 A 467.839 A 527.679 A 538.295 A 654.991 A <p>It has the following signature:</p> range category <pre><code>// Group it by \"category\"\nval groupedRangesDF = rangesDF.groupBy { category }\ngroupedRangesDF\n</code></pre> categorygroup A rangecategory 527.679A 654.991A 538.295A 467.839A 347.452A B rangecategory 377.8B 266.069B 306.389B 543.127B 482.897B <p>Now we have a <code>GroupBy</code> with a signature</p> key: [category] group: DataFrame[range|category] A A-Group B B-Group <pre><code>groupedRangesDF.statBin { x(range) }\n</code></pre> categorygroup A Stat { x: 116.91, count: 1, countWeighted: 1, ... } B Stat { x: 116.91, count: 5, countWeighted: 5, ... } <p>After <code>statBin</code> applying it's still a <code>GroupBy</code> but with different signature of <code>group</code> \u2014 all groups have the same signature as usual <code>DataFrame</code> after <code>statBin</code> applying (i.e. <code>StatBinFrame</code>):</p> key: [category] group: StaBinFrame A A-Group B B-Group <p>As you can see, we did indeed do a <code>statBin</code> transformation within groups, the grouping keys did not change. Also, all bin centers match \u2014 it helps to build grouped histogram.</p> <p>The plotting process doesn't change much \u2014 we do everything the same.</p> <pre><code>groupedRangesDF.plot {\n    statBin(range) {\n        area {\n            x(Stat.x)\n            y(Stat.density)\n        }\n    }\n}\n</code></pre> <p></p> <p>As you can see, there are two areas because we have two groups of data. To distinguish them, we need to add mapping to the filling color from the key. This is convenient \u2014 the key is available in the context</p> <pre><code>groupedRangesDF.plot {\n    statBin(range) {\n        area {\n            x(Stat.x)\n            y(Stat.density)\n            // can access \"key.\" columns and create mapping from them\n            fillColor(category)\n            alpha = 0.6\n        }\n    }\n}\n</code></pre> <p></p> <p>The <code>histogram</code> layer also works. Moreover, if we have exactly one grouping key, a mapping from it to <code>fillColor</code> will be created by default.</p> <pre><code>groupedRangesDF.plot {\n    histogram(range)\n}\n</code></pre> <p></p> <p>We can customize it like we used to. From the differences - access to <code>key</code> columns, and we can customize the <code>position</code> of bars (within a single x-coordinate), for example \u2014 stack them:</p> <pre><code>groupedRangesDF.plot {\n    histogram(range) {\n        fillColor(category) {\n            scale = categorical(listOf(Color.GREEN, Color.ORANGE))\n        }\n        borderLine.width = 0.0\n        width = 1.0\n        // Adjust position of bars from different groups\n        position = Position.stack()\n    }\n}\n</code></pre> <p></p> <p>Histogram plot for <code>GroupBy</code> (i.e. <code>GroupBy.histogram(statBinArgs)</code> extensions) works as well:</p> <pre><code>groupedRangesDF.histogram(\"range\")\n</code></pre> <p></p> <p>... and can be configured the same way:</p> <pre><code>groupedRangesDF.histogram(binsAlign = BinsAlign.center(500.0)) { x(range) }.configure {\n    alpha = 0.6\n    // make the bars from different groups overlap with each other\n    position = Position.identity()\n    // can access key column by name as `String`\n    fillColor(\"category\") { scale = categoricalColorBrewer(BrewerPalette.Qualitative.Dark2) }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Histogram-Guide/#inside-groupby-plot-context","title":"Inside <code>groupBy{}</code> plot context","text":"<p>We can apply <code>groupBy</code> modification to the initial dataset and build a histogram with grouped data the same way:</p> <pre><code>rangesDF.plot {\n    groupBy(category) {\n        histogram(range)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Jitter-Points-Guide/","title":"Jitter Points","text":"<p> Jitter Points in Kandy: A dynamic way to represent overlapping data points in Kotlin. This guide demonstrates how to use jittering to enhance clarity and aesthetics in data visualizations. </p> <p> Kandy Jitter Points: Discover how to effectively display dense, overlapping data points in Kotlin projects, bringing clarity to complex datasets. </p> <p> Unveil intricacies in dense datasets with Jitter Points in Kandy, a Kotlin-based solution for enhancing data visualization clarity and detail. </p> <pre><code>val mpgDf = DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDf.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact <p> <pre><code>mpgDf.plot {\n    points {\n        x(drv)\n        y(hwy)\n        color(drv)\n    }\n}\n</code></pre> <pre><code>mpgDf.plot {\n    points {\n        x(drv)\n        y(hwy)\n        color(drv)\n        position = Position.jitter()\n    }\n}\n</code></pre> <p></p> <p> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Kotlin-Notebook-Features-Guide/","title":"Kotlin Notebook Features","text":"<p> Unlock the full potential of data visualization in Kotlin notebooks with the Kandy Kotlin Notebook Features guide. This comprehensive guide offers insights into unique features tailored for interactive and dynamic chart creation in Kotlin notebooks. </p> <p> Kandy Kotlin Notebook Features guide: A gateway to enhanced data visualization in Kotlin notebooks. Discover unique interactive capabilities that elevate your charting experience. </p> <p> Dive into the Kandy Kotlin Notebook Features guide for an in-depth understanding of how to leverage Kotlin notebooks for sophisticated data visualization. </p> <p>This notebook demonstrates the features available when working with kandy-lets-plot in Kotlin Notebook</p>"},{"location":"kandy/docs/topics/guides/Kotlin-Notebook-Features-Guide/#swing-render","title":"Swing render","text":"<p>By default, Kotlin Notebook uses Swing to display plots:</p> <pre><code>val rand = Random(42)\n\nval simpleData = dataFrameOf(\n    \"time\" to (1..10).toList(),\n    \"value\" to List(10) { rand.nextDouble(0.0, 1.0) },\n    \"type\" to (List(5) { \"a\" } + List(5) { \"b\" }).shuffled(rand),\n    \"active\" to List(10) { rand.nextBoolean() },\n)\n</code></pre> <pre><code>val plot = simpleData.plot {\n    points {\n        x(time)\n        y(value)\n        color(type)\n        size = 6.0\n\n        tooltips(type, active)\n    }\n}\nplot\n</code></pre> <p>{width=\"700\" border-effect=\"rounded\"}</p> <p>Swing rendering has a lot of advantages: it is more performant (when using tooltips), you can change its size (in this case it will be scaled), and also has a dynamically changing color scheme (see the relevant section).</p> <p>However, you can disable it manually and use web rendering (may not work at all in Kotlin Notebook \u2014 try to restart kernel). To do this, before displaying the plot, it is necessary to change the corresponding option in <code>kandyConfig</code> (notebook parameter).</p> <pre><code>kandyConfig.swingEnabled = false\n</code></pre> <pre><code>plot\n</code></pre> <p>{width=\"700\" border-effect=\"rounded\"}</p>"},{"location":"kandy/docs/topics/guides/Kotlin-Notebook-Features-Guide/#dynamic-color-scheme","title":"Dynamic color scheme","text":"<p>If you are using a non-light color scheme in the editor, you may have noticed that the swing-rendered plot has automatically changed its theme to match the environment theme. If not already, you can check this by changing the theme of your editor to, for example, Darcula. Even without restarting the cell, the next plot (just like the first swing plot) will change the theme to match yours.</p> <pre><code>// Switching the swing rendering back on\nkandyConfig.swingEnabled = true\n</code></pre> <pre><code>plot\n</code></pre> <p>{width=\"700\" border-effect=\"rounded\"}</p> <p>To disable the automatic theme change, you need to change the corresponding flag in <code>kandyConfig</code>:</p> <pre><code>kandyConfig.applyColorScheme = false\n</code></pre> <pre><code>plot\n</code></pre> <p>{width=\"700\" border-effect=\"rounded\"}</p> <p>Also note that automatic theme change does not work if you set the theme manually (via <code>layout.flavor</code>):</p> <pre><code>kandyConfig.applyColorScheme = true\n</code></pre> <pre><code>simpleData.plot {\n    points {\n        x(time)\n        y(value)\n        color(type)\n        size = 6.0\n\n        tooltips(type, active)\n    }\n\n    layout.flavor = Flavor.HIGH_CONTRAST_DARK\n}\n</code></pre> <p>{width=\"700\" border-effect=\"rounded\"}</p>"},{"location":"kandy/docs/topics/guides/Kotlin-Notebook-Features-Guide/#plot-export-from-output","title":"Plot Export from Output","text":"<p>You can export plot from the cell output with the \"Export Plot As...\" button in the output menu or with \"Export Plot As...\" action.</p> <p>{width=\"200\" border-effect=\"rounded\"}</p> <p>After that, a settings menu will open where you can select the image format, the path to where you want to save it, as well as the file name itself.</p> <p>{width=\"400\" border-effect=\"rounded\"}</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Legend-and-Axis-Guide/","title":"Legend and Axis","text":"<p> Refine your plots with Kandy's Legend and Axis guide. Learn to manipulate legends and axes for improved readability and aesthetics in your data visualizations. </p> <p> Enhance plot legibility with Kandy's Legend and Axis guide. Gain insights on customizing legends and axes for clearer, more impactful data presentations. </p> <p> Dive into the nuances of plot customization with Kandy's Legend and Axis guide.  </p> <pre><code>val mpgDf =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDf.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18 1999 4 auto\\(l5\\) f 18 29 p compact 2 audi a4 18 1999 4 manual\\(m5\\) f 21 29 p compact 3 audi a4 2 2008 4 manual\\(m6\\) f 20 31 p compact 4 audi a4 2 2008 4 auto\\(av\\) f 21 30 p compact 5 audi a4 28 1999 6 auto\\(l5\\) f 16 26 p compact <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(manufacturer)\n        size = 5.0\n    }\n    layout.size = 600 to 250\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(manufacturer) {\n            legend.type = LegendType.DiscreteLegend(nCol = 2)\n        }\n        size = 5.0\n    }\n    layout {\n        title = \"Two columns legend\"\n        size = 600 to 250\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(manufacturer) {\n            legend.type = LegendType.DiscreteLegend(nCol = 2, byRow = true)\n        }\n        size = 5.0\n    }\n    layout {\n        title = \"Two columns legend filled by rows\"\n        size = 600 to 250\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(manufacturer) {\n            legend.type = LegendType.DiscreteLegend(nRow = 5)\n        }\n        size = 5.0\n    }\n    layout {\n        title = \"Five rows legend and below\"\n        size = 700 to 400\n        theme {\n            axis.title { blank = true }\n            legend.position = LegendPosition.Bottom\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    x(displ)\n    y(hwy)\n    points {\n        size = 5.0\n        color(cty)\n        symbol(drv)\n    }\n    layout.size = 700 to 350\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    x(displ)\n    y(hwy)\n    points {\n        size = 5.0\n        color(cty)\n        symbol(drv)\n    }\n    layout {\n        size = 700 to 350\n        theme {\n            legend {\n                justification(1.0, 1.0)\n                position(1.0, 1.0)\n                direction = LegendDirection.HORIZONTAL\n            }\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    x(displ)\n    y(hwy)\n    points {\n        size = 5.0\n        color(cty) {\n            scale = continuous(range = Color.named(\"dark_blue\")..Color.named(\"light_blue\"))\n            legend {\n                name = \"City MPG\"\n                type = LegendType.ColorBar(barHeight = 10.0, barWidth = 300.0)\n            }\n        }\n        symbol(drv) {\n            legend {\n                name = \"Drive-train\"\n                breaksLabeled(\"f\" to \"front\", \"r\" to \"rear\", \"4\" to \"4X4\")\n            }\n        }\n    }\n    layout {\n        size = 700 to 350\n        theme {\n            yAxis.line { blank = true }\n            legend {\n                justification(1.0, 1.0)\n                position(1.0, 1.0)\n                direction = LegendDirection.HORIZONTAL\n            }\n        }\n        xAxisLabel = \"Engine displacement (L)\"\n        yAxisLabel = \"Highway MPG\"\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Lines-Guide/","title":"Lines","text":"<p> Kandy Lines Guide: Learn to craft detailed line plots in Kotlin, perfect for visualizing trends and relationships in data. This comprehensive guide helps you navigate through various line styles and options. </p> <p> Line Plots in Kotlin with Kandy: A concise guide on creating sophisticated line visualizations, ideal for depicting data trends and correlations. </p> <p> Enhance your Kotlin projects with Kandy's line plot capabilities. This guide offers insights into creating impactful line charts, showcasing data trends with precision and style. </p> <pre><code>val mpgDf =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDf.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact"},{"location":"kandy/docs/topics/guides/Lines-Guide/#vertical-horizontal-and-oblique-lines","title":"Vertical, horizontal and oblique lines","text":"<pre><code>val ctyMedian = mpgDf.median { cty }\nval hwyMedian = mpgDf.median { hwy }\n</code></pre> <pre><code>val medianColor = Color.hex(\"#756bb1\")\nmpgDf.plot {\n    points {\n        x(cty)\n        y(hwy)\n    }\n    vLine {\n        xIntercept.constant(ctyMedian)\n        color = medianColor\n        type = LineType.DASHED\n    }\n    hLine {\n        yIntercept.constant(hwyMedian)\n        color = medianColor\n        type = LineType.DASHED\n    }\n    smoothLine(\"cty\", \"hwy\", method = SmoothMethod.Linear()) {\n        color = Color.hex(\"#de2d26\")\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Lines-Guide/#broken-lines","title":"Broken Lines","text":"<pre><code>fun generateParabolicDataMap(n: Int = 25, a: Double = 1.0): Map&lt;String, List&lt;Double&gt;&gt; {\n    val rand = java.util.Random(42)\n    val x = List(2 * n + 1) { i -&gt; a * (i - n).toDouble() / n }\n    val y = x.map { i -&gt; i * i + rand.nextGaussian() }\n    return mapOf(\"x\" to x, \"y\" to y)\n}\n\nval pDataMap = generateParabolicDataMap(a = 3.0)\nval xSrc = column&lt;Double&gt;(\"x\")\nval ySrc = column&lt;Double&gt;(\"y\")\n</code></pre> <pre><code>plot(pDataMap) {\n    line {\n        x(xSrc)\n        y(ySrc)\n    }\n}\n</code></pre> <pre><code>plot(pDataMap) {\n    path {\n        x(xSrc)\n        y(ySrc)\n    }\n}\n</code></pre> <pre><code>plot(pDataMap) {\n    step {\n        x(xSrc)\n        y(ySrc)\n    }\n}\n</code></pre> <p>And what is the difference between <code>line</code> and <code>path</code>?</p> <p>Let's have a look at the following example:</p> <pre><code>fun generateArchimedeanDataMap(n: Int = 25, k: Double = 1.0, a: Double = 1.0): Map&lt;String, List&lt;Double&gt;&gt; {\n    val phi = List(n) { i -&gt; 2.0 * PI * k * i.toDouble() / (n - 1) }\n    val r = phi.map { angle -&gt; (a * angle) / (2.0 * PI) }\n    val x = (r zip phi).map { p -&gt; p.first * cos(p.second) }\n    val y = (r zip phi).map { p -&gt; p.first * sin(p.second) }\n    return mapOf(\"x\" to x, \"y\" to y)\n}\n\nval aDataMap = generateArchimedeanDataMap(n = 200, k = 2.0)\n</code></pre> <pre><code>val linePlot = plot(aDataMap) {\n    line {\n        x(xSrc)\n        y(ySrc)\n    }\n    layout.title = \"Line Plot\"\n}\n\nval pathPlot = plot(aDataMap) {\n    path {\n        x(xSrc)\n        y(ySrc)\n    }\n    layout.title = \"Path Plot\"\n}\n\nval segments = plot(generateArchimedeanDataMap(n = 50)) {\n    segments {\n        xBegin(xSrc)\n        yBegin(ySrc)\n        xEnd.constant(0.0)\n        yEnd.constant(0.0)\n    }\n}\nplotBunch {\n    add(linePlot, 0, 0, 350, 300)\n    add(pathPlot, 350, 0, 350, 300)\n    add(segments, 0, 300, 700, 300)\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Pie-Guide/","title":"Pie","text":"<p> Discover the art of pie chart creation in Kotlin with the Kandy Pie Guide. This resource teaches you how to effectively represent categorical data proportions through engaging and informative pie charts. </p> <p> Kandy Pie Guide: Elevate your data storytelling in Kotlin with compelling pie charts. Learn how to visually communicate categorical data proportions with clarity and impact. </p> <p> Learn to effectively represent categorical data with visually engaging charts. </p> <pre><code>val blankTheme = theme {\n    global.line {\n        blank = true\n    }\n    blankAxes()\n}\n</code></pre> <pre><code>val dataset = dataFrameOf(\n    \"name\" to listOf('a', 'b', 'c', 'd', 'b'),\n    \"value\" to listOf(40, 90, 10, 50, 20)\n)\n</code></pre>"},{"location":"kandy/docs/topics/guides/Pie-Guide/#basic-pie-chart","title":"Basic Pie Chart","text":"<pre><code>dataset.plot {\n    pie {\n        slice(value)\n        fillColor(name)\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Pie-Guide/#improve-appearance","title":"Improve appearance","text":"<ul> <li>configure stroke</li> <li>make the pie bigger</li> <li>add hole to draw donut-like chart</li> <li>use blank theme</li> <li>use better colors</li> </ul> <pre><code>dataset.plot {\n    pie {\n        slice(value)\n        fillColor(name) {\n            scale = categoricalColorBrewer(BrewerPalette.Qualitative.Set1)\n        }\n        size = 20.0\n        stroke = 1.0\n        strokeColor = Color.WHITE\n        hole = 0.5\n    }\n    layout {\n        theme(blankTheme)\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Pie-Guide/#explode","title":"Explode","text":"<pre><code>val length = dataFrameOf(\n    \"name\" to listOf(\n        \"20-50 km\",\n        \"50-75 km\",\n        \"10-20 km\",\n        \"75-100 km\",\n        \"3-5 km\",\n        \"7-10 km\",\n        \"5-7 km\",\n        \"&gt;100 km\",\n        \"2-3 km\"\n    ),\n    \"count\" to listOf(1109, 696, 353, 192, 168, 86, 74, 65, 53),\n    \"explode\" to listOf(.0, .0, .0, .1, .1, .2, .3, .4, .6)\n)\n</code></pre> <pre><code>length.plot {\n    pie {\n        fillColor(name) {\n            scale = continuous(Color.named(\"dark_blue\"), Color.LIGHT_GREEN)\n        }\n        slice(count)\n        explode(explode)\n        stroke = 1.0\n        strokeColor = Color.BLACK\n        size = 20.0\n    }\n    layout.theme(blankTheme)\n}\n</code></pre> <pre><code>val calories = dataFrameOf(\n    \"slice\" to listOf(35, 25, 25, 15),\n    \"label\" to listOf(\"Apples\", \"Bananas\", \"Cherries\", \"Dates\"),\n    \"explode\" to listOf(.1, .0, .0, .0)\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        calories.plot {\n            pie {\n                slice(slice)\n                explode(explode)\n                fillColor(label) {\n                    scale = categoricalColorBrewer(BrewerPalette.Qualitative.Set1)\n                }\n                size = 15.0\n            }\n            layout {\n                theme(blankTheme)\n            }\n        },\n        calories.plot {\n            pie {\n                slice(slice)\n                explode(explode)\n                fillColor(label) {\n                    scale = categoricalColorBrewer(BrewerPalette.Qualitative.Set1)\n                }\n                size = 15.0\n                hole = 0.8\n            }\n            layout {\n                theme(blankTheme)\n            }\n        }\n    )\n)\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Plot-Bunch-Guide/","title":"Plot Bunch","text":"<p> Explore flexible data visualization with Kandy's Plot Bunch guide. Learn to arrange multiple plots in a single display, tailoring their size and position for impactful presentations. </p> <p> Kandy's Plot Bunch guide offers innovative ways to display multiple plots. Customize your data visualization with adjustable sizes and positions for maximum impact. </p> <p> Dive into the world of custom plot arrangements with Kandy's Plot Bunch guide. Perfect the art of displaying multiple plots in one view, with full control over their layout. </p> <p><code>plotBunch()</code> allows showing a collection of plots on one figure. Each plot in the collection can have an arbitrary location and size. There is no automatic layout inside the bunch.</p> <pre><code>val cov: Array&lt;DoubleArray&gt; = arrayOf(\n    doubleArrayOf(1.0, 0.0),\n    doubleArrayOf(0.0, 1.0)\n)\nval means: DoubleArray = doubleArrayOf(0.0, 0.0)\nval xy = MultivariateNormalDistribution(means, cov).sample(400)\n\nval xs = xy.map { it[0] }\nval ys = xy.map { it[1] }\n</code></pre>"},{"location":"kandy/docs/topics/guides/Plot-Bunch-Guide/#view-this-data-as-a-scatter-plot-and-as-a-histogram","title":"View this data as a scatter plot and as a histogram","text":"<pre><code>plot {\n    points {\n        x(xs)\n        y(ys)\n        color = Color.GREY\n        alpha = .4\n    }\n    layout {\n        size = 600 to 200\n        xAxisLabel = \"x\"\n        yAxisLabel = \"y\"\n    }\n}\n</code></pre> <pre><code>plot {\n    histogram(xs) {\n        fillColor = Color.named(\"dark_magenta\")\n    }\n    layout {\n        size = 600 to 200\n        xAxisLabel = \"x\"\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Plot-Bunch-Guide/#combine-both-plots-in-one-figure","title":"Combine both plots in one figure","text":"<pre><code>val scaleX = Scale.continuousPos(-3.5..3.5)\nplotBunch {\n    add(plot {\n        histogram(xs) {\n            x { scale = scaleX }\n            fillColor = Color.named(\"dark_magenta\")\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n        }\n    }, 0, 0)\n    add(plot {\n        points {\n            x(xs) { scale = scaleX }\n            y(ys)\n            color = Color.GREY\n            alpha = .4\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n            yAxisLabel = \"y\"\n        }\n    }, 0, 200)\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Plot-Bunch-Guide/#adjust-visuals-of-the-bunch-figure","title":"Adjust visuals of the bunch figure","text":"<pre><code>val upperTheme = theme {\n    blankAxes()\n    axis.text { }\n    yAxis.title { }\n    panel.grid.majorYLine {\n        blank = true\n    }\n}\nval lowerTheme = theme {\n    blankAxes()\n    yAxis.text { }\n    axis.title { }\n}\n</code></pre> <pre><code>plotBunch {\n    add(plot {\n        histogram(xs) {\n            x { scale = scaleX }\n            fillColor = Color.named(\"dark_magenta\")\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n            theme(upperTheme)\n        }\n    }, 0, 0)\n    add(plot {\n        points {\n            x(xs) { scale = scaleX }\n            y(ys)\n            color = Color.GREY\n            alpha = .4\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n            yAxisLabel = \"y\"\n            theme(lowerTheme)\n        }\n    }, 0, 200)\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Plot-Bunch-Guide/#adjust-plot-sizes","title":"Adjust plot sizes","text":"<p><code>add</code> method has two more (optional) parameters: <code>width</code> and <code>height</code>.</p> <p>These values will override the plot size earlier defined via size property.</p> <pre><code>plotBunch {\n    add(plot {\n        histogram(xs) {\n            x { scale = scaleX }\n            fillColor = Color.named(\"dark_magenta\")\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n            theme(upperTheme)\n        }\n    }, 0, 0, 600, 100)\n    add(plot {\n        points {\n            x(xs) { scale = scaleX }\n            y(ys)\n            color = Color.GREY\n            alpha = .4\n        }\n        layout {\n            size = 600 to 200\n            xAxisLabel = \"x\"\n            yAxisLabel = \"y\"\n            theme(lowerTheme)\n        }\n    }, 0, 100, 600, 300)\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/","title":"Quick Start Guide","text":"<p> Embark on your journey with Kandy, the Kotlin-based data visualization library. Our Quick Start Guide is tailored to help beginners and seasoned users alike, offering straightforward instructions for creating impactful visualizations. From data preparation to crafting detailed plots, this guide ensures a smooth start with Kandy. </p> <p> This guide covers all the essentials, from data handling to advanced plotting techniques, to kickstart your Kandy experience. </p> <p> Explore data visualization in Kotlin with the Kandy Quick Start Guide, a comprehensive resource for creating effective charts and plots. </p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#basics","title":"Basics","text":""},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#usage","title":"Usage","text":"<p> <p>To integrate Kandy and Dataframe into an interactive notebook, use the following commands:</p> <p> <p>Without specifying <code>%useLatestDescriptors</code>, the version included in the Kotlin Jupyter kernel will be used. {style=\"note\"}</p> <p></p> <pre><code>// Fetches the latest versions\n%useLatestDescriptors\n// Adds the dataframe library with the latest version\n%use dataframe\n// Adds the kandy library with the latest version\n%use kandy\n</code></pre> <p> <pre><code>// Adds the dataframe library with a specific version\n%use dataframe(%dataframe_latest_version%)\n// Adds the kandy library with a specific version\n%use kandy(%kandy_latest_version%)\n</code></pre> <p> </p> <p>Kotlin notebook offers unique features with the dataframe library.</p> <p> <p>To include Kandy in your Gradle project, add the following to your dependencies:</p> <pre><code>dependencies {\n    implementation(\"org.jetbrains.kotlinx:kandy-lets-plot:%kandy_latest_version%\")\n}\n</code></pre> <p> </p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#data","title":"Data","text":"<p>In Kandy, the primary data model for plotting is a \"named data\" or \"dataframe\". This model comprises a set of named columns with values of equal length. The input data should be structured as <code>Map&lt;String, List&lt;*&gt;&gt;</code>.</p> <p>Example of a simple dataset in Kandy:</p> <pre><code>val simpleDataset = mapOf(\n    \"time, ms\" to listOf(12, 87, 130, 149, 200, 221, 250),\n    \"relativeHumidity\" to listOf(0.45, 0.3, 0.21, 0.15, 0.22, 0.36, 0.8),\n    \"flowOn\" to listOf(true, true, false, false, true, false, false),\n)\n</code></pre> <p>To reference dataset columns in your plots, create pointers for each column. There are several ways to do this:</p> <pre><code>// 1. Using the `column()` function with the specified column type and name:\nval timeMs = column&lt;Int&gt;(\"time, ms\")\n// 2. Utilizing the String API, similar to the method above, but using String invocation:\nval humidity = \"relativeHumidity\"&lt;Double&gt;()\n// 3. Delegating an unnamed column - its name will be derived from the variable name:\nval flowOn by column&lt;Boolean&gt;()\n</code></pre>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#plot-creation","title":"Plot Creation","text":"<p>In Kandy, to create a plot, you start by calling the <code>plot()</code> function and passing your dataset as an argument. This function establishes a context within which you can add various layers to your plot.</p> <p>A layer is essentially a collection of mappings from your data to the visual attributes of the plot, known as aesthetic attributes. These attributes define how your data is represented visually, such as through points, lines, or bars.</p> <p>Here's an example demonstrating the creation of a plot with a single layer:</p> <pre><code>plot(simpleDataset) {\n    points {\n        // Maps values from the \"time, ms\" column to the X-axis\n        x(timeMs)\n        // Maps values from the \"relativeHumidity\" column to the Y-axis\n        y(humidity)\n        // Sets the size of the points to 4.5\n        size = 4.5\n        // Maps values from the \"flowOn\" column to the color attribute\n        color(flowOn)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#layers-aesthetics-mappings-and-scales","title":"Layers, aesthetics, mappings, and scales","text":"<p>Each plot layer is defined by its geometrical entity (or geom), which determines the layer's visual representation. Geoms have associated aesthetic attributes (or aesthetics/aes), which can be either positional (like <code>x</code>, <code>y</code>, <code>yMin</code>, <code>yMax</code>, <code>middle</code>) or non-positional (such as <code>color</code>, <code>size</code>, <code>width</code>). Non-positional aesthetics have specific types (e.g., <code>size</code> is associated with <code>Double</code>, <code>color</code> with <code>Color</code>).</p> <p>Aesthetic values can be assigned in two ways: setting and mapping.</p> <ul> <li>Setting involves assigning a constant value directly:</li> </ul> <pre><code>// Using `.constant()` for positional aes:\nx.constant(12.0f)\nyMin.constant(10.0)\n\n// Assignment for non-positional aes:\nsize = 5.0\ncolor = Color.RED\n</code></pre> <ul> <li>Mapping links data column values to aesthetic attributes.    This can be defined in various ways:</li> </ul> <pre><code>// With `ColumnReference`:\nx(timeMs)\nsize(humidity)\ncolor(flowOn)\n\n// Using raw `String`:\nx(\"time, ms\")\nsize(\"relativeHumidity\")\n\n// Directly providing values, e.g., with `Iterable`:\nx(listOf(12, 87, 130, 149, 200, 221, 250))\n// Optional source ID can be set:\ncolor(listOf(true, true, false, false, true, false, false), \"flow on\")\n</code></pre> <p>Scales determine how data values are translated into visual representations. They can be categorical (discrete) or continuous, based on their domain and range types. Continuous scales use limits for their domain and range, while categorical scales use lists of categories and corresponding values. Scales are typed and may include a transform parameter to define a transformation function (linear by default).</p> <p>Explicitly specifying scales after mapping:</p> <pre><code>plot(simpleDataset) {\n    points {\n        x(listOf(12, 87, 130, 149, 200, 221, 250)) {\n            scale = continuous(min = 0, max = 270) // Using `min`/`max`\n        }\n        y(humidity) {\n            scale = continuous(0.0..1.0) // Using `Range`\n        }\n        size(humidity) {\n            scale = continuous(range = 5.0..20.0)\n        }\n        color(flowOn) {\n            scale = categorical(true to Color.RED, false to Color.BLUE)\n        }\n        symbol(flowOn) {\n            scale = categorical()// default scale\n        }\n        alpha = 0.9\n    }\n}\n</code></pre> <p></p> <p>Scales can also be created separately and applied later:</p> <pre><code>val xReversedScale = Scale.continuousPos&lt;Int&gt;(transform = Transformation.REVERSE)\nval yScale = Scale.continuousPos(0.0..0.9)\nval colorScale = Scale.categorical&lt;Color, Boolean&gt;(\n    range = listOf(Color.RED, Color.GREEN)\n)\n</code></pre> <p>Applying pre-defined scales:</p> <pre><code>plot(simpleDataset) {\n    points {\n        x(listOf(12, 87, 130, 149, 200, 221, 250)) {\n            scale = xReversedScale\n        }\n        y(humidity) {\n            scale = yScale\n        }\n        color(flowOn) {\n            scale = colorScale\n        }\n        symbol = Symbol.ASTERIX\n        size = 6.6\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#scale-parameters-axis-and-legend","title":"Scale parameters: axis and legend","text":"<p>Guides play a crucial role in interpreting charts. They function as mini-charts for scales, with positional scales using axes as guides and non-positional ones utilizing legends. Each scale comes with a default guide, but you can tailor it to your needs.</p> <p>Here's how to customize the axis and legend in a plot:</p> <pre><code>// Creating a plot with customized axis and legend\nplot(simpleDataset) {\n    points {\n        // Configuring the x-axis for time\n        x(timeMs) {\n            axis.name = \"Time from start of counting,\\n milliseconds\"\n        }\n        // Configuring the y-axis for humidity\n        y(humidity) {\n            scale = continuous(0.0..1.0) // Setting scale for humidity\n            axis {\n                name = \"Relative humidity\" // Axis label\n                breaksLabeled(0.0 to \"0%\", 0.3 to \"30%\", 0.6 to \"60%\", 0.9 to \"90%\") // Custom axis breaks\n            }\n        }\n        size = 12.0 // Set size of points\n        // Configuring the legend for humidity\n        color(humidity) {\n            scale = continuous()\n            legend {\n                name = \"rel. humidity\" // Legend label\n                type = LegendType.ColorBar(40.0, 190.0, 15) // Legend type and dimensions\n                breaks(format = \"e\") // Legend breaks format\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#global-x-axis-and-y-axis-mappings-and-scales","title":"Global X-axis and Y-axis mappings and scales","text":"<p>In Kandy, you can use global mappings for <code>X</code> and <code>Y</code> across multiple layers, simplifying the process when these mappings are common. Each layer inherits the global mapping unless overridden locally.</p> <p>Example with global X and Y mappings:</p> <pre><code>// Using global mappings for X and Y\nplot(simpleDataset) {\n    x(timeMs) { scale = continuous(max = 275) }\n    y(humidity)\n    points {\n        // Inherits X and Y from the global context\n        size = 4.5\n        color(flowOn)\n    }\n    line {\n        // Inherits X, overrides Y\n        y(listOf(0.49, 0.39, 0.1, 0.4, 0.8, 0.8, 0.9))\n        width = 3.0\n        color = Color.RED\n    }\n}\n</code></pre> <p></p> <p>Configuring axis scales without explicit mapping:</p> <pre><code>// Configuring axis scales independently\nplot(simpleDataset) {\n    points {\n        x(listOf(10, 20, 30, 40, 50, 60, 70))\n        y(humidity)\n        size = 4.5\n        color(flowOn)\n    }\n    x.axis.name = \"time, ms\"\n    y {\n        scale = continuous(min = 0.0)\n        axis.breaks(format = \".2f\")\n    }\n}\n</code></pre> <p></p> <pre><code>plot(simpleDataset) {\n    points {\n        x(listOf(10, 20, 30, 40, 50, 60, 70))\n        y(humidity)\n        size = 4.5\n        color(flowOn)\n    }\n    // Alternate brief notation if we want to set the axis limits (continuous scale)\n    x.limits = 0..80\n    y.limits = 0.0..1.0\n}\n</code></pre> <p></p> <p>Free scale mechanism in Kandy:</p> <p>This feature, known as \"free scale\" allows the setting of scale parameters without direct data mapping. It's particularly useful for sub-positional &lt;aesthetics that don't have individual scales but depend on the parent positional aesthetics scale.</p> <p>Example of using free scale in a <code>boxplot</code>:</p> <pre><code>// Demonstrating free scale in a boxplot\nplot(\n    mapOf(\n        \"x\" to listOf(\"a\", \"b\", \"c\"),\n        // Boxplot sub-positional aesthetics\n        \"min\" to listOf(0.8, 0.4, 0.6),\n        \"lower\" to listOf(0.9, 1.4, 0.8),\n        \"middle\" to listOf(1.5, 2.4, 1.6),\n        \"upper\" to listOf(1.9, 3.4, 1.7),\n        \"max\" to listOf(3.1, 4.4, 2.6),\n        \"width\" to listOf(0.1, 1.4, 14.0)\n    )\n) {\n    boxes {\n        x(\"x\"&lt;String&gt;())\n        // Sub-y aesthetics with a free scale\n        yMin(\"min\"&lt;Double&gt;())\n        lower(\"lower\"&lt;Double&gt;())\n        middle(\"middle\"&lt;Double&gt;())\n        upper(\"upper\"&lt;Double&gt;())\n        yMax(\"max\"&lt;Double&gt;())\n        fatten = 4.5\n        alpha = 0.2\n        borderLine.color = Color.hex(0x9A2A2A)\n    }\n    y {\n        axis.name = \"weight\"\n        limits = 0.0..5.0\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#raw-source-mapping","title":"Raw source mapping","text":"<p>Kandy allows for direct data source mapping in plots, providing an alternative to using dataset column pointers. This method supports mapping from an <code>Iterable</code> source and offers the option to name these sources for clearer visualization.</p> <p>Example dataset:</p> <pre><code>// Sample data with months, number of days, and seasons\nval month = listOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval numberOfDays = listOf(31, 28, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30)\nval season = listOf(\n    \"winter\", \"winter\",\n    \"spring\", \"spring\", \"spring\",\n    \"summer\", \"summer\", \"summer\",\n    \"autumn\", \"autumn\", \"autumn\",\n    \"winter\"\n)\n</code></pre> <p>Using raw source mapping:</p> <pre><code>// Plotting using raw source mapping\nplot {\n    bars {\n        // Mapping 'month' directly with a name\n        x(month, \"month\") { scale = categorical() }\n        // Mapping 'numberOfDays' directly\n        y(numberOfDays, \"number of days\")\n        // Mapping 'season' with color, named source, and categorical scale\n        fillColor(season, \"season\") {\n            scale = categorical(\n                listOf(Color.BLUE, Color.GREEN, Color.RED, Color.ORANGE),\n                listOf(\"winter\", \"spring\", \"summer\", \"autumn\"),\n            )\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#kotlin-dataframe-api","title":"Kotlin DataFrame API","text":"<p>Kandy integrates seamlessly with the Kotlin DataFrame library, allowing the use of <code>DataFrame</code> as a data source and <code>DataColumn</code> for mappings. This integration simplifies the process of creating visualizations, as you can utilize auto-generated property columns without manually creating column pointers.</p> <pre><code>// Reading a CSV file into a DataFrame\nval mpgDF =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\n// Display the first five rows of the DataFrame\nmpgDF.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18,0 1999 4 auto(l5) f 18 29 p compact 2 audi a4 18,0 1999 4 manual(m5) f 21 29 p compact 3 audi a4 2,0 2008 4 manual(m6) f 20 31 p compact 4 audi a4 2,0 2008 4 auto(av) f 21 30 p compact 5 audi a4 28,0 1999 6 auto(l5) f 16 26 p compact <pre><code>// Show the schema of the DataFrame\nmpgDF.schema()\n</code></pre> <pre><code>untitled: Int\nmanufacturer: String\nmodel: String\ndispl: Double\nyear: Int\ncyl: Int\ntrans: String\ndrv: String\ncty: Int\nhwy: Int\nfl: String\nclass: String\n</code></pre> <p>Example of using DataFrame with Kandy:</p> <pre><code>// Create a plot using the DataFrame\nval mpgInfoPlot = mpgDF.plot {\n    points {\n        x(displ) // Auto-generated DataFrame columns\n        y(cty) {\n            scale = continuous(8..34)\n        }\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n        alpha = 0.7\n        fillColor(drv)\n        size(hwy) {\n            scale = continuous(5.0..15.0)\n            legend.breaks(listOf(15, 30, 40), format = \"d\")\n        }\n    }\n}\nmpgInfoPlot\n</code></pre> <p></p> <p>In scenarios where auto-generated property-columns are not available, you can manually create pointers to DataFrame columns:</p> <pre><code>// Creating a plot with manual column pointers\nval mpgCountPlot = mpgDF.groupBy { drv }.aggregate {\n    count() into \"count\"\n}.plot {\n    bars {\n        x(drv)\n        y(\"count\"&lt;Int&gt;())\n        alpha = 0.75\n    }\n}\nmpgCountPlot\n</code></pre> <p></p> <p>This integration with Kotlin DataFrame enriches Kandy's plotting capabilities, providing a more streamlined and efficient approach to data visualization in Kotlin projects.</p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#grouping","title":"Grouping","text":"<p>The grouping feature in Kandy is particularly useful for plotting collective geometries, where multiple data units are represented by a single geometric object, such as a <code>line</code>. Grouping can be performed either by providing a grouped dataframe (<code>GroupBy</code>) as a dataset or directly within the plot DSL.</p> <p>Here's how you can use grouping in Kandy:</p> <ol> <li>Grouping with a Map as Dataset:    You can define your dataset as a map and then use <code>groupBy</code> within the plotting DSL to create groups based on a    specific column.</li> </ol> <pre><code>// Dataset with a grouping column\nval lineDataset = mapOf(\n    \"timeG\" to listOf(1.0, 2.2, 3.4, 6.6, 2.1, 4.4, 6.0, 1.5, 4.7, 6.7),\n    \"value\" to listOf(112.0, 147.3, 111.1, 200.6, 90.8, 110.2, 130.4, 100.1, 90.0, 121.8),\n    \"c-type\" to listOf(\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"C\", \"C\", \"C\")\n)\n</code></pre> <pre><code>// Using grouping in the plot\nplot(lineDataset) {\n    groupBy(\"c-type\") {\n        line {\n            x(\"timeG\")\n            y(\"value\")\n        }\n    }\n}\n</code></pre> <p></p> <ol> <li>Grouping with DataFrame API:    If you are using the Kotlin DataFrame API, you can apply grouping on a dataframe.</li> </ol> <pre><code>// Convert the map to a DataFrame\nval lineDF = lineDataset.toDataFrame()\n</code></pre> <pre><code>// Apply grouping on the DataFrame\nlineDF.groupBy {\n    `c-type`\n}.plot {\n    line {\n        x(timeG)\n        y(value)\n    }\n}\n</code></pre> <p></p> <ol> <li>Advanced Grouping with Color Mapping: For more complex visualizations,    you can use grouping along with additional aesthetic mappings like color.</li> </ol> <pre><code>// Grouping with additional color mapping\nlineDF.plot {\n    groupBy(`c-type`) {\n        line {\n            x(timeG)\n            y(value)\n            color(`c-type`)\n            width = 4.0\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#implicit-grouping","title":"Implicit grouping","text":"<p>Kandy provides a convenient way to perform implicit grouping by utilizing categorical scales. This approach is especially useful when you want to differentiate data points based on a specific category without explicitly defining groups.</p> <p>Plotting with Implicit Grouping: By specifying a categorical scale for an aesthetic attribute like color, Kandy automatically groups the data based on the categories presented in the data column.</p> <pre><code>// Plotting with implicit grouping\nlineDF.plot {\n    line {\n        x(timeG)\n        y(value)\n        // Implicit grouping based on `c-type`\n        color(`c-type`)\n        width = 4.0\n    }\n}\n</code></pre> <p></p> <p>In this example, the <code>color</code> aesthetic is mapped to the <code>c-type</code> column, which is a categorical variable. Kandy implicitly groups the data based on the unique values in the <code>c-type</code> column and assigns different colors to each group. This results in a visually distinct representation for each category, making it easier to differentiate between them in the plot.</p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#position","title":"Position","text":"<p>The <code>position</code> parameter plays a crucial role in adjusting the spatial arrangement of objects within a single layer, especially when dealing with grouped data. It controls how objects from different groups are positioned relative to each other.</p> <p>Here's a breakdown of how position can be applied:</p> <pre><code>val meanCylDf = mpgDF.groupBy { cyl and drv }.mean { cty }\n// Display the first five rows of the grouped DataFrame\nmeanCylDf.head(5)\n</code></pre> cyldrvcty 4f22,068966 6f17,186047 4418,347826 6414,781250 8412,104167 <ol> <li>Dodge Position: Separates bars side by side, making it easy to compare groups.</li> </ol> <pre><code>val meanCylPlot = meanCylDf.groupBy { cyl }.plot {\n    bars {\n        x(drv)\n        y(cty)\n        fillColor(cyl) { legend.breaks(format = \"d\") }\n\n        position = Position.dodge()\n    }\n}\nmeanCylPlot\n</code></pre> <p></p> <ol> <li>Identity Position: Overlays bars directly on top of each other, useful for highlighting overlaps.</li> </ol> <pre><code>meanCylDf.groupBy { cyl }.plot {\n    bars {\n        x(drv)\n        y(cty)\n        fillColor(cyl) { legend.breaks(format = \"d\") }\n        alpha = 0.4\n\n        position = Position.identity()\n    }\n}\n</code></pre> <p></p> <ol> <li>Stack Position: Stacks bars on top of each other, ideal for cumulative comparisons.</li> </ol> <pre><code>meanCylDf.groupBy { cyl }.plot {\n    bars {\n        x(drv)\n        y(cty)\n        fillColor(cyl) { legend.breaks(format = \"d\") }\n\n        position = Position.stack()\n    }\n}\n</code></pre> <p></p> <p>The <code>position</code> parameter is applicable only within a single layer. It doesn't affect the positioning of objects across different layers. {style=\"note\"}</p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#experimental","title":"Experimental","text":"<p>This section of Kandy explores experimental APIs which are subject to change in future versions. They offer innovative features for advanced data visualization, inviting exploration and feedback for further development.</p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#multiplot","title":"Multiplot","text":"<p>There are three ways to create a multiplot: <code>plotGrid</code>, <code>plotBunch</code> and faceting.</p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#plot-grid","title":"Plot Grid","text":"<p>The <code>plotGrid</code> function allows for arranging multiple plots in a structured grid format, offering a cohesive view of different data visualizations. Example:</p> <pre><code>plotGrid(listOf(mpgInfoPlot, mpgCountPlot, meanCylPlot), nCol = 2)\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#plot-bunch","title":"Plot Bunch","text":"<p><code>plotBunch</code> provides a more flexible approach to multiplot creation, enabling custom placement and sizing for each plot. This is ideal for tailored data presentations. Example:</p> <pre><code>plotBunch {\n    add(mpgCountPlot, 0, 0, 400, 200)\n    add(meanCylPlot, 400, 0, 300, 200)\n    add(mpgInfoPlot, 0, 200, 700, 300)\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#faceting","title":"Faceting","text":"<p>Faceting in Kandy is a powerful feature that splits a single plot into multiple plots based on dataset categories. This method is akin to groupBy in data manipulation, providing detailed insights into subcategories. Faceting methods include:</p> <ul> <li><code>facetGridX</code> and <code>facetGridY</code> for single-parameter faceting along the X or Y axes, respectively:</li> </ul> <pre><code>mpgDF.plot {\n    points {\n        x(displ)\n        y(cty) {\n            scale = continuous(8..34)\n        }\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n        alpha = 0.7\n        fillColor(drv)\n        size(hwy) {\n            scale = continuous(2.0..10.0)\n        }\n    }\n\n    layout.size = 750 to 450\n\n    facetGridX(drv, scalesSharing = ScalesSharing.FREE_X)\n}\n</code></pre> <p></p> <pre><code>mpgDF.plot {\n    points {\n        x(displ)\n        y(cty) {\n            scale = continuous(8..34)\n        }\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n        alpha = 0.7\n        fillColor(drv)\n        size(hwy) {\n            scale = continuous(2.0..10.0)\n        }\n    }\n\n    layout.size = 750 to 450\n\n    facetGridY(cyl, format = \"d\")\n}\n</code></pre> <p></p> <ul> <li><code>facetGrid</code> for two-parameter faceting along both X and Y axes:</li> </ul> <pre><code>mpgDF.plot {\n    points {\n        x(displ)\n        y(cty) {\n            scale = continuous(8..34)\n        }\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n        fillColor(drv)\n        size(hwy) {\n            scale = continuous(2.0..10.0)\n        }\n    }\n\n    layout.size = 750 to 450\n\n    facetGrid(drv, cyl, yFormat = \"d\")\n}\n</code></pre> <p></p> <ul> <li><code>facetWrap</code> for multi-parameter faceting with additional layout control:</li> </ul> <pre><code>mpgDF.plot {\n    points {\n        x(displ)\n        y(cty) {\n            scale = continuous(8..34)\n        }\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n        fillColor(drv)\n        size(hwy) {\n            scale = continuous(2.0..10.0)\n        }\n    }\n\n    layout.size = 750 to 450\n\n    facetWrap(nCol = 3, scalesSharing = ScalesSharing.FREE) {\n        facet(drv)\n        facet(cyl, order = OrderDirection.DESCENDING, format = \"d\")\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#statistics","title":"Statistics","text":"<p>Kandy offers a robust API for computing statistics directly within its DSL. This functionality is achieved through the <code>stat</code> family of functions, which transform raw data into a new dataset with calculated statistics. These statistics become accessible as columns and can be mapped to various plot aesthetics, scaled, or incorporated into tooltips.</p> <p>Here's an example using a dataset of random observations:</p> <pre><code>val random = kotlin.random.Random(42)\n\nval observation = List(1000) { random.nextDouble() }\nval observationDataset = dataFrameOf(\n    \"observations\" to observation\n)\n</code></pre> <p>You can create statistical visualizations such as a bin plot with bars and lines:</p> <pre><code>plot(observationDataset) {\n    statBin(obs) {\n        bars {\n            // Simple mapping\n            x(Stat.x)\n            // Mapping with the scale\n            y(Stat.count) {\n                scale = continuous(0..100, transform = Transformation.REVERSE)\n            }\n\n            alpha = 0.5\n\n            // Formatting of stat value format\n            tooltips {\n                // Line with the name of stat (i.e. \"count\") on the left side and its value on the right side\n                line(Stat.count, format = \"d\")\n            }\n        }\n\n        line {\n            x(Stat.x)\n            y(Stat.count)\n\n            width = 2.5\n            color = Color.RED\n        }\n    }\n}\n</code></pre> <p></p> <p>Kandy also simplifies the creation of standard statistical charts, like histograms, by combining statistical calculations and layer creation into a single function:</p> <pre><code>val histPlot = plot(observationDataset) {\n    histogram(obs)\n\n    layout.title = \"`histogram`\"\n}\nhistPlot\n</code></pre> <p></p> <p>You can compare it to a bar chart with the calculation of bins stat:</p> <pre><code>val binBarPlot = plot(observationDataset) {\n    statBin(obs) {\n        bars {\n            x(Stat.x)\n            y(Stat.count)\n        }\n    }\n    layout.title = \"`statBin` + `bar`\"\n}\n\nplotGrid(listOf(histPlot, binBarPlot), 2)\n</code></pre> <p></p> <p>The <code>histogram</code> in Kandy is flexible, allowing for custom aesthetic bindings and the use of \"stat-bin\" statistics for mapping:</p> <pre><code>plot(observationDataset) {\n    histogram(obs, binsOption = BinsOption.byWidth(0.05), binsAlign = BinsAlign.boundary(0.1)) {\n        y(Stat.density)\n\n        fillColor(Stat.count) {\n            scale = continuous(Color.GREEN..Color.RED)\n        }\n\n        borderLine {\n            color = Color.BLACK\n            width = 0.3\n        }\n\n        tooltips(title = \"${value(Stat.x)} \u00b1 0.025\") {\n            line(Stat.density)\n        }\n    }\n}\n</code></pre> <p></p> <p>This statistical API is also compatible with <code>Iterable</code> data types, expanding its applicability across various data structures:</p> <pre><code>plotGrid(listOf(\n    plot {\n        statBin(observation) {\n            points {\n                x(Stat.density)\n                y(Stat.x)\n            }\n        }\n    },\n    plot {\n        histogram(observation)\n    }\n), 2)\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#layout","title":"Layout","text":""},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#title-subtitle-caption-and-size","title":"Title, subtitle, caption, and size","text":"<p>You can personalize your plot's layout by configuring the title, subtitle, caption, and overall size. The <code>layout</code> block provides direct access to these properties, making it easy to create visually compelling charts.</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n    }\n\n    // Can access of layout parameters in this context\n    layout {\n        subtitle = \"plot subtitle\"\n        caption = \"plot caption \\n important info\"\n        size = 800 to 600\n    }\n    // If you just want to put a title\n    layout.title = \"PLOT TITLE\"\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#themes","title":"Themes","text":"<p>Themes in Kandy offer extensive customization options for your plot's appearance, including styles for lines, text, backgrounds, and more. You can use a pre-built theme or create your own custom theme.</p> <p>To apply a <code>theme</code>:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n    }\n    layout.theme(Theme.Classic)\n}\n</code></pre> <p></p> <p>For example, creating a plot with different themes:</p> <pre><code>fun plotWithTheme(theme: Theme? = null, title: String? = null): org.jetbrains.kotlinx.kandy.ir.Plot {\n    return mpgDF.plot {\n        points {\n            x(cty)\n            y(hwy)\n        }\n        layout {\n            theme?.let {\n                theme(it)\n            }\n            this.title = title\n        }\n    }\n}\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        plotWithTheme(Theme.Classic, \"\\\"Classic\\\" theme\"),\n        plotWithTheme(Theme.Grey, \"\\\"Grey\\\" theme\"),\n        plotWithTheme(Theme.Light, \"\\\"Light\\\" theme\"),\n        plotWithTheme(Theme.Minimal, \"\\\"Minimal\\\" theme\"),\n        plotWithTheme(Theme.Minimal2, \"\\\"Minimal2\\\" theme (by default)\"),\n        plotWithTheme(Theme.None, \"\\\"None\\\" theme\"),\n    ), 2\n)\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#custom-themes","title":"Custom Themes","text":"<p>Kandy's DSL allows you to craft custom themes. You can set parameters for lines, text, backgrounds, etc.,either separately or in-place.</p> <p>Creating a simple custom theme:</p> <pre><code>val redLine = LayoutParameters.line(Color.RED)\n\nval simpleCustomTheme = theme {\n    // use previously created parameters\n    xAxis.line(redLine)\n    // set up parameters\n    yAxis.line {\n        color = Color.RED\n        width = 0.3\n    }\n    // remove ticks on both axes\n    axis.ticks {\n        blank = true\n    }\n}\n\nplotWithTheme(simpleCustomTheme)\n</code></pre> <p></p> <p>Example of a theme with blank axes:</p> <pre><code>val blankAxesTheme = theme {\n    blankAxes()\n}\nplotWithTheme(blankAxesTheme)\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#custom-scales","title":"Custom scales","text":"<p>Kandy extends the versatility of scales beyond standard options, providing custom color scales like <code>hue</code>, <code>grey</code>, <code>brewer</code>, <code>gradient2</code>, and <code>gradientN</code>.</p> <p>Creating plots with different color scales:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        size = 5.0\n        color(drv) {\n            scale = categoricalColorHue()\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        size = 5.0\n        color(cty) {\n            scale = continuousColorGrey()\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        size = 5.0\n        color(hwy) {\n            scale = continuousColorGradient2(Color.BLUE, Color.ORANGE, Color.RED, 30.0)\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        size = 5.0\n        color(cty) {\n            scale = continuousColorGradientN(\n                gradientColors = listOf(\n                    Color.RED, Color.hex(\"#fa89c7\"),\n                    Color.rgb(200, 89, 12), Color.LIGHT_GREEN\n                )\n            )\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        size = 5.0\n        color(drv) {\n            scale = categoricalColorBrewer(BrewerPalette.Qualitative.Set1)\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#tooltips","title":"Tooltips","text":"<p>Tooltips in Kandy allow for an interactive exploration of data by displaying additional information about visual objects. These tooltips are established within each layer's context using the <code>tooltips()</code> method.</p> <p>While tooltips are enabled by default, Kandy allows for their customization or complete deactivation. This flexibility is achieved by adjusting the <code>hide</code> flag within the tooltips' settings:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        color(drv)\n        size = 3.5\n\n        tooltips(hide = true)\n    }\n}\n</code></pre> <p></p> <p>Kandy offers extensive customization for tooltips, enabling users to not only display data from specific columns but also format these data points for better clarity and interpretation:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        color(drv)\n        size = 3.5\n\n        tooltips(drv, cyl, displ, formats = mapOf(displ to \".1g\"))\n    }\n}\n</code></pre> <p></p> <p>Kandy allows for further customization of tooltips, including title adjustment, minimum width settings, and fixed positioning:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        color(drv)\n        size = 3.5\n\n        tooltips(\n            cyl, displ,\n            title = \"Car info\",\n            anchor = Anchor.TOP_RIGHT,\n            minWidth = 80.0,\n        )\n    }\n}\n</code></pre> <p></p> <p>For more detailed tooltip configurations, Kandy offers a special DSL. This DSL enables manual adjustments of tooltip lines, allowing users to add specific data values and customize the layout:</p> <pre><code>mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        color(drv)\n        size = 3.5\n\n        tooltips(\n            // use column values in the title\n            title = \"${value(manufacturer)} ${value(model)}\",\n        ) {\n            // standard line with column name and value\n            line(displ)\n            // solid line\n            line(trans.tooltipValue())\n            // two-sided line\n            line(\"cty/hwy [mpg]\", \"${cty.tooltipValue()}/${hwy.tooltipValue()}\")\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Quick-Start-Guide/#export","title":"Export","text":"<p>Kandy's plotting library provides an efficient way to export your plots as images in various formats, including .jpg/.jpeg, .png, .html, and .svg. This feature is facilitated by the <code>save()</code> extension method.</p> <p>First, create a plot that you wish to export. Here's an example plot with some basic configurations:</p> <pre><code>val plotForExport = mpgDF.plot {\n    points {\n        x(cty)\n        y(hwy)\n        color(drv)\n        size = 3.5\n    }\n    layout {\n        title = \"Plot for export\"\n        size = 600 to 400\n    }\n}\nplotForExport\n</code></pre> <p></p> <p>Once your plot is ready, you can export it as an image file. The <code>save()</code> method allows you to specify the file format, scale, and dpi, and the path where the image will be saved:</p> <pre><code>val pathPNG = plotForExport.save(\"plot.png\", scale = 2.5, dpi = 9000, path = \"./saved_plots\")\n</code></pre> <p>To view the exported image, you can use the following code snippet:</p> <pre><code>javax.imageio.ImageIO.read(java.io.File(pathPNG))\n</code></pre> <p></p> <p>In addition to saving as a file, you can also export the plot as a <code>BufferedImage</code>. This is particularly useful for further manipulation or display within a Kotlin application:</p> <pre><code>plotForExport.toBufferedImage(scale = 2.5, dpi = 9000)\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Ribbon-Guide/","title":"Ribbon","text":"<p> Unveil the power of data visualization in Kotlin with the Kandy Ribbon Guide. Dive into creating sophisticated ribbon plots that skillfully represent uncertainty and variability in your data. </p> <p> Discover the Ribbon Guide in Kandy for Kotlin: A comprehensive tutorial on crafting detailed ribbon plots, perfect for showcasing data variability and confidence intervals. </p> <p> Explore the art of ribbon plotting in Kotlin with the Kandy Ribbon Guide. Learn to represent uncertainty and trends in data with visually intuitive ribbon charts. </p> <pre><code>fun generateDataMap(n: Int = 15, a: Double = 1.0): Map&lt;String, List&lt;Any&gt;&gt; {\n    val rand = java.util.Random(42)\n    val x = List(2 * n + 1) { i -&gt; a * (i - n).toDouble() / n }\n    val tMin = x.map { a * a - it.pow(2) - abs(rand.nextGaussian()) }\n    val tMax = x.map { a * a - it.pow(2) + abs(rand.nextGaussian()) }\n    return mapOf(\"day\" to (1..x.size).toList(), \"minTemp\" to tMin, \"maxTemp\" to tMax)\n}\n\nval dataMap = generateDataMap(a = 2.0)\n</code></pre> <pre><code>plot(dataMap) {\n    ribbon {\n        x(\"day\"&lt;Int&gt;()) { axis.name = \"time\" }\n        yMin(\"minTemp\"&lt;Double&gt;())\n        yMax(\"maxTemp\"&lt;Double&gt;())\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Scatter-Guide/","title":"Scatter","text":"<p> Primary the intricacies of scatter plotting in Kotlin with the Kandy Scatter Guide. This comprehensive resource helps you create detailed and insightful scatter plots, revealing hidden patterns and correlations in your data. </p> <p> Enhance your data storytelling with the Kandy Scatter Guide for Kotlin. Dive into creating expressive scatter plots that illuminate relationships and trends in complex datasets. </p> <p> Unlock the potential of scatter plots in Kotlin using the Kandy Scatter Guide. </p> <pre><code>// This example was found at:\n// www.cookbook-r.com/Graphs/Scatterplots_(ggplot2)\nval rand = java.util.Random(123)\nval n = 20\nval dataset = dataFrameOf(\n    \"cond\" to List(n / 2) { \"A\" } + List(n / 2) { \"B\" },\n    \"xvar\" to List(n) { i: Int -&gt; i },\n    \"yvar\" to List(n) { i: Int -&gt; i + rand.nextGaussian() * 3 }\n)\nval cond = \"cond\"&lt;String&gt;()\nval xvar = \"xvar\"&lt;Int&gt;()\nval yvar = \"yvar\"&lt;Double&gt;()\n</code></pre>"},{"location":"kandy/docs/topics/guides/Scatter-Guide/#basic-scatter-plot","title":"Basic Scatter Plot","text":"<pre><code>plot(dataset) {\n    points {\n        x(xvar)\n        y(yvar)\n        symbol = Symbol.CIRCLE_OPEN\n    }\n}\n</code></pre> <pre><code>plot(dataset) {\n    points {\n        x(xvar)\n        y(yvar)\n        color(cond)\n        symbol(cond)\n        size = 5.0\n    }\n    layout {\n        size = 700 to 350\n    }\n}\n</code></pre> <pre><code>plot(dataset) {\n    points {\n        x(xvar)\n        y(yvar)\n        color(cond)\n        symbol(cond) {\n            scale = categorical(range = listOf(Symbol.CIRCLE_OPEN, Symbol.TRIANGLE_OPEN))\n        }\n        size = 5.0\n    }\n    layout {\n        size = 700 to 350\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Scatter-Guide/#handling-over-plotting","title":"Handling Over-plotting","text":"<pre><code>// Create data with overlapping points.\nval datasetOverlapping = dataset.convert { xvar and yvar }.with {\n    (it.toDouble() / 5).toInt() * 5\n}\n</code></pre> <pre><code>plot(datasetOverlapping) {\n    points {\n        x(xvar) {\n            axis.breaks(listOf(0, 5, 10, 15))\n        }\n        y(yvar)\n        alpha = .3\n        size = 7.0\n    }\n    layout {\n        size = 700 to 350\n    }\n}\n</code></pre> <pre><code>plot(datasetOverlapping) {\n    points {\n        x(xvar) {\n            axis.breaks(listOf(0, 5, 10, 15))\n        }\n        y(yvar)\n        symbol = Symbol.CIRCLE_OPEN\n\n        position = Position.jitter(.1, .1)\n    }\n    layout {\n        size = 700 to 350\n    }\n}\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Series-Hack-Guide/","title":"Series Hack","text":"<p> Explore advanced charting techniques with the 'Series Hack' guide from Kandy. This guide delves into creative ways to manipulate data series for more effective and innovative visualizations. </p> <p> Boost your visualization tactics with the advanced guide on 'Series Hack' from Kandy. Discover how to alter series for creating distinctive and insightful chart displays. </p> <p> Embrace the 'Series Hack' guide from Kandy for professional advice on morphing data series into engaging visual stories. </p> <p>Sometimes you have several sources of data, and you want to visualize them by displaying color mapping from a group (i.e., color of plot objects corresponds to their group).</p> <p>Let's assume we have three samples with different y-values and the same x-values</p> <pre><code>val xs = listOf(1, 2, 3, 4, 5)\nval ysA = listOf(1.0, 2.5, 3.0, 3.5, 5.0)\nval ysB = listOf(0.5, 1.5, 3.0, 1.5, 0.0)\nval ysC = listOf(3.0, 5.0, 2.0, 3.0, 5.0)\n</code></pre> <p>So you can try something like that:</p> <pre><code>plot {\n    x(xs)\n    line {\n        y(ysA)\n        color = Color.RED\n    }\n    line {\n        y(ysB)\n        color = Color.GREEN\n    }\n    line {\n        y(ysC)\n        color = Color.BLUE\n    }\n}\n</code></pre> <p></p> <p>But unfortunately, \"lets-plot\" doesn't support it \u2014 legend is not displayed (because of Lets-Plot limitations). So you need to gather them into one layer. You need to change your data - add grouping variable (so now each point has exactly three parameters: x and y coordinates and its group).</p> <pre><code>plot {\n    line {\n        x(xs + xs + xs)\n        y(ysA + ysB + ysC)\n        color(xs.map { \"A\" } + xs.map { \"B\" } + xs.map { \"C\" })\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Series-Hack-Guide/#dataframe-solution","title":"DataFrame solution","text":"<p>In case a similar situation occurred with a dataframe, it is even easier to solve it with the <code>gather</code> function</p> <pre><code>val df = dataFrameOf(\n    \"xs\" to xs,\n    \"ysA\" to ysA,\n    \"ysB\" to ysB,\n    \"ysC\" to ysC,\n)\ndf\n</code></pre> xs ysA ysB ysC 1 1 0.5 3 2 2.5 1.5 5 3 3 3 2 4 3.5 1.5 3 5 5 0 5 <p>For example, we cant to build several bars:</p> <pre><code>// Doesn't work - bars are overlapped, and we can't change that\ndf.plot {\n    x(xs)\n    bars {\n        y(ysA)\n        fillColor = Color.RED\n    }\n    bars {\n        y(ysB)\n        fillColor = Color.GREEN\n    }\n    bars {\n        y(ysC)\n        fillColor = Color.BLUE\n    }\n}\n</code></pre> <p></p> <pre><code>val gatheredDF = df.gather {\n    ysA and ysB and ysC\n}\n    .mapKeys { it.drop(2) } // Take group name as a key\n    .into(keyColumn = \"group\", valueColumn = \"ys\")\ngatheredDF.head()\n</code></pre> xs group ys 1 A 1 1 B 0.5 1 C 3 2 A 2.5 2 B 1.5 <pre><code>gatheredDF.plot {\n    bars {\n        x(xs)\n        y(ys)\n        fillColor(group)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/","title":"Smoothing","text":"<p> Become proficient in data smoothing with Kandy's 'Smoothing' guide. Explore methods to improve data visualization by lessening the noise and emphasizing trends </p> <p> Kandy's 'Smoothing' guide demystifies the process of smoothing data. Learn how to refine your visualizations for clearer insights. </p> <p> Explore Kandy's 'Smoothing' guide for advanced data visualization techniques. Understand how smoothing can elevate your plots by emphasizing underlying patterns. </p> <p>Statistics \"smooth\" are calculated on the sample of two continuous variables (i.e., sample of points or lines). It interpolates data points to create a smoother curve.</p> <p>This notebook uses definitions from DataFrame.</p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#usage","title":"Usage","text":"<p>The \"Smooth\" statistic proves beneficial in scenarios with over-plotting or noise, simplifying the process of identifying inherent trends and patterns. It can also be used to make a more pretty line with a small number of points.</p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#arguments","title":"Arguments","text":"<ul> <li>Input (mandatory):<ul> <li><code>x</code> \u2014 numeric sample of input points <code>x</code> coordinates</li> <li><code>y</code> \u2014 numeric sample of input points <code>y</code> coordinates</li> </ul> </li> <li>Parameters (optional):<ul> <li><code>method: SmoothMethod</code> \u2014 smoothing model:<ul> <li><code>SmoothMethod.Linear(confidenceLevel: Double)</code> \u2014 linear model</li> <li><code>SmoothMethod.Polynomial(degree: Int, confidenceLevel: Double)</code> \u2014 polynomial model</li> <li><code>SmoothMethod.LOESS(span: Double, loessCriticalSize: Int, samplingSeed: Long, confidenceLevel: Double)</code> \u2014   Local Polynomial Regression model</li> </ul> </li> <li><code>smootherPointCount: Int</code> \u2014 number of sampled points</li> </ul> </li> </ul>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#generalized-signature","title":"Generalized signature","text":"<p>The specific signature depends on the function, but all functions related to \"smooth\" statistic (which will be discussed further below \u2014 different variations of <code>statSmooth()</code>, <code>smoothLine()</code>) have approximately the same signature with the arguments above:</p> <pre><code>statSmoothArgs := \n   x, \n   y,\n   method: SmoothMethod = SmoothMethod.LOESS(),\n   smootherPointCount: Int = 100\n</code></pre> <p>The possible types of <code>x</code> and <code>y</code> depend on where a certain function is used. They can be simply <code>Iterable</code> (<code>List</code>, <code>Set</code>, etc.) or a reference to a column in a <code>DataFrame</code> (<code>String</code>, <code>ColumnAccessor</code>) or the <code>DataColumn</code> itself.</p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#output-statistics","title":"Output statistics","text":"name type description Stat.x Double <code>x</code> coordinate Stat.y Double <code>y</code> coordinate Stat.yMin Double Lower point-wise confidence interval around the mean Stat.yMax Double Upper point-wise confidence interval around the mean Stat.se Double Standard error"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#statsmooth-plots","title":"StatSmooth plots","text":"<pre><code>// To generate the data, we use a standard java math library\n// https://commons.apache.org/proper/commons-math/\n\n// Generate line with formula\nval xs = (-100..100).map { it / 50.0 }\nval lineFormula = { x: Double -&gt; 2.0 / (x * x + 0.5) }\n// Generate noises from normal distribution\nval noises = NormalDistribution(0.0, 0.1).sample(xs.size).toList()\nval ys = xs.zip(noises).map { lineFormula(it.first) + it.second }\n// And drop 2/3 points\nval random = Random(42)\nval (newXs, newYs) = xs.zip(ys).shuffled(random).take(xs.size * 1 / 3).sortedBy { it.first }.unzip()\n</code></pre> <pre><code>// Gather them into the DataFrame\nval df = dataFrameOf(\n    \"speed\" to newXs,\n    \"efficiency\" to newYs\n)\ndf.head(5)\n</code></pre> speed efficiency -2.00 0.500380 -1.92 0.459302 -1.84 0.636746 -1.78 0.623408 -1.68 0.839757 <p><code>df</code> has a signature</p> speed efficiency <p>Let's take a look at <code>StatSmooth</code> output DataFrame:</p> <pre><code>df.statSmooth(\"speed\", \"efficiency\").head(5)\n</code></pre> Stat xyyMinyMaxse -20.197-0.0060.4010.102 -1.960.2470.0470.4470.1 -1.9190.2970.10.4930.099 -1.8790.3470.1530.540.097 -1.8380.3970.2060.5880.096 <p>It has the following signature:</p> Stat x y yMin yMax se <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statSmooth</code>, each row corresponds to one of the line points. <code>Stat.x</code> is the column with this point <code>x</code> coordinate. <code>Stat.y</code> is points <code>y</code> coordinate; <code>Stat.yMin</code> \u2014 lower point of confidence level. <code>Stat.yMax</code> \u2014 upper point of confidence level. <code>Stat.se</code> \u2014 standard error.</p> <p><code>DataFrame</code> with \"smooth\" statistics is called <code>StatSmoothFrame</code></p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#statsmooth-transform","title":"<code>statSmooth</code> transform","text":"<p><code>statSmooth(statSmoothArgs) { /*new plotting context*/ }</code> modifies a plotting context \u2014 instead of original data (no matter was it empty or not) new <code>StatSmooth</code> dataset (calculated on given arguments. Inputs can be provided as <code>Iterable</code> or as dataset column reference \u2014 by name as a <code>String</code>, as a <code>ColumnReference</code> or as a <code>DataColumn</code>) is used inside a new context (original dataset and primary context are not affected \u2014 you can add layers using initial dataset outside the <code>statSmooth</code> context). Since the old dataset is irrelevant, we cannot use references for its columns. But we can refer to the new ones. They are all contained in the <code>Stat</code> group and can be called inside the new context:</p> <pre><code>plot {\n    statSmooth(newXs, newYs) {\n        // new `StatSmooth` dataset here\n        area {\n            // use `Stat.*` columns for mappings\n            x(Stat.x)\n            y(Stat.y)\n        }\n    }\n    points {\n        x(newXs)\n        y(newYs)\n    }\n}\n</code></pre> <p></p> <pre><code>df.plot {\n    statSmooth(speed, efficiency, method = SmoothMethod.Polynomial(2), smootherPointCount = 250) {\n        ribbon {\n            x(Stat.x)\n            yMin(Stat.yMin)\n            yMax(Stat.yMax)\n        }\n    }\n    // Dataset is not changed here\n    points {\n        x(speed)\n        y(efficiency)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#smoothline-layer","title":"<code>smoothLine</code> layer","text":"<p><code>smoothLine</code> layer is a shortcut for fast plotting a smoothed line:</p> <pre><code>val smoothLineLayerPlot = plot {\n    smoothLine(newXs, newYs)\n    layout.title = \"`smoothLine()` layer\"\n}\nsmoothLineLayerPlot\n</code></pre> <p></p> <pre><code>// Compare it with `statSmooth` + usual `line`\nval statSmoothAndLinePlot = plot {\n    statSmooth(newXs, newYs) {\n        line {\n            x(Stat.x)\n            y(Stat.y)\n        }\n    }\n    layout.title = \"`statSmooth()` + non-statistical `line` layer\"\n}\nplotGrid(listOf(smoothLineLayerPlot, statSmoothAndLinePlot))\n</code></pre> <p></p> <p><code>smoothLine</code> uses <code>statSmooth</code> and <code>line</code> and performs coordinate mappings under the hood. And we can customize <code>smoothLine</code> layer: <code>smoothLine()</code> optionally opens a new context, where we can configure the line (as in the usual context opened by <code>line { ... }</code>) \u2014 even change coordinate mappings from default ones. <code>StatSmooth</code> dataset of <code>smoothLine</code> is also can be accessed here.</p> <pre><code>df.plot {\n    smoothLine(speed, efficiency, SmoothMethod.LOESS(span = 0.1), 120) {\n        // change a column mapped on `y` to `Stat.scaled`\n        y(Stat.yMax)\n        color = Color.RED\n        width = 4.0\n    }\n    points {\n        x(speed)\n        y(efficiency)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#grouped-statsmooth","title":"Grouped <code>statSmooth</code>","text":"<p><code>statSmooth</code> can be applied for grouped data \u2014 statistics will be calculated on each group independently but with equal categories. This application returns a new <code>GroupBy</code> dataset with the same keys as the old one but with <code>StatSmooth</code> groups instead of old ones.</p> <pre><code>// Generate two lines\nval fA = { x: Double -&gt; 0.02 * x * x * x - 0.2 * x * x + 0.1 * x + 2.1 }\nval fB = { x: Double -&gt; -0.1 * x * x * x + 0.5 * x * x - 0.8 }\nval xRange = (-500..500).map { it / 100.0 }\nval noisesA = NormalDistribution(0.0, 0.05).sample(xRange.size).toList()\nval noisesB = NormalDistribution(0.0, 0.2).sample(xRange.size).toList()\nval valuesA = xRange.zip(noisesA).map { fA(it.first) + it.second }\nval valuesB = xRange.zip(noisesB).map { fB(it.first) + it.second }\n\nval (xsA, ysA) = xRange.zip(valuesA).shuffled(Random(17)).take(xRange.size * 1 / 3).sortedBy { it.first }\n    .unzip()\nval (xsB, ysB) = xRange.zip(valuesB).shuffled(Random(17)).take(xRange.size * 1 / 3).sortedBy { it.first }\n    .unzip()\n</code></pre> <pre><code>// Gather them into `DataFrame` with \"A\" and \"B\" keys in \"category\" column\nval valuesDF = dataFrameOf(\n    \"time\" to xsA + xsB,\n    \"value\" to ysA + ysB,\n    \"category\" to List(xsA.size) { \"A\" } + List(xsB.size) { \"B\" }\n)\nvaluesDF.head(5)\n</code></pre> time value category -4.96 -5.735 A -4.89 -5.57 A -4.87 -5.384 A -4.84 -5.261 A -4.83 -5.333 A <p>It has the following signature:</p> time value category <pre><code>// Group it by \"category\"\nval groupedDF = valuesDF.groupBy { category }\ngroupedDF\n</code></pre> categorygroup A timevaluecategory -4.96-5.69A -4.89-5.449A -4.87-5.509A -4.84-5.377A -4.83-5.265A B timevaluecategory -4.9623.806B -4.8922.735B -4.8722.503B -4.8422.293B -4.8322.072B <p>Now we have a <code>GroupBy</code> with a signature</p> key: [category] group: DataFrame[time|value|category] A A-Group B B-Group <pre><code>groupedDF.statSmooth { x(time); y(value) }\n</code></pre> categorygroup A Stat { x: -5.0, y: -4.2, y: -4.2, ... } B Stat { x: -5.0, y: 17.4, y: 17.1, ... } <p>After <code>statSmooth</code> applying it's still a <code>GroupBy</code> but with different signature of <code>group</code> \u2014 all groups have the same signature as usual <code>DataFrame</code> after <code>statSmooth</code> applying (i.e. <code>StatSmoothFrame</code>):</p> key: [drv] group: StaSmoothFrame \"A\" \"A\"-Group \"B\" \"B\"-Group <p>As you can see, we did indeed do a <code>statSmooth</code> transformation within groups, the grouping keys did not change.</p> <p>The plotting process doesn't change much \u2014 we do everything the same.</p> <pre><code>groupedDF.plot {\n    statSmooth(time, value) {\n        line {\n            x(Stat.x)\n            y(Stat.y)\n        }\n    }\n}\n</code></pre> <p></p> <p>As you can see, there are two lines because we have two groups of data. To distinguish them, we need to add mapping to the color from the key. This is convenient \u2014 the key is available in the context</p> <pre><code>groupedDF.plot {\n    statSmooth(time, value, method = SmoothMethod.Polynomial(3)) {\n        line {\n            x(Stat.x)\n            y(Stat.y)\n            color(category)\n        }\n    }\n}\n</code></pre> <p></p> <p>The <code>smoothLine()</code> layer also works. Moreover, if we have exactly one grouping key, a mapping from it to <code>color</code> will be created by default.</p> <pre><code>groupedDF.plot {\n    smoothLine(time, value)\n}\n</code></pre> <p></p> <p>We can customize it like we used to. From the differences \u2014 access to <code>key</code> columns:</p> <pre><code>groupedDF.plot {\n    smoothLine(time, value) {\n        color = Color.GREEN\n        type(category)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Smoothing-Guide/#inside-groupby-plot-context","title":"Inside <code>groupBy{}</code> plot context","text":"<p>We can apply <code>groupBy</code> modification to the initial dataset and build a histogram with grouped data the same way:</p> <pre><code>valuesDF.plot {\n    groupBy(category) {\n        smoothLine(time, value)\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/","title":"Statistics Guide","text":"<p> Delve into the versatile world of data visualization with Kandy's 'Statistics' guide. Learn to perform statistical pre-transformations within your plots, enhancing data analysis and visual clarity. </p> <p> Statistical transformations in Kandy. This guide demonstrates how to use built-in functions for insightful and visually striking data representations. </p> <p> Explore the 'Statistics' guide in Kandy for in-depth data analysis. </p> <p><code>kandy-statistics</code> allows you to build statistical plots, i.e., plots with statistical transformations of data. With them, you can explore your data in a better way as well as visualize important statistical observations.</p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#how-do-statistics-work","title":"How do statistics work?","text":"<p>The process of statistical transformations is straightforward and intuitive. You have some dataset \u2014 it can be a single <code>List</code> or a whole <code>DataFrame</code>. Statistics consume one or more sets of values (<code>List</code>, <code>DataColumn</code>) from this dataset and import a new dataset with the transformed data. Then this dataset is used for visualization. Kandy has an API for explicit work with this dataset as well as more simplified for quick plotting.</p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#statbin-anatomy-example","title":"<code>statBin</code> anatomy example","text":"<p>Let's look at an example. The <code>bin</code> statistic is one of the most used \u2014 it allows you to split observations by bins and count the number of observations in each one. It is used to construct one of the most common statistical plots \u2014 histogram. But before we build a histogram, let's examine the statistics.</p> <pre><code>// Generate sample from normal distribution\nval sample = NormalDistribution().sample(1000).toList()\n// Generate weights from uniform distribution\nval weights = UniformRealDistribution(0.0, 1.0).sample(1000).toList()\n</code></pre> <p>Each statistic has several types of arguments:</p> <ol> <li>Main inputs \u2014 one or more sets of values (usually named <code>x</code>, <code>y</code>, <code>z</code>) on which the statistic is counted \u2014    these are the only mandatory arguments.    All inputs must be of the same size.</li> <li>weight \u2014 some statistics are weighted,    i.e., the weight of each element will be taken into account. To pass it, the optional argument <code>weights</code> is used.    This set must have the same size as the main inputs.</li> <li>Statistics parameters.    Each statistic has its unique parameters, on which its calculation depends directly.    All of them have a default value.</li> </ol> <p>Let's look at the checklist of these arguments for <code>statBin</code>:</p> <ol> <li><code>statBin</code> consumes exactly one values set \u2014 sample of values to bin (<code>x</code>).</li> <li>It's weighted. In addition, to <code>count</code> (i.e., the number of observations within bin) <code>statBin</code> counts <code>countWeighted</code>    statistic, i.e., the weighted count refers to the total sum of the observation weights within a specific bin. To    calculate this, pass <code>weights</code> set of the same size as the sample.</li> <li><code>statBin</code> has two parameters, both of which configure bins<ul> <li><code>binOptions</code> - allows you to specify either the number of bins or their width.</li> <li><code>binAlign</code> - sets the alignment of the bin.</li> </ul> </li> </ol> <p>Let's use it on our sample...</p> <pre><code>val statBinData = statBin(\n    sample, // Pass a sample as an input\n    null, // Don't provide weights\n    BinsOption.byNumber(20), // Set the number of bins\n    BinsAlign.center(0.0) // Set the align of bins\n)\n</code></pre> <p>...and take a look at the output dataset:</p> <pre><code>statBinData\n</code></pre> Stat xcountcountWeighteddensitydensityWeighted -3.14060522.00.0063680.006368 -2.82654400.00.0000000.000000 -2.51248422.00.0063680.006368 -2.1984231414.00.0445770.044577 -1.8843632121.00.0668660.066866 <p>As you can see, we got a <code>DataFrame</code> with one <code>ColumnGroup</code> called <code>Stat</code> which contains several columns with statics. For <code>statBin</code>, each row corresponds to one bin. <code>Stat.x</code> is the column with the centers of the bins; <code>Stat.count</code> contains the number of observations in the bin. <code>Stat.countWeighted</code> - weighted version of <code>count</code> (but since we do not pass weights, this column differs from the previous one only in type - <code>Double</code> instead of <code>Int</code>; values are the same). There are also <code>Stat.density</code> and <code>Stat.densityWeighted</code>. They contain empirically estimated density (both normal and weighted) of the sample in the points corresponding to the centers of bins.</p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#awesome-but-what-about-plotting","title":"Awesome! But what about plotting?","text":"<p>As mentioned earlier, <code>statBin</code> is used to plot a histogram. And now, having our new dataset, it is really easy to build it \u2014 for a classic histogram we need bars with coordinates (x: bin center (i.e. <code>Stat.x</code>), y = bin count (i.e. <code>Stat.count</code>)):</p> <pre><code>statBinData.plot {\n    bars {\n        x(Stat.x)\n        y(Stat.count)\n    }\n    layout.title = \"Our awesome histogram!\"\n}\n</code></pre> <p></p> <p>Of course, we won't need to explicitly calculate a new dataset every time. Moreover, we will not need to define the histogram manually again each time. There are different types of APIs for this purpose, which are described in the next chapter.</p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#statistics-apis","title":"Statistics APIs","text":""},{"location":"kandy/docs/topics/guides/Statistics-Guide/#stat-transform-api","title":"Stat-transform API","text":"<p>\"Stat-transform\" API allows you to transform a dataset right inside <code>PlotContext</code>, calculating stats on the fly. It is essentially a set of extensions for <code>PlotContext</code> that have the usual statistics API (input samples, weights and parameters) but also open a new context. As usual, new layers can be created in this context, but within it, they will have a new dataset \u2014 a dataset with a statistical transformation.</p> <pre><code>val df = dataFrameOf(\"sample\" to sample, \"weights\" to weights)\n</code></pre> <pre><code>df.plot {\n    statBin(sample, weights, binsOption = BinsOption.byWidth(0.25)) {\n        // New `StatBin` dataset inside this context\n        line {\n            // The old dataset is not actual, so we can use `Stat.` columns of a new one\n            x(Stat.x)\n            y(Stat.density)\n        }\n    }\n    // Dataset hasn't changed here, so we can use it in the usual way\n    vLine {\n        xIntercept.constant(sample.mean())\n        width = 3.0\n        color = Color.RED\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#stat-layers-api","title":"Stat-layers API","text":"<p>\"Stat-layers\" API is a set of shortcuts for the most popular statistical graphs (such as a histogram); it's an integration of \"stat-transform\" API and regular layers \u2014 with just one function we can plot a statistical layer (i.e., it's an amalgamation of three whole things \u2014 stat counting, layer creation and default mappings)</p> <pre><code>plot {\n    // Equal to `statBin` + `bars` + x/y mappings on Stat.x/Stat.count\n    histogram(sample)\n}\n</code></pre> <p></p> <p>Everything is the same, however, three times less code! But that doesn't mean we lose flexibility. First of all, <code>.histogram()</code> has all the same arguments as <code>.statBin()</code>, which means we can fully control the counting of statistics. Second, it optionally creates a new context \u2014 a union of <code>bars</code> and <code>statBin</code> contexts. This will allow you to customize <code>bars</code> (including overriding default mappings!).</p> <pre><code>plot {\n    histogram(sample, weights, binsAlign = BinsAlign.center(0.0)) {\n        // This context combines `bars` and `statBin` context; that means we can\n        // make `bars` mappings and use `Stat.` columns.\n        // By default, `Stat.count` is mapped on `y` if weights are not provided;\n        // however, we can easily override mapping to `y`, for example, from `Stat.density`\n        y(Stat.density)\n        fillColor(Stat.density) {\n            scale = continuous(Color.GREEN..Color.RED)\n        }\n    }\n    x.limits = -3.5..3.5\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#stat-plots-api","title":"Stat-plots API","text":"<p>\"Stats-plots\" API allows you to build a histogram even faster \u2014 only with one function! Usually it is a function or set of extensions for a <code>DataFrame</code> with standard statistic arguments (inputs, weights, parameters).</p> <pre><code>histogram(sample)\n</code></pre> <p></p> <p>or</p> <pre><code>df.histogram(\"sample\", binsOption = BinsOption.byNumber(10))\n</code></pre> <p></p> <p>Column selection DSL for stat plots is slightly different from the standard one. You can still open a new scope in which you can access the columns of the dataframe. However, unlike the classic one, you must not return the columns as the result of the expression, but rather access the inputs of the statistics through the function of the same name. Weights are provided in the same way.</p> <pre><code>df.histogram {\n    x(sample)\n    weight(weights)\n}\n</code></pre> <p></p> <p>And stat plots can be configured. We can configure layer mappings and settings exactly as in stat layer, and also change the general settings of the plot. The <code>.configure()</code> extension is used for this purpose \u2014 it opens a context that combines several contexts you are familiar with \u2014 stat context, layer context and plot context:</p> <pre><code>df.histogram(BinsOption.byNumber(14), BinsAlign.boundary(0.0)) {\n    x(sample)\n}.configure {\n    // StatBin + Bars + Plot contexts\n    x.limits = -3.5..3.5\n    y(Stat.density)\n    borderLine.color = Color.BLACK\n    layout.title = \"Configured histogram\"\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Statistics-Guide/#statistics-and-grouped-data","title":"Statistics and grouped data","text":"<p>Everything described above works with grouped data as well. Statistics are calculated independently inside each group (however, sometimes not exactly; for example, to plot a histogram, we want the centers of bins in different groups to be equals for better plotting). Thus, a statistical transformation for <code>GroupBy</code> will return a <code>GroupBy</code> with the same keys, but instead of the original datasets we will have a <code>Stat</code> dataframes.</p> <p>Let's make sure of that:</p> <pre><code>// Generate two samples from a normal distribution with different mean/std\nval sampleA = NormalDistribution(1.5, 1.0).sample(1000).toList()\nval sampleB = NormalDistribution(4.0, 2.0).sample(1000).toList()\n\n// Gather them into `DataFrame` with \"A\" and \"B\" keys in the \"category\" column\nval dfAB = dataFrameOf(\n    \"sample\" to sampleA + sampleB,\n    \"type\" to List(1000) { \"A\" } + List(1000) { \"B\" }\n)\n</code></pre> <pre><code>val gbAB = dfAB.groupBy { type }\ngbAB\n</code></pre> typegroup A sampletype 0.481969A 0.849284A 5.044135A -0.037175A 1.547424A B sampletype 2.394755B 3.440403B 7.718361B 4.209521B 2.030533B <pre><code>gbAB.statBin(\"sample\")\n</code></pre> typegroup A Stat { x: -2.8, count: 0, countWeigh..., ... } { x: -2.1, count: 0, countWeigh..., ... } { x: -1.4, count: 4, countWeigh..., ... } { x: -0.7, count: 22, countWeigh..., ... } { x: 0.0, count: 99, countWeigh..., ... } B Stat { x: -2.8, count: 2, countWeigh..., ... } { x: -2.1, count: 2, countWeigh..., ... } { x: -2.4, count: 2, countWeigh..., ... } { x: -0.7, count: 8, countWeigh..., ... } { x: 0.0, count: 20, countWeigh..., ... } <p>As you can see, we did indeed do a <code>statBin</code> transformation within groups, the grouping keys did not change.</p> <p>The plotting process isn't much different either. As usual, different sets of points are plotted for different groups. Within the new \"stat\" context, we also can access columns corresponding to the grouping keys. Also, we can configure position inside the layer.</p> <pre><code>gbAB.plot {\n    statBin(sample) {\n        bars {\n            x(Stat.x)\n            y(Stat.count)\n            fillColor(type)\n            borderLine.width = 0.0\n            position = Position.dodge()\n        }\n        line {\n            x(Stat.x)\n            y(Stat.count)\n            color(type)\n        }\n    }\n}\n</code></pre> <p></p> <p>For <code>histogram</code> layer, this also works. Moreover, if we have exactly one grouping key, it will be mapped to <code>fillColor</code> by default:</p> <pre><code>gbAB.plot {\n    histogram(sample)\n}\n</code></pre> <p></p> <p>And we can customize it:</p> <pre><code>gbAB.plot {\n    histogram(sample, binsOption = BinsOption.byNumber(12)) {\n        fillColor(type)\n        borderLine.color = Color.BLACK\n        position = Position.stack()\n    }\n}\n</code></pre> <p></p> <p>And <code>GroupBy</code> has a <code>.histogram()</code> extension that works exactly like one for <code>DataFrame</code> and can be configured the same way:</p> <pre><code>gbAB.histogram(\"sample\")\n</code></pre> <p></p> <pre><code>gbAB.histogram(BinsOption.byNumber(20), binsAlign = BinsAlign.boundary(0.0)) {\n    x(sample)\n}.configure {\n    fillColor(type) {\n        scale = categorical(listOf(Color.GREEN, Color.ORANGE))\n    }\n    layout {\n        size = 650 to 350\n        title = \"Configured grouped histogram!\"\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Themes-Guide/","title":"Themes","text":"<p> Unleash the power of visual styling with Kandy's Themes guide. Explore a variety of themes to add a professional and aesthetically pleasing touch to your data visualizations. </p> <p> Transform your data plots with Kandy's Themes guide. Learn how to apply different themes to enhance the visual appeal and clarity of your charts. </p> <p> Step into the world of thematic data visualization with Kandy's Themes guide. Discover how to select and apply themes for more engaging and informative charts. </p>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#preparation","title":"Preparation","text":"<pre><code>val df =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\ndf.head(3)\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18 1999 4 auto\\(l5\\) f 18 29 p compact 2 audi a4 18 1999 4 manual\\(m5\\) f 21 29 p compact 3 audi a4 2 2008 4 manual\\(m6\\) f 20 31 p compact <pre><code>fun pointPlotWithTheme(name: String, inTheme: Theme = Theme.Minimal2, cusTheme: CustomTheme.() -&gt; Unit = {}) =\n    df.plot {\n        points {\n            x(cty)\n            y(hwy)\n        }\n        layout {\n            title = name\n            theme(inTheme, cusTheme)\n        }\n    }\n\ndf.plot {\n    points {\n        x(cty)\n        y(hwy)\n    }\n}\n</code></pre> <pre><code>val bPlotDf = df.groupBy { fl }.count()\n</code></pre> <pre><code>fun barPlotWithTheme(name: String, inTheme: Theme = Theme.Minimal2, cusTheme: CustomTheme.() -&gt; Unit = {}) =\n    bPlotDf.plot {\n        bars {\n            x(fl)\n            y(count)\n            fillColor(fl)\n        }\n        layout {\n            title = name\n            theme(inTheme, cusTheme)\n        }\n    }\n\nbPlotDf.plot {\n    bars {\n        x(fl)\n        y(count)\n        fillColor(fl)\n    }\n}\n</code></pre> <pre><code>val fPlotDf = df.groupBy { fl and year }.count()\n</code></pre> <pre><code>fun barFacetPlotWithTheme(\n    name: String, inTheme: Theme = Theme.Minimal2, cusTheme: CustomTheme.() -&gt; Unit = {}\n) =\n    fPlotDf.plot {\n        bars {\n            x(fl)\n            y(count)\n            fillColor(fl)\n        }\n        facetGridX(year)\n        layout {\n            title = name\n            theme(inTheme, cusTheme)\n        }\n    }\n\nfPlotDf.plot {\n    bars {\n        x(fl)\n        y(count)\n        fillColor(fl)\n    }\n    facetGridX(year)\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#elements","title":"Elements","text":"<pre><code>val eLine = LayoutParameters.line(color = Color.RED, width = 4.0)\nval eLine2 = LayoutParameters.line(color = Color.hex(\"#fcae91\"), width = 1.0)\nval eLine3 = LayoutParameters.line(width = 4.0)\nval eBackground = LayoutParameters.background(\n    borderLineColor = Color.hex(\"#2c7fb8\"),\n    fillColor = Color.hex(\"#edf8b1\"),\n    borderLineWidth = 2.0\n)\nval eText = LayoutParameters.text(color = Color.hex(\"#31a354\"))\nval (w, h) = listOf(400) to listOf(300)\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#themes_1","title":"Themes","text":"<pre><code>plotGrid(\n    listOf(\n        pointPlotWithTheme(\"Minimal2 Theme - by default\"),\n        pointPlotWithTheme(\"Light Theme\", Theme.Light),\n        pointPlotWithTheme(\"Classic Theme\", Theme.Classic),\n        pointPlotWithTheme(\"Grey Theme\", Theme.Grey),\n        pointPlotWithTheme(\"Minimal Theme\", Theme.Minimal),\n        pointPlotWithTheme(\"None Theme\", Theme.None)\n    ),\n    nCol = 2,\n    fit = true\n)\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#custom-theme","title":"Custom Theme","text":"<pre><code>val yellowLight = Color.hex(\"#ffffcc\")\nval orangeDark = Color.hex(\"#7f2704\")\nval orangeNormal = Color.hex(\"#f16913\")\nval orangeLight = Color.hex(\"#fff5eb\")\n\nval themeOrangeConstructor: CustomTheme.() -&gt; Unit = {\n    global {\n        line {\n            color = orangeNormal\n            width = 2.0\n        }\n        background {\n            borderLineColor = orangeNormal\n            fillColor = orangeLight\n            borderLineWidth = 2.0\n        }\n        text {\n            color = orangeDark\n        }\n    }\n    axis {\n        ticks {\n            color = orangeNormal\n            width = 1.0\n        }\n        ticksLength = 7.0\n        onTop = true\n    }\n    legend {\n        background {\n            borderLineWidth = 1.0\n        }\n        position = LegendPosition.Bottom\n    }\n    panel.grid {\n        majorLine {\n            color = orangeNormal\n            width = .5\n        }\n        minorLine {\n            blank = true\n        }\n    }\n    plotCanvas.background {\n        fillColor = yellowLight\n        borderLineWidth = 1.0\n    }\n    axis.tooltip.background {\n        borderLineColor = orangeDark\n    }\n}\n\nplotGrid(\n    listOf(\n        pointPlotWithTheme(\"Scatter plot\", Theme.None, themeOrangeConstructor),\n        barPlotWithTheme(\"Bar plot\", Theme.None, themeOrangeConstructor)\n    ),\n    nCol = 2,\n    fit = true\n)\n</code></pre> <pre><code>barPlotWithTheme(\"Place legend\") {\n    legend {\n        position(1.0, 1.0)\n        justification(1.0, 1.0)\n        direction = LegendDirection.HORIZONTAL\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#axis-tooltip","title":"Axis Tooltip","text":"<pre><code>plotGrid(\n    listOf(\n        pointPlotWithTheme(\"blank tooltip x-axis\") {\n            xAxis.tooltip.background {\n                blank = true\n            }\n        },\n        pointPlotWithTheme(\"background tooltip x-axis\") {\n            xAxis.tooltip.background(eBackground)\n        }\n    ),\n    nCol = 2\n)\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#line-background-text","title":"Line, Background, Text","text":"<pre><code>plotGrid(\n    listOf(\n        pointPlotWithTheme(\"Default\"),\n        pointPlotWithTheme(\"Configured grid line\") {\n            global.line(eLine)\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barPlotWithTheme(\"None Theme\", Theme.None),\n        barPlotWithTheme(\"None theme + Rect\", Theme.None) {\n            global.background(eBackground)\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barFacetPlotWithTheme(\"Default\"),\n        barFacetPlotWithTheme(\"Text\") { global.text(eText) },\n        barFacetPlotWithTheme(\"Legend text\") { legend.text(eText) },\n        barFacetPlotWithTheme(\"Strip text\") { strip.text(eText) }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barPlotWithTheme(\"Default\"),\n        barPlotWithTheme(\"Text\") { global.text(eText) },\n        barPlotWithTheme(\"Plot title\") { plotCanvas.title(eText) },\n        barPlotWithTheme(\"Legend title\") { legend.title(eText) }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        pointPlotWithTheme(\"Default\"),\n        pointPlotWithTheme(\"Blank axis\") {\n            axis.line {\n                blank = true\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        pointPlotWithTheme(\"Default\"),\n        pointPlotWithTheme(\"Panel background\") {\n            panel.background(eBackground)\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barPlotWithTheme(\"Blank panel grid\") {\n            panel.grid.lineGlobal {\n                blank = true\n            }\n        },\n        pointPlotWithTheme(\"Line panel grid\") {\n            panel.grid.lineGlobal(eLine)\n        },\n        pointPlotWithTheme(\"Major line panel grid\\n Minor line panel grid\") {\n            panel.grid {\n                majorLine(eLine)\n                minorLine(eLine2)\n            }\n        },\n        barPlotWithTheme(\"Blank major x-line panel grid\\n major y-line panel grid\\n minor y-line panel grid\") {\n            panel.grid {\n                majorXLine {\n                    blank = true\n                }\n                majorYLine(eLine)\n                minorYLine(eLine2)\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barFacetPlotWithTheme(\"Grey Theme\", Theme.Grey),\n        barFacetPlotWithTheme(\"Strip background\") { strip.background(eBackground) },\n        barFacetPlotWithTheme(\"Blank strip background\") {\n            strip.background {\n                blank = true\n            }\n        },\n        barFacetPlotWithTheme(\"Blank strip text\") {\n            strip.text {\n                blank = true\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        barPlotWithTheme(\"x-axis line\") { xAxis.line(eLine3) },\n        barPlotWithTheme(\"On top x-axis line\") {\n            xAxis {\n                line(eLine3)\n                onTop = true\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre>"},{"location":"kandy/docs/topics/guides/Themes-Guide/#miscellaneous","title":"Miscellaneous","text":"<pre><code>plotGrid(\n    listOf(\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Default\"\n            }\n        },\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Plot 1\"\n                theme {\n                    global {\n                        line(eLine)\n                        text(eText)\n                    }\n                }\n            }\n        },\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Plot 2\"\n                theme {\n                    axis {\n                        line(eLine)\n                        onTop = true\n                    }\n                    legend.title(eText)\n                }\n            }\n        },\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Plot 3\"\n                theme {\n                    plotCanvas.title(eText)\n                    panel {\n                        background(eBackground)\n                        grid {\n                            majorXLine {\n                                blank = true\n                            }\n                            minorXLine {\n                                blank = true\n                            }\n                            majorYLine(eLine)\n                            minorYLine(eLine2)\n                        }\n                    }\n                }\n            }\n        },\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Plot 4\"\n                theme {\n                    strip {\n                        background(eBackground)\n                        text(eText)\n                    }\n                }\n            }\n        },\n        fPlotDf.plot {\n            bars {\n                x(fl)\n                y(count)\n                fillColor(fl)\n            }\n            coordFlip()\n            layout {\n                title = \"Plot 5\"\n                theme {\n                    xAxis {\n                        text(eText)\n                        title(eText)\n                        ticks(eLine)\n                        line(eLine2)\n                        tooltip.background {\n                            blank = true\n                        }\n                    }\n                }\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <pre><code>plotGrid(\n    listOf(\n        df.plot {\n            points {\n                x(cty)\n                y(hwy)\n                color(fl)\n\n                tooltips(anchor = Anchor.TOP_CENTER, minWidth = 50.0) {}\n            }\n            layout.title = \"Tooltip: top-center\"\n        },\n        df.plot {\n            points {\n                x(cty)\n                y(hwy)\n                color(fl)\n\n                tooltips(anchor = Anchor.TOP_CENTER, minWidth = 50.0) {}\n            }\n            layout {\n                title = \"Grey background\"\n                theme {\n                    panel.background {\n                        borderLineColor = Color.PURPLE\n                        fillColor = Color.GREY\n                    }\n                }\n            }\n        }\n    ),\n    nCol = 2\n)\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Title-Subtitle-Caption-Guide/","title":"Title, subtitle, and caption","text":"<p> Enhance your ability to communicate effectively in data visualization using Kandy's guide on Titles, Subtitles, and Captions.  Improve your skills in creating effective and insightful titles that boost the comprehensibility of your charts. </p> <p> Enhance your charts with clear messaging using Kandy's guide on Titles, Subtitles, and Captions. Discover how to convey your data's story more effectively. </p> <p> Explore Kandy's guide to Titles, Subtitles, and Captions, and learn how to add descriptive elements to your charts for better clarity and impact. </p> <pre><code>val mpgDf =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDf.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18 1999 4 auto\\(l5\\) f 18 29 p compact 2 audi a4 18 1999 4 manual\\(m5\\) f 21 29 p compact 3 audi a4 2 2008 4 manual\\(m6\\) f 20 31 p compact 4 audi a4 2 2008 4 auto\\(av\\) f 21 30 p compact 5 audi a4 28 1999 6 auto\\(l5\\) f 16 26 p compact <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout.title = \"The plot title using 'layout.title'\"\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title using 'Layout context'\"\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title\"\n        subtitle = \"The plot subtitle\"\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title\"\n        subtitle = \"The plot subtitle\"\n        caption = \"The plot caption\"\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title\"\n        subtitle = \"The plot subtitle\"\n        caption = \"The plot caption\"\n        theme {\n            global.title {\n                color = Color.BLUE\n            }\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title\"\n        subtitle = \"The plot subtitle\"\n        caption = \"The plot caption\"\n        theme {\n            global {\n                text {\n                    fontFace = FontFace.ITALIC\n                }\n                title {\n                    fontFace = FontFace.ITALIC\n                }\n            }\n            plotCanvas {\n                title {\n                    color = Color.BLUE\n                }\n                subtitle {\n                    fontFace = FontFace.ITALIC\n                }\n                caption {\n                    fontFace = FontFace.ITALIC\n                }\n            }\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title\"\n        subtitle = \"The plot subtitle\"\n        caption = \"The plot caption\"\n        theme {\n            plotCanvas {\n                title {\n                    color = Color.BLUE\n                }\n                subtitle {\n                    color = Color.RED\n                }\n                caption {\n                    color = Color.named(\"dark_green\")\n                }\n            }\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(drv)\n    }\n    layout {\n        title = \"The plot title:\\nFuel efficiency for most popular models of car\"\n        subtitle = \"The plot subtitle:\\nPoints are colored by the type of drive train\"\n        caption = \"The plot caption:\\nmpg dataset\"\n        theme {\n            plotCanvas {\n                subtitle {\n                    color = Color.GREY\n                }\n            }\n        }\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(cty) { legend.name = \"City mileage\" }\n        symbol(drv) { legend.name = \"Drive type\" }\n        size = 4.0\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(cty) { legend.name = \"City mileage\" }\n        symbol(drv) { legend.name = \"Drive type\" }\n        size = 4.0\n    }\n    layout.theme {\n        legend.position = LegendPosition.Bottom\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(cty) { legend.name = \"City mileage\\n(mpg)\" }\n        symbol(drv) { legend.name = \"Drive type\\n(front/4/rear wheel)\" }\n        size = 4.0\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(cty) { legend.name = \"City mileage\\n(mpg)\" }\n        symbol(drv) { legend.name = \"Drive type\\n(front/4/rear wheel)\" }\n        size = 4.0\n    }\n    layout.theme {\n        legend.position = LegendPosition.Bottom\n    }\n}\n</code></pre> <p></p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(hwy)\n        color(cty) { legend.name = \"City mileage\\n(mpg)\" }\n        symbol(drv) {\n            legend {\n                type = LegendType.DiscreteLegend(nRow = 3)\n                name = \"Drive type\\n(front/4/rear wheel)\"\n            }\n        }\n        size = 4.0\n    }\n    layout.theme {\n        legend.position = LegendPosition.Bottom\n    }\n}\n</code></pre> <p></p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/","title":"Tooltips","text":"<p> Unlock interactive data exploration with Kandy's Tooltips guide. Learn how to implement and customize tooltips to reveal detailed data insights on hover, enhancing user engagement with your visualizations. </p> <p> Kandy's Tooltips guide: A key to interactive charts. Discover how to use tooltips to display rich data details, providing a more engaging and informative visual experience. </p> <p> Dive into Kandy's guide on Tooltips to add interactive elements to your charts. Learn to display data insights dynamically, making your visualizations more engaging and informative. </p> <p>This guide is taken from lets-plot: Tooltip Customization.</p> <p>You can customize the content of tooltips for the layer by using the parameter <code>tooltips</code> of layer functions.</p> <p>The following parameters and functions set lines, define the formatting of the tooltip, its location and width:</p> <pre><code>tooltips(variables, formats, title, anchor, minWidth, hide) {\n  LayerTooltipsContext -&gt; line(template)\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-variables-parameter-optional","title":"Tooltip <code>variables</code> parameter (optional)","text":"<p>The <code>variables</code> parameter defines a list of variable names, which values will be placed line by line in the general tooltip. If formatting is specified for a variable from this list (with the <code>format</code> function), it will be applied. Otherwise, the default formatting is used. Additional tooltip lines can be specified using the <code>line</code> functions.</p> <p>This is useful for configuring the tooltip content, instead of using the <code>line()</code> method to configure each line of the tooltip.</p> <p>Set the list of variables to place them in a multiline tooltip with the default formatting:</p> <pre><code>val mpgDf =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\nmpgDf.head()\n</code></pre> untitled manufacturer model displ year cyl trans drv cty hwy fl class 1 audi a4 18 1999 4 auto\\(l5\\) f 18 29 p compact 2 audi a4 18 1999 4 manual\\(m5\\) f 21 29 p compact 3 audi a4 2 2008 4 manual\\(m6\\) f 20 31 p compact 4 audi a4 2 2008 4 auto\\(av\\) f 21 30 p compact 5 audi a4 28 1999 6 auto\\(l5\\) f 16 26 p compact <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(manufacturer, model, `class`, drv)\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-formats-parameter","title":"Tooltip <code>formats</code> parameter","text":"<p>Parameter <code>formats</code> defines the format for displaying the value. The format will be applied to the mapped value in the default tooltip or to the corresponding value specified in the <code>line</code> template. The format to apply to the field. The format contains a number format (<code>'1.f'</code>) or a string template (<code>'{.1f}'</code>). The numeric format for non-numeric value will be ignored. The string template contains \u201creplacement fields\u201d surrounded by curly braces <code>{}</code>. Any code not in the braces is considered literal text, and it will be copied unchanged to the result string. If you need to include a brace character in the literal text, it can be escaped by doubling: {{ and }}. For example:</p> <ul> <li><code>cty to \".1f\")</code> -&gt; <code>\"17.0\"</code></li> <li><code>cty to \"{.2f} (mpg)\"))</code> -&gt; <code>\"17.00 (mpg)\"</code></li> <li><code>cty to \"{{{.2f}}}\")</code> -&gt; <code>\"{17.00}\"</code></li> <li><code>model to \"{} {{text}}\")</code> -&gt; <code>\"mustang {text}\"</code></li> </ul>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#customizing-tooltip-lines","title":"Customizing tooltip lines","text":"<p>Specifies the string template to use in a general tooltip. If you add <code>line()</code>, it overrides the default tooltip.</p> <ul> <li><code>line(\"text\")</code> -&gt; <code>\"text\"</code></li> <li><code>line(\"{{text}}\")</code> -&gt; <code>\"{text}\"</code></li> <li><code>line(\"${value(model)}\")</code> -&gt; <code>\"mustang\"</code></li> <li><code>line(\"${model.tooltipValue()}\")</code> -&gt; <code>\"mustang\"</code></li> </ul>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#labels-configuration","title":"Labels configuration","text":"<p>The default tooltip has a label before the value, usually containing the name of the mapped variable. It has its own behavior similar to a blank label for an axis aesthetics. This default label can be set in the template by using a pair of symbols <code>@|</code>. You can override the label by specifying a string value before <code>|</code> symbol.</p> <p>Within the tooltip line, you can align the label to left. The string formed by a template can be aligned to right. If you do not specify a label, the string will be centered in the tooltip. For example:</p> <ul> <li><code>line(\"^color\")</code>: no label, value is centered;</li> <li><code>line(\"|^color\")</code>: label is empty, value is right-aligned;</li> <li><code>line(\"@|^color\")</code>: default label is used, value is right-aligned;</li> <li><code>line(\"my label|^color\")</code>: label is specified, value is right-aligned.</li> </ul>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-title-parameter","title":"Tooltip Title Parameter","text":"<p>Adds a title template to the tooltip.</p> <p>The specification rules are the same as for the <code>line()</code> function.</p> <p>A long title can be split into multiple lines using \\n as a text separator.</p>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-anchor","title":"Tooltip anchor","text":"<p>Specifies a fixed position for a general tooltip.</p> <p>The <code>Anchor</code> object accepts the following values:</p> <ul> <li><code>TOP_RIGHT</code></li> <li><code>TOP_CENTER</code></li> <li><code>TOP_LEFT</code></li> <li><code>BOTTOM_RIGHT</code></li> <li><code>BOTTOM_CENTER</code></li> <li><code>BOTTOM_LEFT</code></li> <li><code>MIDDLE_RIGHT</code></li> <li><code>MIDDLE_CENTER</code></li> <li><code>MIDDLE_LEFT</code></li> </ul>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#minimum-width-of-general-tooltip","title":"Minimum width of general tooltip","text":"<p>Specifies minimum width of a general tooltip in pixels.</p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips {\n            line(\"${manufacturer.tooltipValue()} ${model.tooltipValue()}\")\n            line(\"cty/hwy|${cty.tooltipValue(\".1f\")}/${hwy.tooltipValue(\".1f\")}\")\n            line(`class`)\n            line(\"drive train\", drv.tooltipValue(\"{}wd\"))\n            line(year, format = \"d\")\n        }\n    }\n\n    layout {\n        theme {\n            legend.position = LegendPosition.None\n        }\n    }\n}\n</code></pre> <p></p> <p>Change format for the default tooltip:</p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips {\n            varLine(\"hwy\", \"{.2f} (mpg)\")\n        }\n    }\n}\n</code></pre> <p></p> <p>Place a general tooltip at the top center and define its minimum width:</p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(anchor = Anchor.TOP_CENTER, minWidth = 200.0) {\n            line(\"${manufacturer.tooltipValue()} ${model.tooltipValue()}\")\n            line(\"cty/hwy|${cty.tooltipValue(\".1f\")}/${hwy.tooltipValue(\".1f\")}\")\n            line(`class`)\n            line(\"drive train\", drv.tooltipValue(\"{}wd\"))\n            line(year, format = \"d\")\n        }\n    }\n}\n</code></pre> <p></p> <p>Move the tooltips to the top right corner:</p> <pre><code>val irisDf = DataFrame.readCSV(\n    \"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/iris.csv\",\n    parserOptions = ParserOptions(Locale.ENGLISH)\n)\nirisDf.head()\n</code></pre> sepal_length sepal_width petal_length petal_width species 5.1 3.5 1.4 0.2 setosa 4.9 3 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5 3.6 1.4 0.2 setosa <pre><code>irisDf.groupBy { species }.plot {\n    densityPlot(sepal_length) {\n        tooltips(anchor = Anchor.TOP_RIGHT) {\n            line(species.tooltipValue())\n            line(\"length\", Stat.x.tooltipValue())\n            line(\"density\", Stat.density.tooltipValue())\n        }\n    }\n    layout {\n        theme { legend.position = LegendPosition.None }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#side-tooltips-configuration","title":"Side tooltips configuration","text":"<p>In Kandy, certain aesthetics by default are represented by a so-called \"side tooltip\" \u2014 a small tipped box containing just a single numeric value.</p> <p>You can override these defaults using the <code>line()</code> function. Configuring a \"line\" in a general multi-line tooltip disables side tooltip for the correspondent aesthetic.</p> <pre><code>mpgDf.plot {\n    boxplot(`class`, hwy) {\n        boxes {\n            tooltips {\n                line(\"y min/max\", \"${Stat.min.tooltipValue()}, ${Stat.max.tooltipValue()}\")\n                line(\"lower/upper\", \"${Stat.lower.tooltipValue()}, ${Stat.upper.tooltipValue()}\")\n                line(\"middle\", Stat.middle.tooltipValue())\n            }\n        }\n    }\n}\n</code></pre> <p></p> <p>Place the tooltip at the top center:</p> <pre><code>mpgDf.plot {\n    boxplot(`class`, hwy) {\n        boxes {\n            tooltips(anchor = Anchor.TOP_CENTER) {\n                line(\"middle\", Stat.middle.tooltipValue(\".2f\"))\n                line(\"lower/upper\", \"${Stat.lower.tooltipValue(\"d\")}, ${Stat.upper.tooltipValue(\"d\")}\")\n                line(\"y min/max\", \"${Stat.min.tooltipValue(\"d\")}, ${Stat.max.tooltipValue(\"d\")}\")\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#hiding-tooltips","title":"Hiding tooltips","text":"<p>Set <code>tooltips(true)</code> to hide tooltips from the layer.</p> <p>To hide axis tooltips, you can set \"blank\" parameters of the <code>theme()</code> function.</p> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(hide = true)\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-title","title":"Tooltip Title","text":""},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#splitting-text-using-n","title":"Splitting text using <code>\\n</code>","text":"<pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips {\n            line(\"${value(manufacturer)} \\n${value(model)}\")\n            line(`class`)\n            line(year)\n        }\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#adding-a-title","title":"Adding a title","text":"<pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(title = \"${value(manufacturer)} ${value(model)}\") {}\n    }\n    layout {\n        theme { legend.position = LegendPosition.None }\n    }\n}\n</code></pre> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(`class`, year, title = \"${value(manufacturer)} ${value(model)}\") {}\n    }\n    layout {\n        theme { legend.position = LegendPosition.None }\n    }\n}\n</code></pre> <pre><code>mpgDf.plot {\n    points {\n        x(displ)\n        y(cty)\n        fillColor(drv)\n        size(hwy)\n\n        symbol = Symbol.CIRCLE_FILLED\n        color = Color.GREY\n\n        tooltips(title = \"Car info: \\n${value(manufacturer)} ${value(model)}\") {\n            line(`class`)\n            line(\"drive train\", value(drv))\n            line(year)\n        }\n    }\n    layout {\n        theme { legend.position = LegendPosition.None }\n    }\n}\n</code></pre>"},{"location":"kandy/docs/topics/guides/Tooltips-Guide/#tooltip-theme","title":"Tooltip Theme","text":"<pre><code>val dataset = dataFrameOf(\"x\" to listOf(0.0, 1.0), \"y\" to listOf(0.0, 1.0))\n</code></pre> <pre><code>plot(dataset) {\n    tiles {\n        x(\"x\")\n        y(\"y\")\n        fillColor = Color.GREY\n\n        tooltips(title = \"Tooltip title\") {\n            line(\"label|value\")\n        }\n    }\n}\n</code></pre> <pre><code>plot(dataset) {\n    tiles {\n        x(\"x\")\n        y(\"y\")\n        fillColor = Color.GREY\n\n        tooltips(title = \"Tooltip title\") {\n            line(\"label|value\")\n        }\n    }\n\n    layout.theme {\n        layerTooltips {\n            background {\n                borderLineColor = Color.hex(\"#225e32\")\n                fillColor = Color.hex(\"#238b45\")\n                borderLineWidth = 2.0\n            }\n            text {\n                color = Color.hex(\"#bae4b3\")\n            }\n            title {\n                color = Color.hex(\"#edf8e9\")\n            }\n        }\n        xAxis.tooltip.text {\n            color = Color.GREEN\n        }\n    }\n}\n</code></pre> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/Area/","title":"Area","text":"<p> Area plot examples in the Kandy Kotlin library </p> <p> Area Examples </p> <p> Area Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Bars/","title":"Bars","text":"<p> Bar plot examples in the Kandy Kotlin library </p> <p> Bar Examples </p> <p> Bar Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Boxplot/","title":"Boxplot","text":"<p> Boxplot examples in the Kandy Kotlin library </p> <p> Boxplot Examples </p> <p> Boxplot Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Count-Plot/","title":"Count Plot","text":"<p> Count plot examples in the Kandy Kotlin library </p> <p> Count Plot Examples </p> <p> Count Plot Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Density-Plot/","title":"Density Plot","text":"<p> Density plot examples in the Kandy Kotlin library </p> <p> Density Plot Examples </p> <p> Density Plot Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Error-Bars/","title":"Error Bars","text":"<p> Error bar plot examples in the Kandy Kotlin library </p> <p> Error Bar Examples </p> <p> Error Bar Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Heatmap/","title":"Heatmap","text":"<p> Heatmap plot examples in the Kandy Kotlin library </p> <p> Heatmap Examples </p> <p> Heatmap Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Histogram/","title":"Histogram","text":"<p> Histogram plot examples in the Kandy Kotlin library </p> <p> Histogram Examples </p> <p> Histogram Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Layout/","title":"Layout","text":"<p> Layout settings examples in the Kandy Kotlin library </p> <p> Layout Settings Examples </p> <p> Layout Settings Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Line/","title":"Line","text":"<p> Line plot examples in the Kandy Kotlin library </p> <p> Line Examples </p> <p> Line Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Points/","title":"Points","text":"<p> Scatter plot examples in the Kandy Kotlin library </p> <p> Scatter Examples </p> <p> Scatter Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Ribbon/","title":"Ribbon","text":"<p> Ribbon plot examples in the Kandy Kotlin library </p> <p> Ribbon Examples </p> <p> Ribbon Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/Tiles/","title":"Tiles","text":"<p> Tile plot examples in the Kandy Kotlin library </p> <p> Tile Examples </p> <p> Tile Examples </p> <p></p>"},{"location":"kandy/docs/topics/samples/area/Area-Density-Plot/","title":"Density Plot","text":"<p> Discover 'Density Plot' in Kotlin using Kandy, showcasing the distribution of a data set with a density plot. This example highlights how to visualize the probability density of a random sample, making it ideal for statistical analysis and data exploration. </p> <p> 'Density Plot' in Kotlin with Kandy: An insightful example of representing statistical data distributions, perfect for understanding the underlying patterns in a large set of data. </p> <p> Explore 'Density Plot' using Kotlin and Kandy to gain insights into the probability density of random Gaussian samples, a fundamental technique in statistical visualization. </p> <pre><code>val random = java.util.Random(42)\n\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    densityPlot(sample)\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Area-Settings/","title":"Area Settings","text":"<p> Explore 'Area Settings' in Kotlin with Kandy to visualize server load throughout the day. This example demonstrates the impactful use of area plots with customized settings. </p> <p> 'Area Settings' in Kotlin with Kandy: A vivid representation of daily server load using area plots, showcasing how to customize plot aesthetics for enhanced readability. </p> <p> Dive into 'Area Settings' using Kotlin and Kandy, where server load data is elegantly visualized in an area plot, revealing patterns of demand over time. </p> <p> <pre><code>val loadServer = dataFrameOf(\n    \"time\" to listOf(\"00:00\", \"03:00\", \"06:00\", \"09:00\", \"12:00\", \"15:00\", \"18:00\", \"21:00\"),\n    \"load\" to listOf(10, 5, 15, 50, 75, 60, 80, 40)\n)\nval time = column&lt;String&gt;(\"time\")\nval load = column&lt;Int&gt;(\"load\")\n\nloadServer.plot {\n    layout.title = \"Daily Server Load Dynamics\"\n    area {\n        x(time) { axis.name = \"Time\" }\n        y(load) {\n            axis.name = \"Load (%)\"\n            scale = continuous(0..100)\n        }\n        borderLine {\n            color = Color.ORANGE\n            type = LineType.DASHED\n            width = 2.5\n        }\n        fillColor = Color.RED\n        alpha = 0.7\n    }\n}\n</code></pre> <p> <pre><code>val time = listOf(\"00:00\", \"03:00\", \"06:00\", \"09:00\", \"12:00\", \"15:00\", \"18:00\", \"21:00\")\nval load = listOf(10, 5, 15, 50, 75, 60, 80, 40)\n\nplot {\n    layout.title = \"Daily Server Load Dynamics\"\n    area {\n        x(time) { axis.name = \"Time\" }\n        y(load) { axis.name = \"Load (%)\" }\n        borderLine {\n            color = Color.ORANGE\n            type = LineType.DASHED\n            width = 2.5\n        }\n        fillColor = Color.RED\n        alpha = 0.7\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Area-with-Mark-Line/","title":"Area with Mark Line","text":"<p> Discover 'Area with Mark Line' in Kotlin using Kandy, where area plots are enhanced with horizontal mark lines. This example compares the average temperatures of Berlin and Madrid, highlighting them with distinct dashed lines for a clear visual contrast. </p> <p> 'Area with Mark Line' in Kotlin with Kandy: An innovative plot combining area charts with marked average lines, providing a visual comparison of temperature trends in Berlin and Madrid. </p> <p> Explore 'Area with Mark Line' in Kotlin using Kandy, a creative approach to juxtaposing average temperature trends against monthly data for two cities with distinctively marked lines. </p> <p> <pre><code>val months = listOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval tempBerlin =\n    listOf(-0.5, 0.0, 4.8, 9.0, 14.3, 17.5, 19.2, 18.9, 14.5, 9.7, 4.7, 1.0)\nval tempMadrid =\n    listOf(6.3, 7.9, 11.2, 12.9, 16.7, 21.1, 24.7, 24.2, 20.3, 15.4, 9.9, 6.6)\n\nval df = dataFrameOf(\n    \"month\" to months + months,\n    \"temperature\" to tempBerlin + tempMadrid,\n    \"city\" to List(12) { \"Berlin\" } + List(12) { \"Madrid\" }\n)\n\ndf.plot {\n    area {\n        x(\"month\")\n        y(\"temperature\")\n        fillColor(\"city\") {\n            scale = categorical(\"Berlin\" to Color.hex(\"#07C3F2\"), \"Madrid\" to Color.hex(\"#FDB60D\"))\n        }\n        alpha = 0.5\n        borderLine.width = 1.5\n    }\n    hLine {\n        yIntercept.constant(tempBerlin.average())\n        color = Color.BLACK\n        width = 2.0\n        type = LineType.DASHED\n    }\n    hLine {\n        yIntercept.constant(tempMadrid.average())\n        color = Color.RED\n        width = 2.0\n        type = LineType.DASHED\n    }\n    layout.size = 1000 to 450\n}\n</code></pre> <p> <pre><code>val months = listOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval tempBerlin =\n    listOf(-0.5, 0.0, 4.8, 9.0, 14.3, 17.5, 19.2, 18.9, 14.5, 9.7, 4.7, 1.0)\nval tempMadrid =\n    listOf(6.3, 7.9, 11.2, 12.9, 16.7, 21.1, 24.7, 24.2, 20.3, 15.4, 9.9, 6.6)\n\nval df = mapOf(\n    \"month\" to months + months,\n    \"temperature\" to tempBerlin + tempMadrid,\n    \"city\" to List(12) { \"Berlin\" } + List(12) { \"Madrid\" }\n)\n\ndf.plot {\n    area {\n        x(\"month\")\n        y(\"temperature\")\n        fillColor(\"city\") {\n            scale = categorical(\"Berlin\" to Color.hex(\"#07C3F2\"), \"Madrid\" to Color.hex(\"#FDB60D\"))\n        }\n        alpha = 0.5\n        borderLine.width = 1.5\n    }\n    hLine {\n        yIntercept.constant(tempBerlin.average())\n        color = Color.PURPLE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    hLine {\n        yIntercept.constant(tempMadrid.average())\n        color = Color.ORANGE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    layout.size = 1000 to 450\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Area-with-Reversed-Axis/","title":"Area with Reversed Axis","text":"<p> Explore 'Area with Reversed Axis' in Kotlin using Kandy, an intriguing example that visualizes weekly star ratings with a reversed y-axis. This plot creatively flips the conventional chart perspective, offering a unique view of the data.\" </p> <p> 'Area with Reversed Axis' in Kotlin with Kandy: An innovative visualization that turns the traditional area chart upside down, presenting star ratings across the week in a reversed manner. </p> <p> Dive into the 'Area with Reversed Axis' example using Kotlin and Kandy, where the concept of reversing axis in area charts is applied to depict weekly ratings uniquely. </p> <p> <pre><code>val `Day of the Week` by columnOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval `Star Rating (Reversed)` by columnOf(4, 2, 1, 2, 3, 4, 1)\n\nplot {\n    layout.title = \"Weekly Star Ratings\"\n    layout.subtitle = \"A reversed perspective\"\n    area {\n        x(`Day of the Week`)\n        y(`Star Rating (Reversed)`) {\n            scale = continuous(0..5, transform = Transformation.REVERSE)\n        }\n        fillColor = Color.hex(\"#FCF84A\")\n        alpha = 0.75\n    }\n}\n</code></pre> <p> <pre><code>val week = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval stars = listOf(4, 2, 1, 2, 3, 4, 1)\n\nplot {\n    layout.title = \"Weekly Star Ratings\"\n    layout.subtitle = \"A reversed perspective\"\n    area {\n        x(week) { axis.name = \"Day of the Week\" }\n        y(stars) {\n            axis.name = \"Star Rating (Reversed)\"\n            scale = continuous(0..5, transform = Transformation.REVERSE)\n        }\n        fillColor = Color.hex(\"#FCF84A\")\n        alpha = 0.75\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Fixed-Area-Coordinate/","title":"Fixed Area Coordinate","text":"<p> Explore 'Annual Water Level Fluctuations in Reservoir' in Kotlin using Kandy to visualize how water levels change throughout the year. This example demonstrates the seasonal variations in a reservoir, providing insights for water resource management. </p> <p> 'Annual Water Level Fluctuations in Reservoir' in Kotlin with Kandy: An illustrative plot showing the monthly changes in water levels, highlighting seasonal impacts on reservoirs. </p> <p> Dive into the 'Annual Water Level Fluctuations in Reservoir' using Kotlin and Kandy, a graphical representation of water level changes over the year, essential for environmental monitoring. </p> <p> <pre><code>val month by columnOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval waterLvl by columnOf(4.5, 4.7, 5.0, 5.5, 6.0, 6.5, 6.7, 6.2, 5.8, 5.3, 4.8, 4.6)\nval reservoirDf = dataFrameOf(month, waterLvl)\n\nplot(reservoirDf) {\n    layout {\n        title = \"Water Level\"\n        subtitle = \"Annual Water Level Fluctuations in Reservoir\"\n        yAxisLabel = \"Month\"\n        xAxisLabel = \"Water Level (meters)\"\n    }\n\n    x(month)\n    y { limits = 3.0..8.0 }\n    line {\n        y(waterLvl)\n    }\n    area {\n        y.constant(5.0)\n        borderLine.type = LineType.DOTTED\n        alpha = 0.5\n        fillColor = Color.RED\n    }\n}\n</code></pre> <p> <pre><code>val reservoirDf = mapOf(\n    \"month\" to listOf(\n        \"January\", \"February\",\n        \"March\", \"April\", \"May\",\n        \"June\", \"July\", \"August\",\n        \"September\", \"October\", \"November\",\n        \"December\"\n    ),\n    \"waterLvl\" to listOf(4.5, 4.7, 5.0, 5.5, 6.0, 6.5, 6.7, 6.2, 5.8, 5.3, 4.8, 4.6)\n)\n\nplot(reservoirDf) {\n    layout {\n        title = \"Water Level\"\n        subtitle = \"Annual Water Level Fluctuations in Reservoir\"\n        yAxisLabel = \"Month\"\n        xAxisLabel = \"Water Level (meters)\"\n    }\n\n    x(\"month\")\n    y { limits = 3.0..8.0 }\n    line {\n        y(\"waterLvl\")\n    }\n    area {\n        y.constant(5.0)\n        borderLine.type = LineType.DOTTED\n        alpha = 0.5\n        fillColor = Color.RED\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Functional-Area/","title":"Functional Area Plot","text":"<p> Explore 'Functional Area Plot' in Kotlin using Kandy to visualize complex mathematical functions. This example uniquely demonstrates how area plots can be used to represent intricate function behaviors and patterns. </p> <p> 'Functional Area Plot' in Kotlin with Kandy: A mathematical journey into visualizing complex functions using area plots, perfect for an analytical view of functional dynamics. </p> <p> Dive into 'Functional Area Plot' using Kotlin and Kandy, where mathematics meets art in the visualization of complex functional relationships with area plots. </p> <pre><code>val xs = (-2000..2000).map { it / 500.0f }\nval function = { x: Float -&gt; sin(x) * cos(x * 2 + 1) * sin(3 * x + 2) }\nval ys = xs.map(function)\n\nplot {\n    area {\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Several-Areas/","title":"Several Areas","text":"<p> Explore 'Several Areas' in Kotlin using Kandy to see how multiple area plots can be combined for comparative data analysis. This example skillfully illustrates the overlaying of different data sets in a single chart for a comprehensive view. </p> <p> 'Several Areas' in Kotlin with Kandy: A demonstration of layering multiple area plots, ideal for juxtaposing varied data sets in an insightful and visually appealing manner. </p> <p> Dive into 'Several Areas' using Kotlin and Kandy, a sophisticated example of blending multiple area plots, perfect for in-depth comparative data visualization. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"year\" to listOf(\"2016\", \"2017\", \"2018\", \"2019\", \"2020\", \"2021\"),\n    \"Apple\" to listOf(700, 800, 750, 900, 850, 950),\n    \"Google\" to listOf(1000, 950, 1200, 1150, 1250, 1300),\n    \"Microsoft\" to listOf(600, 700, 650, 700, 750, 800),\n    \"Meta\" to listOf(1100, 1200, 1150, 1300, 1250, 1350),\n    \"Amazon\" to listOf(300, 400, 350, 450, 500, 600)\n).gather(\"Apple\", \"Google\", \"Microsoft\", \"Meta\", \"Amazon\").into(\"company\", \"users\")\n\ndataset.groupBy(\"company\").plot {\n    layout.title = \"User Growth Dynamics\"\n    area {\n        x(\"year\")\n        y(\"users\")\n        fillColor(\"company\") {\n            scale = categorical(\n                \"Apple\" to Color.hex(\"#FF45ED\"),\n                \"Google\" to Color.hex(\"#3DEA62\"),\n                \"Microsoft\" to Color.BLACK,\n                \"Meta\" to Color.hex(\"#FDB60D\"),\n                \"Amazon\" to Color.hex(\"#087CFA\")\n            )\n        }\n        borderLine.color(\"company\")\n        alpha = 0.3\n    }\n}\n</code></pre> <p> <pre><code>val year = listOf(\"2016\", \"2017\", \"2018\", \"2019\", \"2020\", \"2021\")\n\nval usersApple = listOf(700, 800, 750, 900, 850, 950)\nval usersGoogle = listOf(1000, 950, 1200, 1150, 1250, 1300)\nval usersMicrosoft = listOf(600, 700, 650, 700, 750, 800)\nval usersMeta = listOf(1100, 1200, 1150, 1300, 1250, 1350)\nval usersAmazon = listOf(300, 400, 350, 450, 500, 600)\n\nval dataset = mapOf(\n    \"year\" to year + year + year + year + year,\n    \"users\" to usersApple + usersGoogle + usersMicrosoft + usersMeta + usersAmazon,\n    \"company\" to List(6) { \"Apple\" } + List(6) { \"Google\" } + List(6) { \"Microsoft\" } + List(6) { \"Meta\" } + List(\n        6\n    ) { \"Amazon\" }\n)\n\nplot(dataset) {\n    layout.title = \"User Growth Dynamics\"\n    groupBy(\"company\") {\n        area {\n            x(\"year\")\n            y(\"users\")\n            fillColor(\"company\") {\n                scale = categorical(\n                    \"Apple\" to Color.hex(\"#FF45ED\"),\n                    \"Google\" to Color.hex(\"#3DEA62\"),\n                    \"Microsoft\" to Color.BLACK,\n                    \"Meta\" to Color.hex(\"#FDB60D\"),\n                    \"Amazon\" to Color.hex(\"#087CFA\")\n                )\n            }\n            borderLine.color(\"company\")\n            alpha = 0.3\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Simple-Area/","title":"Simple Area","text":"<p> Discover 'Simple Area' in Kotlin using Kandy, a clear and straightforward example of area plotting. This example visualizes cost data over several years, demonstrating the effectiveness of area charts in data representation. </p> <p> 'Simple Area' in Kotlin with Kandy: An elegant demonstration of area plots, showcasing yearly cost trends in a visually intuitive manner. </p> <p> Explore the 'Simple Area' example using Kotlin and Kandy, a perfect illustration of how area charts can be used to depict trends over time. </p> <p> <pre><code>val dataframe = dataFrameOf(\n    \"years\" to listOf(\"2017\", \"2018\", \"2019\", \"2020\", \"2021\", \"2022\", \"2023\"),\n    \"cost\" to listOf(56.1, 22.7, 34.7, 82.1, 53.7, 68.5, 39.9)\n)\n\ndataframe.plot {\n    area {\n        x(\"years\")\n        y(\"cost\")\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2017\", \"2018\", \"2019\", \"2020\", \"2021\", \"2022\", \"2023\")\nval cost = listOf(56.1, 22.7, 34.7, 82.1, 53.7, 68.5, 39.9)\n\nplot {\n    area {\n        x(years)\n        y(cost)\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Smoothed-Area-with-Points/","title":"Smoothed Area with Points","text":"<p> Explore 'Smoothed Area with Points' in Kotlin using Kandy, a visualization that combines smoothed area plots with distinct data points. This example is perfect for depicting trends and individual data points together, offering both a general overview and specific insights. </p> <p> 'Smoothed Area with Points' in Kotlin with Kandy: A harmonious blend of smoothed area charts and point markers, ideal for illustrating data trends alongside specific values. </p> <p> Dive into 'Smoothed Area with Points' using Kotlin and Kandy, where smoothed area visualization meets individual data points, providing a comprehensive view of the data. </p> <pre><code>val xs = listOf(-3.0, -2.5, -2.0, -1.5, -1.0, 0.0, 1.0, 1.5, 2.0, 2.5, 3.0)\nval ys = listOf(5.4, 1.2, 3.4, 0.7, 0.8, 2.1, 0.6, 2.2, 3.4, 4.5, 6.7)\n\nplot {\n    statSmooth(xs, ys, method = SmoothMethod.LOESS(span = 0.3)) {\n        area {\n            x(Stat.x)\n            y(Stat.y)\n            alpha = 0.75\n            fillColor = Color.LIGHT_GREEN\n            borderLine.color = Color.LIGHT_PURPLE\n        }\n    }\n    points {\n        size = 4.0\n        color = Color.ORANGE\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/area/Smoothed-Area/","title":"Smoothed Area","text":"<p> Explore the 'Smoothed Area' plot in Kotlin using Kandy to see how smoothing techniques can enhance area plots. This example visualizes data with a smoothed curve. </p> <p> 'Smoothed Area' in Kotlin with Kandy: A seamless blend of data smoothing and area plotting, ideal for portraying subtle data patterns in a visually appealing way. </p> <p> Dive into 'Smoothed Area' using Kotlin and Kandy, showcasing the elegance and clarity of smoothed curves in area plot visualization. </p> <pre><code>val xs = listOf(-3.0, -2.5, -2.0, -1.5, -1.0, 0.0, 1.0, 1.5, 2.0, 2.5, 3.0)\nval ys = listOf(5.4, 1.2, 3.4, 0.1, 0.6, 2.1, 0.6, 2.2, 3.4, 4.5, 6.7)\n\nplot {\n    statSmooth(xs, ys, smootherPointCount = 30) {\n        area {\n            x(Stat.x)\n            y(Stat.y)\n            borderLine {\n                color = Color.GREEN\n                width = 2.0\n            }\n            alpha = 0.6\n            fillColor = Color.LIGHT_GREEN\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Bar-Gradient/","title":"Bar Gradient","text":"<p> Explore the 'Bar Gradient' example in Kotlin using Kandy, a visually striking demonstration of using color gradients in bar plots. This example illustrates how gradients can be effectively used to represent varying data intensities or categories within a bar chart, enhancing both aesthetics and data interpretation. </p> <p> 'Bar Gradient' in Kotlin with Kandy: A vivid portrayal of data using color gradients in bar charts, perfect for adding a visual depth to categorical comparisons. </p> <p> Dive into 'Bar Gradient' using Kotlin and Kandy, showcasing the dynamic use of color gradients in bar plotting to enrich data visualization and provide more nuanced insights. </p> <p> <pre><code>val cities by columnOf(\"London\", \"Paris\", \"Berlin\", \"Madrid\", \"Rome\", \"Amsterdam\", \"Prague\")\nval airPollution by columnOf(70, 65, 50, 60, 55, 45, 53)\nval numberOfCars by columnOf(3000, 2800, 1800, 2500, 2100, 1300, 2000)\n\nval dataset = dataFrameOf(cities, airPollution, numberOfCars)\n\ndataset.plot {\n    layout.title = \"Air Pollution and Vehicle Count Analysis\"\n    bars {\n        x(cities) { axis.name = \"City\" }\n        y(numberOfCars) { axis.name = \"Number of cars (thousands)\" }\n        fillColor(airPollution) {\n            legend.name = \"Air Pollution\\n Level (AQI)\"\n            scale = continuous(Color.GREEN..Color.RED)\n        }\n        alpha = 0.8\n    }\n}\n</code></pre> <p> <pre><code>val dataset = mapOf(\n    \"city\" to listOf(\"London\", \"Paris\", \"Berlin\", \"Madrid\", \"Rome\", \"Amsterdam\", \"Prague\"),\n    \"airPollution\" to listOf(70, 65, 55, 60, 50, 45, 52),\n    \"numberOfCars\" to listOf(3000, 2800, 2000, 2500, 2200, 1500, 1800)\n)\n\ndataset.plot {\n    bars {\n        x(\"city\") { axis.name = \"City\" }\n        y(\"numberOfCars\") { axis.name = \"Number of cars (thousands)\" }\n        fillColor(\"airPollution\") {\n            legend.name = \"Air Pollution\\n Level (AQI)\"\n            scale = continuous(Color.GREEN..Color.RED)\n        }\n        alpha = 0.8\n    }\n\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Bar-Settings/","title":"Bar Settings","text":"<p> Discover the 'Bar Settings' example in Kotlin using Kandy, showcasing various customizations and settings for bar plots. This example is ideal for learning how to tweak bar plot appearances for more engaging and informative visualizations. </p> <p> 'Bar Settings' in Kotlin with Kandy: A detailed demonstration of the versatility in bar plot customization, perfect for tailoring visual representations to specific data storytelling needs. </p> <p> Explore the 'Bar Settings' example using Kotlin and Kandy to understand the depth of customization available in bar plotting, from color adjustments to layout tweaks. </p> <p> <pre><code>val candy by columnOf(\n    \"Honey Stars\", \"Fairy Tale Caramels\", \" ChocoDream\", \"Fruity Clouds\",\n    \"Minty Spheres\", \"Sour Strips\", \"Vanilla Bars\"\n)\nval sugar by columnOf(65, 58, 53, 35, 40, 45, 50)\n\nplot {\n    layout {\n        title = \"Sugar content\"\n        xAxisLabel = \"Candy Name\"\n        yAxisLabel = \"Sugar Content (g per 100g)\"\n    }\n    bars {\n        x(candy)\n        y(sugar) { scale = continuous(0..100) }\n        fillColor = Color.ORANGE\n        alpha = 0.85\n        borderLine {\n            color = Color.GREY\n            width = 1.3\n        }\n    }\n}\n</code></pre> <p> <pre><code>val candy = listOf(\n    \"Honey Stars\", \"Fairy Tale Caramels\", \" ChocoDream\", \"Fruity Clouds\",\n    \"Minty Spheres\", \"Sour Strips\", \"Vanilla Bars\"\n)\nval sugar = listOf(65, 58, 53, 35, 40, 45, 50)\n\nplot {\n    layout {\n        title = \"Sugar content\"\n        xAxisLabel = \"Candy Name\"\n        yAxisLabel = \"Sugar Content (g per 100g)\"\n    }\n    bars {\n        x(candy)\n        y(sugar) { scale = continuous(0..100) }\n        fillColor = Color.ORANGE\n        alpha = 0.85\n        borderLine {\n            color = Color.GREY\n            width = 1.3\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Bar-with-Reversed-Axis/","title":"Bar with Reversed Axis","text":"<p> Discover 'Bar with Reversed Axis' in Kotlin using Kandy, showcasing how reversing an axis in a bar plot can provide a different perspective on data. This example is particularly useful for visualizing scenarios where lower values hold more significance. </p> <p> 'Bar with Reversed Axis' in Kotlin with Kandy: An innovative twist on traditional bar plots, ideal for emphasizing smaller values in data comparisons and analyses. </p> <p> Explore 'Bar with Reversed Axis' using Kotlin and Kandy, a unique approach to bar chart visualization, offering fresh insights by inverting the conventional axis arrangement. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"task\" to listOf(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    \"time\" to listOf(30, 25, 20, 35, 28)\n)\n\ndataset.plot {\n    bars {\n        x(\"task\")\n        y(\"time\") {\n            scale = continuous(transform = Transformation.REVERSE)\n        }\n        fillColor = Color.hex(\"#07C3F2\")\n    }\n}\n</code></pre> <p> <pre><code>val dataset = mapOf(\n    \"task\" to listOf(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    \"time\" to listOf(30, 25, 20, 35, 28)\n)\n\ndataset.plot {\n    bars {\n        x(\"task\")\n        y(\"time\") {\n            scale = continuous(transform = Transformation.REVERSE)\n        }\n        fillColor = Color.hex(\"#07C3F2\")\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Fixed-Bar-Coordinate/","title":"Fixed Bar Coordinate","text":"<p> Explore 'Fixed Bar Coordinate' in Kotlin using Kandy, a unique approach to bar plotting where one of the coordinates is fixed, creating a standard reference point for comparison. This example is ideal for analyzing categories against a constant value or benchmark. </p> <p> 'Fixed Bar Coordinate' in Kotlin with Kandy: A specialized bar plot where one axis remains constant, perfect for direct comparisons across a uniform scale. </p> <p> Dive into 'Fixed Bar Coordinate' using Kotlin and Kandy, where bar plots are transformed by fixing one coordinate, providing a clear and consistent basis for comparison. </p> <pre><code>plot {\n    x(listOf(2017, 2018, 2019, 2020, 2021, 2022, 2023)) {\n        axis.breaks(format = \"d\")\n    }\n    bars {\n        y.constant(100)\n        width = 0.5\n        fillColor = Color.GREY\n        alpha = 0.3\n    }\n    bars {\n        y(listOf(20, 100, 50, 80, 70, 10, 30))\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Functional-Bars/","title":"Functional Bar Plot","text":"<p> Discover 'Functional Bar Plot' in Kotlin using Kandy, where mathematical functions meet bar plotting. This example illustrates the visualization of a sine function using bars, offering a unique perspective on function values. </p> <p> 'Functional Bar Plot' in Kotlin: A creative blend of math and visualization, showcasing how bars can represent a sine function's values in a compelling format. </p> <p> Explore 'Functional Bar Plot' with Kotlin and Kandy, a fusion of mathematical function plotting and bar charts. </p> <pre><code>val xs = (-80..80).map { it.toDouble() / 8.0 }\nval function = { x: Double -&gt; sin(x / 1.5) }\nval ys = xs.map(function)\n\nplot {\n    bars {\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Grouped-Bars/","title":"Grouped Bars","text":"<p> Explore 'Grouped Bars' in Kotlin using Kandy, a clear demonstration of grouping in bar charts. This example effectively showcases the comparison of multiple data sets side by side within the same category, ideal for comparative analysis across different groups or variables. </p> <p> 'Grouped Bars' in Kotlin with Kandy: A powerful tool for visual comparison, this example highlights how to group data sets in bar charts for a comprehensive comparative view. </p> <p> Dive into 'Grouped Bars' using Kotlin and Kandy, where the concept of grouped bar plotting is used to juxtapose different data sets within the same categories. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"day\" to listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"),\n    \"coffee\" to listOf(0.81, 0.78, 0.72, 0.65, 0.73, 0.49, 0.38),\n    \"tea\" to listOf(0.12, 0.16, 0.21, 0.26, 0.24, 0.22, 0.30),\n    \"soda\" to listOf(0.07, 0.06, 0.07, 0.09, 0.03, 0.29, 0.32),\n).gather(\"coffee\", \"tea\", \"soda\").into(\"drink\", \"amount\")\n\ndataset.groupBy(\"drink\").plot {\n    layout.title = \"Weekly Beverage Consumption Trends\"\n    bars {\n        x(\"day\")\n        y(\"amount\")\n        fillColor(\"drink\") {\n            scale = categorical(\n                \"coffee\" to Color.hex(\"#6F4E37\"),\n                \"tea\" to Color.hex(\"#C2D4AB\"),\n                \"soda\" to Color.hex(\"#B5651D\")\n            )\n        }\n    }\n}\n</code></pre> <p> <pre><code>val days = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval coffee = listOf(0.81, 0.78, 0.72, 0.65, 0.73, 0.49, 0.38)\nval tea = listOf(0.12, 0.16, 0.21, 0.26, 0.24, 0.22, 0.30)\nval soda = listOf(0.07, 0.06, 0.07, 0.09, 0.03, 0.29, 0.32)\nval dataset = mapOf(\n    \"day\" to days + days + days,\n    \"amount\" to coffee + tea + soda,\n    \"drink\" to List(7) { \"coffee\" } + List(7) { \"tea\" } + List(7) { \"soda\" }\n)\n\ndataset.plot {\n    layout.title = \"Weekly Beverage Consumption Trends\"\n    groupBy(\"drink\") {\n        bars {\n            x(\"day\")\n            y(\"amount\")\n            fillColor(\"drink\") {\n                scale = categorical(\n                    \"coffee\" to Color.hex(\"#6F4E37\"),\n                    \"tea\" to Color.hex(\"#C2D4AB\"),\n                    \"soda\" to Color.hex(\"#B5651D\")\n                )\n            }\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Histogram-Bar-Plot/","title":"Histogram Plot","text":"<p> Explore 'Histogram Plot' in Kotlin using Kandy to understand the distribution of a dataset. This example demonstrates the effective use of histograms in visualizing the frequency of data points. </p> <p> 'Histogram Plot' in Kotlin with Kandy: A clear and straightforward representation of data distribution, perfect for statistical analysis and understanding data trends. </p> <p> Dive into 'Histogram Plot' using Kotlin and Kandy, a fundamental tool in data analysis for visualizing the distribution and frequency of dataset values.\" </p> <p> <pre><code>val random = java.util.Random(1111)\nval sample = List(1000) { random.nextGaussian() }\n\ndataFrameOf(\"sample\" to sample).histogram(\"sample\")\n</code></pre> <p> <pre><code>val random = java.util.Random(1111)\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    histogram(sample)\n}\n</code></pre> <p> <pre><code>val random = java.util.Random(1111)\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    statBin(sample) {\n        bars {\n            x(Stat.x)\n            y(Stat.count)\n        }\n    }\n}\n</code></pre> <p> </p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Horizontal-Bars/","title":"Horizontal Bars","text":"<p> Explore 'Horizontal Bars' in Kotlin using Kandy, an example that demonstrates the effective use of horizontal bar charts in data visualization. This approach is ideal for comparing categories or groups where the length of the bar represents a value, offering a clear and straightforward comparative view. </p> <p> 'Horizontal Bars' in Kotlin with Kandy: A classic approach to bar chart visualization, perfect for showcasing comparisons across categories or groups in a horizontal layout. </p> <p> Dive into 'Horizontal Bars' using Kotlin and Kandy, showcasing the versatility and readability of horizontal bar plots in presenting categorical data. </p> <p> <pre><code>val actors by columnOf(\n    \"John Doe\", \"Emma Stone\", \"Ryan Gosling\", \"Natalie Portman\",\n    \"Brad Pitt\", \"Marilyn Monroe\", \"Leonardo DiCaprio\"\n)\nval screenTime by columnOf(90, 75, 60, 85, 50, 40, 95)\n\nval dataset = dataFrameOf(actors, screenTime)\n\ndataset.plot {\n    layout.title = \"Screen Time of Hollywood Actors\"\n    barsH {\n        y(actors) { axis.name = \"Actors\" }\n        x(screenTime) { axis.name = \"minutes\" }\n        alpha = 0.75\n        fillColor(actors) {\n            scale = categoricalColorHue()\n        }\n    }\n}\n</code></pre> <p> <pre><code>val actors = listOf(\n    \"John Doe\", \"Emma Stone\", \"Ryan Gosling\", \"Natalie Portman\",\n    \"Brad Pitt\", \"Marilyn Monroe\", \"Leonardo DiCaprio\"\n)\nval screenTime = listOf(90, 75, 60, 85, 50, 40, 95)\n\nplot {\n    layout.title = \"Screen Time of Hollywood Actors\"\n    barsH {\n        y(actors) { axis.name = \"Actors\" }\n        x(screenTime) { axis.name = \"minutes\" }\n        alpha = 0.75\n        fillColor(actors) {\n            legend.name = \"actors\"\n            scale = categoricalColorHue()\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Simple-Bars/","title":"Simple Bars","text":"<p> Explore 'Simple Bars' in Kotlin using Kandy for a basic yet insightful demonstration of bar plotting. This example effectively utilizes simple bar charts to present categorical data, making it an ideal starting point for beginners in data visualization. </p> <p> 'Simple Bars' in Kotlin with Kandy: An elementary and clear example of bar chart visualization, perfect for straightforward comparisons of categorical data. </p> <p> Dive into 'Simple Bars' using Kotlin and Kandy, a foundational example of bar plotting, demonstrating the ease and clarity of representing categorical data visually. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"city\" to listOf(\"London\", \"Paris\", \"Berlin\", \"Madrid\", \"Rome\"),\n    \"perc\" to listOf(45, 50, 60, 40, 30)\n)\n\ndataset.plot {\n    layout.title = \"Public Transport Usage in European Cities\"\n    bars {\n        x(\"city\") { axis.name = \"City\" }\n        y(\"perc\") { axis.name = \"Public Transport Usage (%)\" }\n    }\n}\n</code></pre> <p> <pre><code>val city = listOf(\"London\", \"Paris\", \"Berlin\", \"Madrid\", \"Rome\")\nval perc = listOf(45, 50, 60, 40, 30)\n\n\nplot {\n    layout.title = \"Public Transport Usage in European Cities\"\n    bars {\n        x(city) { axis.name = \"City\" }\n        y(perc) { axis.name = \"Public Transport Usage (%)\" }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/bars/Stacked-Bars/","title":"Stacked Bars","text":"<p> Explore 'Stacked Bars' in Kotlin using Kandy to see how data segments can be stacked in bar plots for cumulative analysis. This example is perfect for visualizing how different components contribute to a total within each category, providing a layered understanding of the data. </p> <p> 'Stacked Bars' in Kotlin with Kandy: A dynamic approach to bar chart visualization that stacks data segments, offering an insightful view into how individual parts make up a whole. </p> <p> Dive into 'Stacked Bars' using Kotlin and Kandy, where bar plots are transformed by stacking data layers. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"day\" to listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"),\n    \"coffee\" to listOf(0.81, 0.78, 0.72, 0.65, 0.73, 0.49, 0.38),\n    \"tea\" to listOf(0.12, 0.16, 0.21, 0.26, 0.24, 0.22, 0.30),\n    \"soda\" to listOf(0.07, 0.06, 0.07, 0.09, 0.03, 0.29, 0.32),\n).gather(\"coffee\", \"tea\", \"soda\").into(\"drink\", \"amount\")\n\ndataset.groupBy(\"drink\").plot {\n    layout.title = \"Weekly Beverage Consumption Trends\"\n    bars {\n        x(\"day\")\n        y(\"amount\")\n        fillColor(\"drink\") {\n            scale = categorical(\n                \"coffee\" to Color.hex(\"#6F4E37\"),\n                \"tea\" to Color.hex(\"#C2D4AB\"),\n                \"soda\" to Color.hex(\"#B5651D\")\n            )\n        }\n        position = Position.stack()\n    }\n}\n</code></pre> <p> <pre><code>val days = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval coffee = listOf(0.81, 0.78, 0.72, 0.65, 0.73, 0.49, 0.38)\nval tea = listOf(0.12, 0.16, 0.21, 0.26, 0.24, 0.22, 0.30)\nval soda = listOf(0.07, 0.06, 0.07, 0.09, 0.03, 0.29, 0.32)\nval dataset = mapOf(\n    \"day\" to days + days + days,\n    \"amount\" to coffee + tea + soda,\n    \"drink\" to List(7) { \"coffee\" } + List(7) { \"tea\" } + List(7) { \"soda\" }\n)\n\ndataset.plot {\n    layout.title = \"Weekly Beverage Consumption Trends\"\n    groupBy(\"drink\") {\n        bars {\n            x(\"day\")\n            y(\"amount\")\n            fillColor(\"drink\") {\n                scale = categorical(\n                    \"coffee\" to Color.hex(\"#6F4E37\"),\n                    \"tea\" to Color.hex(\"#C2D4AB\"),\n                    \"soda\" to Color.hex(\"#B5651D\")\n                )\n            }\n            position = Position.stack()\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/boxplot/Boxplot-Categories/","title":"Boxplot Categories","text":"<p> Boxplot Categories in Kandy allows for an intuitive understanding of data distribution across different categories. This example demonstrates how boxplot can effectively compare and contrast data groupings. </p> <p> Understanding Data Diversity: 'Boxplot Categories' in Kandy visually compares data across multiple categories. </p> <p> Dive into category-based data analysis with 'Boxplot Categories' in Kandy, showcasing comparative data distribution. </p> <pre><code>val random = kotlin.random.Random(42)\nfun generateData(category: String) =\n    dataFrameOf((0..&lt;10).map { it.toString() }) { List(100) { random.nextDouble(0.0, 100.0) } }\n        .gather(*(0..&lt;10).map { it.toString() }.toTypedArray())\n        .into(\"num\", \"value\").add(\"category\") { category }\n\nval dataset = generateData(\"category0\")\n    .concat(generateData(\"category1\"))\n    .concat(generateData(\"category2\"))\n\ndataset.groupBy(\"category\").plot {\n    boxplot(\"num\", \"value\") {\n        boxes {\n            position = Position.dodge()\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/boxplot/Boxplot-Expr/","title":"Boxplot of Experiments","text":"<p> Explore scientific data diversity with 'Boxplot of Experiments' in Kandy. This example uses boxplot to visualize the variation and distribution of experimental data, offering insights into the nature of scientific experiments. </p> <p> Scientific Data Insights: 'Boxplot of Experiments' in Kandy showcases the variability and distribution in experimental data. </p> <p> Unravel the complexity of experimental data with 'Boxplot of Experiments' in Kandy, highlighting data distribution and variation. </p> <pre><code>val dataset = dataFrameOf(\n    \"expr0\" to listOf(\n        850, 740, 900, 1070, 930, 850, 950, 980, 980,\n        880, 1000, 980, 930, 650, 760, 810, 1000, 1000, 960, 960\n    ),\n    \"expr1\" to listOf(\n        960, 940, 960, 940, 880, 800, 850, 880, 900, 840, 830,\n        790, 810, 880, 880, 830, 800, 790, 760, 800\n    ),\n    \"expr2\" to listOf(\n        880, 880, 880, 860, 720, 720, 620, 860, 970, 950,\n        880, 910, 850, 870, 840, 840, 850, 840, 840, 840\n    ),\n    \"expr3\" to listOf(\n        890, 810, 810, 820, 800, 770, 760, 740, 750,\n        760, 910, 920, 890, 860, 880, 720, 840, 850, 850, 780\n    ),\n    \"expr4\" to listOf(\n        890, 840, 780, 810, 760, 810, 790, 810, 820,\n        850, 870, 870, 810, 740, 810, 940, 950, 800, 810, 870\n    )\n).gather(\"expr0\", \"expr1\", \"expr2\", \"expr3\", \"expr4\").into(\"expr\", \"value\")\n\n\ndataset.plot {\n    boxplot(\"expr\", \"value\") {\n        boxes {\n            borderLine.color = Color.BLUE\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/boxplot/Boxplot-Life-Exp/","title":"Boxplot Life Expectations by Country","text":"<p> Uncover global health trends with 'Boxplot Life Expectations by Country' in Kandy. This example uses boxplot to compare life expectancy across different countries, highlighting variations and patterns in public health. </p> <p> 'Boxplot Life Expectations by Country' in Kandy visualizes life expectancy variations worldwide. </p> <p> Explore life expectancy trends globally with 'Boxplot Life Expectations by Country' in Kandy, showcasing international health patterns. </p> <pre><code>val countries = arrayOf(\"Australia\", \"Canada\", \"China\", \"Germany\", \"Japan\", \"United Kingdom\", \"United States\")\n\nval australiaLifeExpectancy = listOf(\n    87.29, 83.20, 84.93, 88.72, 87.60, 79.07, 84.85, 81.55, 81.69, 83.23,\n    82.43, 86.36, 84.28, 82.37, 83.33, 83.00, 86.48, 81.38, 82.94, 79.44, 74.34, 83.96, 84.59, 79.77, 88.81,\n    77.64, 82.14, 81.44, 86.60, 86.41, 82.46, 83.13, 79.34, 76.06, 80.96, 82.47, 85.69, 85.61, 80.84, 81.09,\n    78.85, 77.74, 76.88, 87.85, 80.47, 80.69, 78.24, 84.33, 77.16, 81.36\n)\nval canadaLifeExpectancy = listOf(\n    77.42, 82.55, 78.96, 76.28, 80.89, 82.71, 81.27, 82.21, 78.46, 79.55, 78.31,\n    79.56, 77.75, 74.09, 81.71, 79.39, 74.48, 82.85, 77.37, 81.21, 83.92, 81.52, 85.56, 76.06, 82.61, 78.26,\n    77.52, 78.68, 79.75, 81.22, 76.34, 84.60, 82.86, 74.86, 86.95, 88.58, 85.72, 80.28, 76.72, 85.22, 79.39,\n    85.89, 81.83, 84.91, 82.43, 83.83, 81.04, 80.07, 90.56, 79.77\n)\nval chinaLifeExpectancy = listOf(\n    76.08, 88.39, 75.42, 80.75, 79.44, 80.96, 86.69, 77.30, 81.14, 76.65, 63.39,\n    88.37, 78.89, 73.96, 87.45, 84.74, 82.90, 78.07, 89.43, 86.43, 78.80, 73.51, 85.01, 81.11, 79.09, 83.57,\n    83.69, 82.95, 77.55, 82.13, 79.85, 79.99, 78.67, 78.90, 79.85, 88.72, 72.23, 76.12, 74.75, 79.22, 85.58,\n    81.17, 74.86, 72.02, 85.43, 73.34, 81.60, 83.86, 79.86, 75.95\n)\nval germanyLifeExpectancy = listOf(\n    75.98, 73.25, 80.70, 69.84, 83.00, 82.91, 84.36, 75.75, 75.16, 85.21, 87.71,\n    80.55, 92.80, 80.20, 86.26, 74.87, 81.98, 85.70, 83.06, 78.86, 79.04, 73.85, 79.78, 79.95, 78.07, 81.57,\n    73.08, 72.05, 92.45, 76.85, 84.82, 80.43, 80.90, 80.26, 82.40, 80.84, 88.51, 87.48, 78.37, 71.97, 81.41,\n    88.58, 84.84, 89.01, 80.05, 82.32, 81.44, 89.74, 79.14, 86.96\n)\nval japanLifeExpectancy = listOf(\n    82.72, 83.77, 83.78, 78.10, 84.92, 80.83, 80.85, 80.02, 84.13, 82.95, 83.10,\n    84.34, 83.39, 79.09, 82.43, 86.71, 81.56, 80.90, 86.52, 80.25, 81.95, 82.91, 78.74, 82.05, 80.53, 84.14,\n    82.10, 81.56, 81.85, 87.35, 80.59, 83.85, 80.55, 85.67, 85.42, 83.47, 85.73, 80.95, 81.38, 82.91, 85.21,\n    87.31, 83.02, 78.46, 78.69, 82.79, 88.07, 81.24, 72.21, 89.26\n)\nval ukLifeExpectancy = listOf(\n    76.66, 82.38, 75.41, 77.95, 82.04, 81.03, 79.85, 75.26, 81.20, 81.83, 78.43,\n    83.02, 79.70, 80.96, 81.24, 80.68, 75.77, 81.59, 77.71, 75.22, 82.07, 82.25, 79.45, 80.73, 79.35, 80.89,\n    85.13, 78.91, 79.96, 82.28, 84.67, 77.76, 79.54, 85.25, 80.17, 80.98, 78.61, 78.73, 80.07, 77.14, 80.86,\n    81.71, 78.17, 79.85, 73.72, 75.23, 77.12, 80.75, 79.22, 83.58\n)\nval usaLifeExpectancy = listOf(\n    71.47, 86.29, 77.41, 74.60, 73.04, 77.52, 80.27, 76.45, 80.95, 72.47, 74.96,\n    79.30, 79.07, 77.33, 83.71, 77.28, 74.23, 75.89, 81.34, 82.65, 82.96, 82.33, 83.89, 76.20, 77.53, 75.34,\n    75.93, 78.74, 79.43, 74.50, 73.26, 77.73, 74.55, 73.39, 79.32, 74.14, 77.21, 73.90, 75.62, 72.88, 78.65,\n    80.89, 79.75, 73.08, 72.05, 71.45, 73.85, 80.82, 79.43, 80.90\n)\n\nval lifeExpectancyData = dataFrameOf(\n    \"Australia\" to australiaLifeExpectancy,\n    \"Canada\" to canadaLifeExpectancy,\n    \"China\" to chinaLifeExpectancy,\n    \"Germany\" to germanyLifeExpectancy,\n    \"Japan\" to japanLifeExpectancy,\n    \"United Kingdom\" to ukLifeExpectancy,\n    \"United States\" to usaLifeExpectancy\n).gather(*countries).into(\"country\", \"lifeExp\")\n\nlifeExpectancyData.boxplot(\"country\", \"lifeExp\").configure { coordFlip() }\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/countPlot/Count-Plot-Grouped/","title":"Count Plot Grouped","text":"<p> Explore 'Count Plot Grouped' in Kotlin using Kandy, a clear demonstration of grouping in count plots. This example effectively showcases the comparison of multiple data sets side by side within the same category, ideal for comparative analysis across different groups or variables. </p> <p> 'Count Plot Grouped' in Kotlin with Kandy: A powerful tool for visual comparison, this example highlights how to group data sets in count plots for a comprehensive comparative view. </p> <p> Dive into 'Count Plot Grouped' using Kotlin and Kandy, where the concept of grouped count plots is used to juxtapose different data sets within the same categories. </p> <p> <pre><code>val categories = listOf(\n    \"easy\", \"medium\", \"hard\", \"medium\", \"easy\",\n    \"hard\", \"hard\", \"easy\", \"easy\", \"hard\", \"medium\",\n    \"hard\", \"easy\", \"easy\", \"easy\", \"medium\",\n    \"hard\", \"hard\", \"hard\", \"medium\", \"easy\",\n    \"hard\", \"medium\", \"hard\", \"hard\", \"hard\",\n    \"medium\", \"medium\", \"easy\", \"medium\", \"hard\",\n    \"hard\", \"easy\", \"hard\", \"medium\", \"medium\",\n    \"hard\", \"hard\", \"hard\", \"easy\", \"hard\",\n    \"hard\", \"easy\", \"medium\", \"medium\", \"hard\",\n    \"medium\", \"medium\", \"easy\", \"hard\", \"medium\",\n    \"hard\", \"medium\", \"easy\", \"easy\",\n)\n\nval years = listOf(\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\"\n)\n\nval df = dataFrameOf(\n    \"category\" to categories,\n    \"year\" to years\n)\n\ndf.groupBy(\"category\").plot {\n    countPlot(\"year\")\n}\n</code></pre> <p> <pre><code>val categories = listOf(\n    \"easy\", \"medium\", \"hard\", \"medium\", \"easy\",\n    \"hard\", \"hard\", \"easy\", \"easy\", \"hard\", \"medium\",\n    \"hard\", \"easy\", \"easy\", \"easy\", \"medium\",\n    \"hard\", \"hard\", \"hard\", \"medium\", \"easy\",\n    \"hard\", \"medium\", \"hard\", \"hard\", \"hard\",\n    \"medium\", \"medium\", \"easy\", \"medium\", \"hard\",\n    \"hard\", \"easy\", \"hard\", \"medium\", \"medium\",\n    \"hard\", \"hard\", \"hard\", \"easy\", \"hard\",\n    \"hard\", \"easy\", \"medium\", \"medium\", \"hard\",\n    \"medium\", \"medium\", \"easy\", \"hard\", \"medium\",\n    \"hard\", \"medium\", \"easy\", \"easy\",\n)\n\nval years = listOf(\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\", \"2022\",\n    \"2022\", \"2022\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\",\n    \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\", \"2023\"\n)\n\nval dataset = mapOf(\n    \"category\" to categories,\n    \"year\" to years\n)\n\ndataset.plot {\n    groupBy(\"category\") {\n        countPlot(\"year\")\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/countPlot/Count-Plot-Horizontal/","title":"Count Plot Horizontal","text":"<p> Explore 'Count Plot Horizontal' in Kotlin using Kandy, showcasing building count plot with horizontal orientation. This example is ideal for learning how to build a count plot using horizontal bars. </p> <p> 'Count Plot Horizontal' in Kotlin with Kandy: A detailed demonstration of the building a custom count plot with horizontal orientation. </p> <p> Explore the 'Count Plot Horizontal' example using Kotlin and Kandy with custom count plot building for horizontal orientation. </p> <p> <pre><code>val transportsDF = dataFrameOf(\n    \"transports\" to listOf(\n        \"metro\", \"bicycle\", \"car\", \"bus\", \"bus\", \"bicycle\", \"bicycle\",\n        \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bicycle\", \"bicycle\",\n        \"bus\", \"bicycle\", \"bus\", \"car\", \"metro\", \"bus\", \"metro\", \"metro\",\n        \"bus\", \"bus\", \"bus\", \"metro\", \"bicycle\", \"metro\", \"bus\", \"metro\",\n        \"bicycle\", \"metro\", \"bicycle\", \"bicycle\", \"bus\", \"bicycle\", \"metro\",\n        \"bicycle\", \"metro\", \"bicycle\", \"bus\", \"bicycle\", \"bus\", \"bicycle\",\n        \"bicycle\", \"bicycle\", \"bus\", \"bicycle\", \"metro\", \"bus\", \"bicycle\",\n        \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"metro\", \"metro\", \"bicycle\",\n        \"metro\", \"bus\", \"bus\", \"metro\", \"metro\", \"bicycle\", \"bus\", \"metro\",\n        \"metro\", \"bicycle\", \"bus\", \"bus\", \"bicycle\", \"car\", \"bus\", \"bicycle\",\n        \"bus\", \"metro\", \"bus\", \"metro\", \"bicycle\", \"metro\", \"bicycle\", \"bicycle\"\n    )\n)\n\ntransportsDF.plot {\n    statCount(\"transports\") {\n        val transport = Stat.x named \"transport\"\n        barsH {\n            x(Stat.count)\n            y(transport)\n            fillColor(transport) {\n                scale = categorical(\n                    \"bus\" to Color.hex(\"#FFD700\"),\n                    \"car\" to Color.hex(\"#FF6347\"),\n                    \"bicycle\" to Color.hex(\"#32CD32\"),\n                    \"metro\" to Color.hex(\"#4169E1\")\n                )\n                legend.type = LegendType.None\n            }\n        }\n    }\n    layout.title = \"Distribution of transport used by students\"\n}\n</code></pre> <p> <pre><code>val transports = listOf(\n    \"metro\", \"bicycle\", \"car\", \"bus\", \"bus\", \"bicycle\", \"bicycle\",\n    \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bicycle\", \"bicycle\",\n    \"bus\", \"bicycle\", \"bus\", \"car\", \"metro\", \"bus\", \"metro\", \"metro\",\n    \"bus\", \"bus\", \"bus\", \"metro\", \"bicycle\", \"metro\", \"bus\", \"metro\",\n    \"bicycle\", \"metro\", \"bicycle\", \"bicycle\", \"bus\", \"bicycle\", \"metro\",\n    \"bicycle\", \"metro\", \"bicycle\", \"bus\", \"bicycle\", \"bus\", \"bicycle\",\n    \"bicycle\", \"bicycle\", \"bus\", \"bicycle\", \"metro\", \"bus\", \"bicycle\",\n    \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"bus\", \"metro\", \"metro\", \"bicycle\",\n    \"metro\", \"bus\", \"bus\", \"metro\", \"metro\", \"bicycle\", \"bus\", \"metro\",\n    \"metro\", \"bicycle\", \"bus\", \"bus\", \"bicycle\", \"car\", \"bus\", \"bicycle\",\n    \"bus\", \"metro\", \"bus\", \"metro\", \"bicycle\", \"metro\", \"bicycle\", \"bicycle\"\n)\n\nplot {\n    statCount(transports) {\n        val transport = Stat.x named \"transport\"\n        barsH {\n            x(Stat.count)\n            y(transport)\n            fillColor(transport) {\n                scale = categorical(\n                    \"bus\" to Color.hex(\"#FFD700\"),\n                    \"car\" to Color.hex(\"#FF6347\"),\n                    \"bicycle\" to Color.hex(\"#32CD32\"),\n                    \"metro\" to Color.hex(\"#4169E1\")\n                )\n                legend.type = LegendType.None\n            }\n        }\n    }\n    layout.title = \"Distribution of transport used by students\"\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/countPlot/Count-Plot-Settings/","title":"Count Plot Settings","text":"<p> Explore 'Count Plot Settings' in Kotlin using Kandy, showcasing various customizations and settings for count plots. This example is ideal for learning how to tweak count plot appearances for more engaging and informative visualizations. </p> <p> 'Count Plot Settings' in Kotlin with Kandy: A detailed demonstration of the versatility in count plot customization, perfect for tailoring visual representations to specific data storytelling needs. </p> <p> Explore the 'Count Plot Settings' example using Kotlin and Kandy to understand the depth of customization available in count plot, from color adjustments to layout tweaks. </p> <p> <pre><code>val classesDF = dataFrameOf(\n    \"classes\" to listOf(\n        \"First\", \"Second\", \"Third\", \"Third\", \"Second\",\n        \"Third\", \"First\", \"Second\", \"Third\", \"First\",\n        \"Third\", \"Second\", \"Third\", \"First\", \"Second\",\n        \"Third\", \"First\", \"Third\", \"Second\", \"Third\",\n        \"First\", \"Second\", \"Third\", \"First\", \"Third\",\n        \"Second\", \"Third\", \"First\", \"Second\", \"Third\",\n        \"First\", \"Third\", \"Second\", \"Third\", \"First\",\n        \"Second\", \"Third\", \"First\", \"Second\", \"Third\"\n    )\n)\n\n\nclassesDF.plot {\n    countPlot(\"classes\") {\n        alpha = 0.8\n        fillColor(Stat.x) {\n            legend.type = LegendType.None\n        }\n        x.axis.name = \"class\"\n    }\n}\n</code></pre> <p> <pre><code>val classes = listOf(\n    \"First\", \"Second\", \"Third\", \"Third\", \"Second\",\n    \"Third\", \"First\", \"Second\", \"Third\", \"First\",\n    \"Third\", \"Second\", \"Third\", \"First\", \"Second\",\n    \"Third\", \"First\", \"Third\", \"Second\", \"Third\",\n    \"First\", \"Second\", \"Third\", \"First\", \"Third\",\n    \"Second\", \"Third\", \"First\", \"Second\", \"Third\",\n    \"First\", \"Third\", \"Second\", \"Third\", \"First\",\n    \"Second\", \"Third\", \"First\", \"Second\", \"Third\"\n)\n\n\nplot {\n    countPlot(classes) {\n        alpha = 0.8\n        fillColor(Stat.x) {\n            legend.type = LegendType.None\n        }\n        x.axis.name = \"class\"\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/countPlot/Count-Plot-Simple/","title":"Count Plot Simple","text":"<p> Explore 'Count Plot Simple' in Kotlin using Kandy to understand the distribution of a discrete variable. This example demonstrates the effective use of count plots in visualizing the frequency of categorical data points. </p> <p> 'Count Plot Simple' in Kotlin with Kandy: A clear and straightforward representation of a discrete variable distribution, perfect for statistical analysis and understanding data trends. </p> <p> Dive into 'Count Plot Simple' using Kotlin and Kandy, a fundamental tool in data analysis for visualizing the distribution and frequency of categorical dataset values.\" </p> <p> <pre><code>val dataframe = dataFrameOf(\n    \"categories\" to listOf(\n        \"A\", \"B\", \"C\", \"C\", \"B\",\n        \"A\", \"C\", \"B\", \"A\", \"B\",\n        \"C\", \"A\", \"B\", \"A\", \"A\",\n        \"C\", \"A\", \"A\", \"B\", \"C\",\n        \"C\", \"A\", \"A\", \"C\", \"B\",\n        \"C\", \"C\", \"A\", \"A\", \"A\",\n        \"B\", \"C\", \"B\", \"A\", \"B\",\n        \"C\", \"A\", \"A\", \"B\", \"A\",\n        \"C\", \"A\", \"C\", \"A\", \"C\"\n    )\n)\n\ndataframe.plot {\n    countPlot(\"categories\")\n}\n</code></pre> <p> <pre><code>val categories = listOf(\n    \"A\", \"B\", \"C\", \"C\", \"B\",\n    \"A\", \"C\", \"B\", \"A\", \"B\",\n    \"C\", \"A\", \"B\", \"A\", \"A\",\n    \"C\", \"A\", \"A\", \"B\", \"C\",\n    \"C\", \"A\", \"A\", \"C\", \"B\",\n    \"C\", \"C\", \"A\", \"A\", \"A\",\n    \"B\", \"C\", \"B\", \"A\", \"B\",\n    \"C\", \"A\", \"A\", \"B\", \"A\",\n    \"C\", \"A\", \"C\", \"A\", \"C\"\n)\n\nplot {\n    countPlot(categories)\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/densityPlot/Density-Plot-Grouped/","title":"Density Plot Grouped","text":"<p> Explore 'Density Plot Grouped' in Kotlin using Kandy, a clear demonstration of grouping in density plots. This example effectively showcases the comparison of multiple data sets side by side within the same category, ideal for comparative analysis across different groups or variables. </p> <p> 'Density Plot Grouped' in Kotlin with Kandy: A powerful tool for visual comparison, this example highlights how to group data sets in density plots for a comprehensive comparative view. </p> <p> Dive into 'Density Plot Grouped' using Kotlin and Kandy, where the concept of grouped density plots is used to juxtapose different data sets within the same categories. </p> <p> <pre><code>val macaqueWeights = listOf(\n    1.563, 2.173, 2.118, 2.722, 2.384, 1.789, 2.649,\n    1.299, 1.566, 1.821, 2.151, 1.554, 1.464, 1.611,\n    2.178, 2.652, 2.031, 2.265, 1.919, 1.283, 2.365,\n    2.540, 2.779, 2.040, 2.138, 1.783, 1.442, 1.413,\n    2.224, 2.345, 1.753, 2.284, 2.465, 1.430, 2.617,\n    1.667, 2.462, 1.777, 2.104, 2.404, 1.276, 1.489,\n    2.662, 1.853, 2.315, 1.589, 1.586, 2.569, 1.888,\n    1.414, 1.623, 2.084, 2.484, 2.348, 1.496, 2.238,\n    1.778, 2.173, 2.411, 2.540, 2.325, 1.324, 2.252,\n    1.978, 2.075, 2.585, 2.414, 2.162, 1.584, 2.399,\n    1.757, 2.109, 1.436, 2.628, 2.370, 1.679, 1.970,\n    2.360, 2.005, 2.179, 2.177, 1.941, 2.282, 2.067,\n    2.288, 1.481, 1.638, 2.164, 2.485, 1.797, 2.369,\n    1.690, 2.143, 1.743, 2.357, 2.280, 1.824, 1.678,\n    2.531, 1.958, 1.466, 1.877, 2.005\n)\nval chimpanzeeWeights = listOf(\n    4.530, 4.257, 4.381, 4.935, 3.392, 4.611, 2.499, 4.306,\n    4.119, 3.622, 4.099, 4.832, 2.456, 3.411, 4.426, 2.940,\n    4.529, 3.635, 2.991, 4.372, 2.319, 4.358, 1.882, 3.472,\n    4.828, 4.005, 3.452, 3.854, 3.455, 2.996, 4.031, 4.382,\n    2.947, 4.752, 2.466, 4.558, 2.548, 3.172, 3.010, 3.472,\n    5.258, 2.746, 4.022, 3.013, 4.942, 3.206, 3.779, 4.367,\n    3.853, 2.483, 3.957, 2.943, 4.791, 3.432, 3.530, 2.576,\n    2.833, 4.650, 5.515, 4.413, 2.699, 3.310, 5.047, 3.047,\n    4.095, 4.712, 2.600, 3.523, 3.106, 4.110, 2.894, 3.373,\n    2.656, 3.684, 5.171, 4.049, 4.773, 3.456, 4.420, 2.090,\n    3.155, 4.678, 3.240,\n)\n\nval df = dataFrameOf(\n    \"weight\" to macaqueWeights + chimpanzeeWeights,\n    \"group\" to macaqueWeights.map { \"macaque\" } + chimpanzeeWeights.map { \"chimpanzee\" }\n)\n\ndf.groupBy(\"group\").plot {\n    densityPlot(\"weight\") {\n        alpha = 0.5\n    }\n}\n</code></pre> <p> <pre><code>val macaqueWeights = listOf(\n    1.563, 2.173, 2.118, 2.722, 2.384, 1.789, 2.649,\n    1.299, 1.566, 1.821, 2.151, 1.554, 1.464, 1.611,\n    2.178, 2.652, 2.031, 2.265, 1.919, 1.283, 2.365,\n    2.540, 2.779, 2.040, 2.138, 1.783, 1.442, 1.413,\n    2.224, 2.345, 1.753, 2.284, 2.465, 1.430, 2.617,\n    1.667, 2.462, 1.777, 2.104, 2.404, 1.276, 1.489,\n    2.662, 1.853, 2.315, 1.589, 1.586, 2.569, 1.888,\n    1.414, 1.623, 2.084, 2.484, 2.348, 1.496, 2.238,\n    1.778, 2.173, 2.411, 2.540, 2.325, 1.324, 2.252,\n    1.978, 2.075, 2.585, 2.414, 2.162, 1.584, 2.399,\n    1.757, 2.109, 1.436, 2.628, 2.370, 1.679, 1.970,\n    2.360, 2.005, 2.179, 2.177, 1.941, 2.282, 2.067,\n    2.288, 1.481, 1.638, 2.164, 2.485, 1.797, 2.369,\n    1.690, 2.143, 1.743, 2.357, 2.280, 1.824, 1.678,\n    2.531, 1.958, 1.466, 1.877, 2.005\n)\nval chimpanzeeWeights = listOf(\n    4.530, 4.257, 4.381, 4.935, 3.392, 4.611, 2.499, 4.306,\n    4.119, 3.622, 4.099, 4.832, 2.456, 3.411, 4.426, 2.940,\n    4.529, 3.635, 2.991, 4.372, 2.319, 4.358, 1.882, 3.472,\n    4.828, 4.005, 3.452, 3.854, 3.455, 2.996, 4.031, 4.382,\n    2.947, 4.752, 2.466, 4.558, 2.548, 3.172, 3.010, 3.472,\n    5.258, 2.746, 4.022, 3.013, 4.942, 3.206, 3.779, 4.367,\n    3.853, 2.483, 3.957, 2.943, 4.791, 3.432, 3.530, 2.576,\n    2.833, 4.650, 5.515, 4.413, 2.699, 3.310, 5.047, 3.047,\n    4.095, 4.712, 2.600, 3.523, 3.106, 4.110, 2.894, 3.373,\n    2.656, 3.684, 5.171, 4.049, 4.773, 3.456, 4.420, 2.090,\n    3.155, 4.678, 3.240,\n)\n\nval df = dataFrameOf(\n    \"weight\" to macaqueWeights + chimpanzeeWeights,\n    \"group\" to macaqueWeights.map { \"macaque\" } + chimpanzeeWeights.map { \"chimpanzee\" }\n)\n\ndf.groupBy(\"group\").plot {\n    densityPlot(\"weight\") {\n        alpha = 0.5\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/densityPlot/Density-Plot-Settings/","title":"Density Plot Settings","text":"<p> Explore 'Density Plot Settings' in Kotlin using Kandy, showcasing various customizations and settings for density plots. This example is ideal for learning how to tweak density plot appearances for more engaging and informative visualizations. </p> <p> 'Density Plot Settings' in Kotlin with Kandy: A detailed demonstration of the versatility in density plot customization, perfect for tailoring visual representations to specific data storytelling needs. </p> <p> Explore the 'Density Plot Settings' example using Kotlin and Kandy to understand the depth of customization available in density plot, from color adjustments to layout tweaks. </p> <p> <pre><code>val experimentalData = dataFrameOf(\n    \"length\" to listOf(\n        5.92, 6.44, 5.87, 4.99, 5.23,\n        5.67, 4.89, 5.34, 5.78, 5.12,\n        5.56, 5.23, 5.78, 6.01, 5.56,\n        5.67, 5.89, 5.45, 6.12, 5.78,\n        6.34, 5.67, 6.45, 5.34, 5.89,\n        6.01, 5.78, 5.23, 5.67, 6.12,\n        6.23, 5.45, 5.56, 5.67, 5.78,\n        5.56, 6.23, 5.78, 6.34, 6.12,\n        5.89, 6.45, 5.78, 6.34, 5.67,\n        6.56, 5.45, 5.78, 5.89, 6.12,\n        4.67, 4.79, 5.14, 5.28, 5.22,\n    )\n)\n\nexperimentalData.plot {\n    densityPlot(\"length\", adjust = 0.8) {\n        alpha = 0.5\n        fillColor = Color.RED\n        borderLine {\n            color = Color.GREEN\n            width = 0.5\n        }\n        x.axis.name = \"length\"\n    }\n    layout.title = \"Flight length experiment\"\n}\n</code></pre> <p> <pre><code>val experimentalData = listOf(\n    5.92, 6.44, 5.87, 4.99, 5.23,\n    5.67, 4.89, 5.34, 5.78, 5.12,\n    5.56, 5.23, 5.78, 6.01, 5.56,\n    5.67, 5.89, 5.45, 6.12, 5.78,\n    6.34, 5.67, 6.45, 5.34, 5.89,\n    6.01, 5.78, 5.23, 5.67, 6.12,\n    6.23, 5.45, 5.56, 5.67, 5.78,\n    5.56, 6.23, 5.78, 6.34, 6.12,\n    5.89, 6.45, 5.78, 6.34, 5.67,\n    6.56, 5.45, 5.78, 5.89, 6.12,\n    4.67, 4.79, 5.14, 5.28, 5.22,\n)\n\nplot {\n    densityPlot(experimentalData, adjust = 0.8) {\n        alpha = 0.5\n        fillColor = Color.RED\n        borderLine {\n            color = Color.GREEN\n            width = 0.5\n        }\n        x.axis.name = \"length\"\n    }\n    layout.title = \"Flight length experiment\"\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/densityPlot/Density-Plot-Simple/","title":"Density Plot Simple","text":"<p> Explore 'Density Plot Simple' in Kotlin using Kandy to understand the distribution of a dataset. This example demonstrates the effective use of density plots in continuous visualizing the frequency of data points. </p> <p> 'Density Plot Simple' in Kotlin with Kandy: A clear and straightforward representation of data distribution, perfect for statistical analysis and understanding data trends. </p> <p> Dive into 'Density Plot Simple' using Kotlin and Kandy, a fundamental tool in data analysis for visualizing the distribution and frequency of continuous dataset values.\" </p> <p> <pre><code>val random = java.util.Random(42)\n\nval dataframe = dataFrameOf(\n    \"sample\" to List(1000) { random.nextGaussian() }\n)\n\ndataframe.plot {\n    densityPlot(\"sample\")\n}\n</code></pre> <p> <pre><code>val random = java.util.Random(42)\n\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    densityPlot(sample)\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/densityPlot/Density-Plot-With-Histogram/","title":"Density Plot With Histogram","text":"<p> Explore 'Density Plot With Histogram' in Kotlin using Kandy, where density plot is enhanced with histogram. This example effectively showcases the usage of several statistical plots together, useful when you want to visualise distribution in several ways on one plot. </p> <p> 'Density Plot With Histogram' in Kotlin with Kandy: A powerful tool for visualising a distribution in several ways. </p> <p> Dive into 'Density Plot With Histogram' using Kotlin and Kandy, showing multiple statistical plots. </p> <pre><code>val df = DataFrame.readCSV(\n    fileOrUrl = \"https://raw.githubusercontent.com/Kotlin/dataframe/master/examples/idea-examples/titanic/src/main/resources/titanic.csv\",\n    delimiter = ';', parserOptions = ParserOptions(locale = java.util.Locale.FRENCH)\n)\nval ages = df[\"age\"].dropNulls().cast&lt;Double&gt;()\n\nplot {\n    histogram(ages) {\n        alpha = 0.9\n        fillColor = Color.WHITE\n        y(Stat.density)\n    }\n    densityPlot(ages) {\n        alpha = 0.5\n        fillColor = Color.hex(0xFF6666)\n    }\n    layout.title = \"Titanic passengers age distribution\"\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/BorderLine-ErrorBars/","title":"BorderLine in ErrorBars","text":"<p> Explore the 'BorderLine in ErrorBars' example in Kandy to see how borderlines can enhance error bar visualization. This example provides a clear view of data uncertainty with defined borders. </p> <p> 'BorderLine in ErrorBars': A clear approach to highlighting error margins in Kandy's data plots. </p> <p> Experience enhanced error bar clarity with 'BorderLine in ErrorBars' in Kandy, focusing on defined border lines for better data understanding. </p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\nval mid = costMin.zip(costMax).map { (it.first + it.second) / 2.0 }\n\nplot {\n    errorBars {\n        x(years)\n        yMin(costMin)\n        yMax(costMax)\n        borderLine {\n            color(mid) {\n                scale = continuous(Color.BLACK..Color.GREEN)\n            }\n            width = 1.8\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/ErrorBars-Settings/","title":"ErrorBars Settings","text":"<p> Dive into the 'ErrorBars Settings' example in Kandy to primarily customizing error bars. This Kotlin tutorial showcases advanced techniques for tailoring error bars to fit specific data visualization needs. </p> <p> Advanced Error Bars: Learn to customize error bars in Kandy for detailed data analysis. </p> <p> Get hands-on with 'ErrorBars Settings' for advanced error bar customization in Kandy, perfect for detailed data analysis. </p> <p> <pre><code>val years by columnOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin by columnOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax by columnOf(68.9, 71.3, 78.9, 76.5, 72.1)\nval dataset = dataFrameOf(years, costMin, costMax)\n\ndataset.plot {\n    errorBars {\n        x(years)\n        yMin(costMin)\n        yMax(costMax)\n        width = 1.1\n        borderLine {\n            width = 1.5\n            color = Color.RED\n        }\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\n\nplot {\n    errorBars {\n        x(years)\n        yMin(costMin)\n        yMax(costMax)\n        width = 1.1\n        borderLine {\n            width = 1.5\n            color = Color.RED\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/ErrorBars-with-Boxplot/","title":"ErrorBars with Boxplot","text":"<p> Discover the combined power of error bars and boxplot in 'ErrorBars with Boxplot' using Kandy. This example skillfully merges two data visualization techniques to provide a comprehensive view of data spread and variability. </p> <p> Combining Clarity: 'ErrorBars with Boxplot' in Kandy showcases enhanced data interpretation by merging error bars with boxplot. </p> <p> Explore the 'ErrorBars with Boxplot' in Kandy for a dual approach to data visualization, blending error bars with the descriptive statistics of boxplot. </p> <pre><code>val random = java.util.Random(42)\n\nval valuesA = List(100) { 3.0 + random.nextGaussian() * 0.5 }\nval valuesB = List(100) { 1.5 + random.nextDouble() * 4.5 }\nval valuesC = valuesA.zip(valuesB).map { (it.first + it.second) / 2.0 }\n\n\nval df = dataFrameOf(\n    \"value\" to valuesA + valuesB + valuesC,\n    \"group\" to List(100) { \"a\" } + List(100) { \"b\" } + List(100) { \"c\" }\n)\n\ndf.plot {\n    statBoxplot(\"group\", \"value\") {\n        errorBars {\n            x(Stat.x)\n            yMin(Stat.min)\n            yMax(Stat.max)\n            borderLine.color(Stat.x)\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/ErrorBars-with-Line/","title":"ErrorBars with Line","text":"<p> Discover how to combine error bars with line charts in the 'ErrorBars with Line' example. This tutorial in Kandy illustrates an effective way to show data trends alongside their variability. </p> <p> 'ErrorBars with Line': A Kandy guide to integrating error bars with line plots for enhanced data interpretation. </p> <p> Explore 'ErrorBars with Line' for a comprehensive understanding of merging error bars with line plots in Kandy. </p> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\nval mid = costMin.zip(costMax).map { (it.first + it.second) / 2.0 }\nval dataset = dataFrameOf(\n    years.toColumn(\"years\"),\n    costMin.toColumn(\"min\"),\n    mid.toColumn(\"mid\"),\n    costMax.toColumn(\"max\")\n)\n\ndataset.plot {\n    x(\"years\")\n    y(\"mid\")\n    line {\n        color = Color.BLUE\n    }\n    errorBars {\n        yMin(\"min\")\n        yMax(\"max\")\n        borderLine.type = LineType.LONGDASH\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\nval mid = costMin.zip(costMax).map { (it.first + it.second) / 2.0 }\n\nplot {\n    x(years)\n    y(mid)\n    line {\n        color = Color.BLUE\n    }\n    errorBars {\n        yMin(costMin)\n        yMax(costMax)\n        borderLine.type = LineType.LONGDASH\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/Fixed-ErrorBars/","title":"Fixed ErrorBars Coordinate","text":"<p> Learn to anchor error bars at specific coordinates with 'Fixed ErrorBars Coordinate' in Kandy. This example demonstrates precise error bar placement for targeted data analysis. </p> <p> Discover precise error visualization with 'Fixed ErrorBars Coordinate' in Kandy, showcasing accurate error bar positioning on data plots. </p> <p> Explore precision in error visualization with 'Fixed ErrorBars Coordinate' in Kandy, showcasing fixed coordinate error bars. </p> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\nval dataset = dataFrameOf(years.toColumn(\"years\"), costMin.toColumn(\"min\"), costMax.toColumn(\"max\"))\n\nplot(dataset) {\n    errorBars {\n        x(\"years\")\n        yMin.constant(20.0)\n        yMax(\"max\")\n        width = 0.5\n        borderLine.width = 1.3\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\n\nplot {\n    errorBars {\n        x(years)\n        yMin.constant(20.0)\n        yMax(costMax)\n        width = 0.5\n        borderLine.width = 1.3\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/Grouped-ErrorBars/","title":"Grouped ErrorBars","text":"<p> Explore how 'Grouped ErrorBars' in Kandy can effectively represent variability across different groups. This example demonstrates the use of error bars to compare data across multiple categories. </p> <p> 'Grouped ErrorBars': Illustrating comparative data uncertainty across categories in Kandy. </p> <p> See how 'Grouped ErrorBars' in Kandy enhance comparative data analysis across multiple groups, providing a clear visualization of variability. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"time\" to (1..5).toList() + (1..5).toList(),\n    \"min\" to listOf(2.0, 3.4, 3.5, 5.5, 2.5) + listOf(1.0, 2.0, 3.0, 4.0, 3.7),\n    \"max\" to listOf(3.0, 5.2, 5.0, 5.8, 3.4) + listOf(5.0, 4.0, 3.5, 5.0, 4.2),\n    \"category\" to List(5) { \"a\" } + List(5) { \"b\" }\n)\n\ndataset.groupBy(\"category\").plot {\n    errorBars {\n        x(\"time\") {\n            axis.breaks((1..5).toList(), format = \"d\")\n        }\n        yMin(\"min\")\n        yMax(\"max\")\n        borderLine.color(\"category\")\n    }\n}\n</code></pre> <p> <pre><code>val dataset = mapOf(\n    \"time\" to (1..5).toList() + (1..5).toList(),\n    \"min\" to listOf(2.0, 3.4, 3.5, 5.5, 2.5) + listOf(1.0, 2.0, 3.0, 4.0, 3.7),\n    \"max\" to listOf(3.0, 5.2, 5.0, 5.8, 3.4) + listOf(5.0, 4.0, 3.5, 5.0, 4.2),\n    \"category\" to List(5) { \"a\" } + List(5) { \"b\" }\n)\n\ndataset.plot {\n    groupBy(\"category\") {\n        errorBars {\n            x(\"time\") {\n                axis.breaks((1..5).toList(), format = \"d\")\n            }\n            yMin(\"min\")\n            yMax(\"max\")\n            borderLine.color(\"category\")\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/errorBars/Simple-ErrorBars/","title":"Simple ErrorBars","text":"<p> Learn to depict data uncertainty with Simple ErrorBars in Kandy. This Kotlin example demonstrates how to add error bars for a clear understanding of data variability. </p> <p> Simple ErrorBars in Kandy: A quick guide on visualizing error margins in your data plots. </p> <p> See Simple ErrorBars in action: A concise example of error visualization in Kandy on GitHub and Datalore. </p> <p> <pre><code>val years by columnOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin by columnOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax by columnOf(68.9, 71.3, 78.9, 76.5, 72.1)\n\nplot {\n    errorBars {\n        x(years)\n        yMin(costMin)\n        yMax(costMax)\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval costMin = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval costMax = listOf(68.9, 71.3, 78.9, 76.5, 72.1)\n\nplot {\n    errorBars {\n        x(years)\n        yMin(costMin)\n        yMax(costMax)\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/heatmap/Heatmap-Settings/","title":"Heatmap Settings","text":"<p> Explore 'Heatmap Settings' in Kotlin using Kandy, showcasing various customizations and settings for heatmap plots. This example is ideal for learning how to tweak heatmap plot appearances for more engaging and informative visualizations. </p> <p> 'Heatmap Settings' in Kotlin with Kandy: A detailed demonstration of the versatility in heatmap plot customization, perfect for tailoring visual representations to specific data storytelling needs. </p> <p> Explore the 'Heatmap Settings' example using Kotlin and Kandy to understand the depth of customization available in heatmap plotting, from color adjustments to layout tweaks. </p> <pre><code>val df = DataFrame.readCSV(\n    fileOrUrl = \"https://raw.githubusercontent.com/Kotlin/dataframe/master/examples/idea-examples/titanic/src/main/resources/titanic.csv\",\n    delimiter = ';', parserOptions = ParserOptions(locale = java.util.Locale.FRENCH)\n)\n\ndf.plot {\n    heatmap(\"embarked\", \"pclass\") {\n        borderLine {\n            width = 0.8\n            color = Color.BLACK\n        }\n        fillColor(Stat.count) {\n            scale = continuous(Color.WHITE..Color.RED)\n            legend.name = \"number of\\n passangers\"\n        }\n    }\n    y.axis.breaks(df[\"pclass\"].distinct().toList(), format = \"d\")\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/heatmap/Heatmap-Simple/","title":"Heatmap Simple","text":"<p> Explore 'Heatmap Simple' in Kotlin using Kandy to understand the distribution of a dataset with two discrete variables. This example demonstrates the effective use of heatmaps in visualizing the frequency of data points with two categorical variables. </p> <p> 'Heatmap Simple' in Kotlin with Kandy: A clear and straightforward representation of two variables data distribution, perfect for statistical analysis and understanding data trends. </p> <p> Dive into 'Heatmap Simple' using Kotlin and Kandy, a fundamental tool in data analysis for visualizing the distribution and frequency of two variables dataset values.\" </p> <p> <pre><code>val dataframe = dataFrameOf(\n    \"days\" to listOf(\n        \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Sun\",\n        \"Sat\", \"Thu\", \"Fri\", \"Tue\", \"Wed\", \"Sun\", \"Mon\", \"Thu\",\n        \"Sun\", \"Sat\", \"Tue\", \"Mon\", \"Thu\", \"Wed\", \"Fri\", \"Sat\",\n        \"Tue\", \"Sun\", \"Fri\", \"Sat\", \"Thu\", \"Mon\", \"Wed\", \"Tue\",\n        \"Thu\", \"Mon\", \"Sun\", \"Fri\", \"Wed\", \"Sat\", \"Tue\", \"Thu\",\n        \"Sat\", \"Tue\", \"Sun\", \"Mon\", \"Wed\", \"Fri\", \"Thu\", \"Sat\",\n        \"Thu\", \"Fri\", \"Sun\", \"Tue\", \"Sat\", \"Wed\", \"Mon\", \"Thu\",\n        \"Wed\", \"Tue\", \"Sat\", \"Fri\", \"Sun\", \"Thu\", \"Mon\", \"Tue\",\n        \"Fri\", \"Thu\", \"Wed\", \"Sun\", \"Sat\", \"Mon\", \"Tue\", \"Thu\",\n        \"Tue\", \"Wed\", \"Sun\", \"Mon\", \"Thu\", \"Sat\", \"Fri\", \"Tue\",\n        \"Thu\", \"Sun\", \"Fri\", \"Sat\", \"Mon\", \"Wed\", \"Tue\", \"Thu\",\n        \"Sat\", \"Mon\", \"Tue\", \"Thu\", \"Fri\", \"Sun\", \"Wed\", \"Sat\",\n        \"Sun\", \"Fri\", \"Tue\", \"Thu\", \"Sat\", \"Mon\", \"Wed\", \"Sun\",\n        \"Mon\", \"Wed\", \"Sat\", \"Fri\", \"Thu\", \"Tue\", \"Sun\", \"Sat\",\n    ),\n    \"drinks\" to listOf(\n        \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"tea\", \"coffee\", \"soda\",\n        \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"tea\",\n        \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\",\n        \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\",\n        \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\",\n        \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\",\n        \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\", \"coffee\",\n        \"soda\", \"coffee\", \"tea\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\",\n        \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"soda\",\n        \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"coffee\",\n        \"tea\", \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\",\n        \"coffee\", \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\",\n        \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\",\n        \"coffee\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\"\n    )\n)\n\ndataframe.plot {\n    heatmap(\"days\", \"drinks\")\n}\n</code></pre> <p> <pre><code>val days = listOf(\n    \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Sun\",\n    \"Sat\", \"Thu\", \"Fri\", \"Tue\", \"Wed\", \"Sun\", \"Mon\", \"Thu\",\n    \"Sun\", \"Sat\", \"Tue\", \"Mon\", \"Thu\", \"Wed\", \"Fri\", \"Sat\",\n    \"Tue\", \"Sun\", \"Fri\", \"Sat\", \"Thu\", \"Mon\", \"Wed\", \"Tue\",\n    \"Thu\", \"Mon\", \"Sun\", \"Fri\", \"Wed\", \"Sat\", \"Tue\", \"Thu\",\n    \"Sat\", \"Tue\", \"Sun\", \"Mon\", \"Wed\", \"Fri\", \"Thu\", \"Sat\",\n    \"Thu\", \"Fri\", \"Sun\", \"Tue\", \"Sat\", \"Wed\", \"Mon\", \"Thu\",\n    \"Wed\", \"Tue\", \"Sat\", \"Fri\", \"Sun\", \"Thu\", \"Mon\", \"Tue\",\n    \"Fri\", \"Thu\", \"Wed\", \"Sun\", \"Sat\", \"Mon\", \"Tue\", \"Thu\",\n    \"Tue\", \"Wed\", \"Sun\", \"Mon\", \"Thu\", \"Sat\", \"Fri\", \"Tue\",\n    \"Thu\", \"Sun\", \"Fri\", \"Sat\", \"Mon\", \"Wed\", \"Tue\", \"Thu\",\n    \"Sat\", \"Mon\", \"Tue\", \"Thu\", \"Fri\", \"Sun\", \"Wed\", \"Sat\",\n    \"Sun\", \"Fri\", \"Tue\", \"Thu\", \"Sat\", \"Mon\", \"Wed\", \"Sun\",\n    \"Mon\", \"Wed\", \"Sat\", \"Fri\", \"Thu\", \"Tue\", \"Sun\", \"Sat\",\n)\nval drinks = listOf(\n    \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"tea\", \"coffee\", \"soda\",\n    \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"tea\",\n    \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\",\n    \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\",\n    \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\",\n    \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\",\n    \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\", \"coffee\",\n    \"soda\", \"coffee\", \"tea\", \"soda\", \"tea\", \"soda\", \"coffee\", \"tea\",\n    \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"soda\",\n    \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"coffee\",\n    \"tea\", \"coffee\", \"soda\", \"tea\", \"soda\", \"coffee\", \"soda\", \"tea\",\n    \"coffee\", \"soda\", \"tea\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\",\n    \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\", \"coffee\", \"soda\", \"tea\",\n    \"coffee\", \"tea\", \"soda\", \"coffee\", \"tea\", \"soda\", \"coffee\", \"soda\"\n)\n\nplot {\n    heatmap(days, drinks)\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/histogram/Histogram-Grouped/","title":"Histogram Grouped","text":"<p> Explore 'Histogram Grouped' in Kotlin using Kandy, a clear demonstration of grouping in histogram charts. This example effectively showcases the comparison of multiple data sets side by side within the same category, ideal for comparative analysis across different groups or variables. </p> <p> 'Histogram Grouped' in Kotlin with Kandy: A powerful tool for visual comparison, this example highlights how to group data sets in histogram charts for a comprehensive comparative view. </p> <p> Dive into 'Histogram Grouped' using Kotlin and Kandy, where the concept of grouped histogram plotting is used to juxtapose different data sets within the same categories. </p> <p> <pre><code>val random = java.util.Random(42)\n\nval sampleA = List(1000) { random.nextGaussian() * 0.7 + 2.0 }\nval sampleB = List(1000) { random.nextGaussian() * 1.4 + 3.5 }\n\nval df = dataFrameOf(\n    \"sample\" to sampleA + sampleB,\n    \"group\" to sampleA.map { \"A\" } + sampleB.map { \"B\" }\n)\n\ndf.groupBy(\"group\").plot {\n    histogram(\"sample\")\n}\n</code></pre> <p> <pre><code>val random = java.util.Random(42)\n\nval sampleA = List(1000) { random.nextGaussian() * 0.7 + 2.0 }\nval sampleB = List(1000) { random.nextGaussian() * 1.4 + 3.5 }\n\nval dataset = mapOf(\n    \"sample\" to sampleA + sampleB,\n    \"group\" to sampleA.map { \"A\" } + sampleB.map { \"B\" }\n)\n\ndataset.plot {\n    groupBy(\"group\") {\n        histogram(\"sample\")\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/histogram/Histogram-Settings/","title":"Histogram Settings","text":"<p> Explore 'Histogram Settings' in Kotlin using Kandy, showcasing various customizations and settings for histogram plots. This example is ideal for learning how to tweak histogram plot appearances for more engaging and informative visualizations. </p> <p> 'Histogram Settings' in Kotlin with Kandy: A detailed demonstration of the versatility in histogram plot customization, perfect for tailoring visual representations to specific data storytelling needs. </p> <p> Explore the 'Histogram Settings' example using Kotlin and Kandy to understand the depth of customization available in histogram plotting, from color adjustments to layout tweaks. </p> <p> <pre><code>val experimentalData = dataFrameOf(\n    \"length\" to listOf(\n        5.92, 6.44, 5.87, 4.99, 5.23,\n        5.67, 4.89, 5.34, 5.78, 5.12,\n        5.56, 5.23, 5.78, 6.01, 5.56,\n        5.67, 5.89, 5.45, 6.12, 5.78,\n        6.34, 5.67, 6.45, 5.34, 5.89,\n        6.01, 5.78, 5.23, 5.67, 6.12,\n        6.23, 5.45, 5.56, 5.67, 5.78,\n        5.56, 6.23, 5.78, 6.34, 6.12,\n        5.89, 6.45, 5.78, 6.34, 5.67,\n        6.56, 5.45, 5.78, 5.89, 6.12,\n        4.67, 4.79, 5.14, 5.28, 5.22,\n    )\n)\nexperimentalData.plot {\n    histogram(\"length\", binsOption = BinsOption.byNumber(12)) {\n        width = 0.8\n        alpha = 0.9\n        fillColor = Color.RED\n        borderLine {\n            color = Color.GREEN\n            width = 0.5\n        }\n        x.axis.name = \"length\"\n    }\n    layout.title = \"Flight length experiment\"\n}\n</code></pre> <p> <pre><code>val experimentalData = listOf(\n    5.92, 6.44, 5.87, 4.99, 5.23,\n    5.67, 4.89, 5.34, 5.78, 5.12,\n    5.56, 5.23, 5.78, 6.01, 5.56,\n    5.67, 5.89, 5.45, 6.12, 5.78,\n    6.34, 5.67, 6.45, 5.34, 5.89,\n    6.01, 5.78, 5.23, 5.67, 6.12,\n    6.23, 5.45, 5.56, 5.67, 5.78,\n    5.56, 6.23, 5.78, 6.34, 6.12,\n    5.89, 6.45, 5.78, 6.34, 5.67,\n    6.56, 5.45, 5.78, 5.89, 6.12,\n    4.67, 4.79, 5.14, 5.28, 5.22,\n)\n\nplot {\n    histogram(experimentalData, binsOption = BinsOption.byNumber(12)) {\n        width = 0.8\n        alpha = 0.9\n        fillColor = Color.RED\n        borderLine {\n            color = Color.GREEN\n            width = 0.5\n        }\n        x.axis.name = \"length\"\n    }\n    layout.title = \"Flight length experiment\"\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/histogram/Histogram-Simple/","title":"Histogram Simple","text":"<p> Explore 'Histogram Simple' in Kotlin using Kandy to understand the distribution of a dataset. This example demonstrates the effective use of histograms in visualizing the frequency of data points. </p> <p> 'Histogram Simple' in Kotlin with Kandy: A clear and straightforward representation of data distribution, perfect for statistical analysis and understanding data trends. </p> <p> Dive into 'Histogram Simple' using Kotlin and Kandy, a fundamental tool in data analysis for visualizing the distribution and frequency of dataset values. </p> <p> <pre><code>val random = java.util.Random(42)\n\nval dataframe = dataFrameOf(\n    \"sample\" to List(1000) { random.nextGaussian() }\n)\n\ndataframe.plot {\n    histogram(\"sample\")\n}\n</code></pre> <p> <pre><code>val random = java.util.Random(42)\n\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    histogram(sample)\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/histogram/Histogram-With-Line/","title":"Histogram With Line","text":"<p> Explore 'Histogram With Line' in Kotlin using Kandy, where histogram is enhanced with line. This example effectively showcases the usage of statistics with several layers, useful when you want to visualise distribution in several ways on one plot. </p> <p> 'Histogram With Line' in Kotlin with Kandy: A powerful tool for visualising a distribution with several layers. </p> <p> Dive into 'Histogram With Line' using Kotlin and Kandy, showing multiple layers with statistical data transformation. </p> <p> <pre><code>val random = java.util.Random(42)\n\nval sampleDf = dataFrameOf(\n    \"sample\" to List(1000) { random.nextGaussian() }\n)\n\nsampleDf.plot {\n    statBin(\"sample\", binsOption = BinsOption.byNumber(15)) {\n        bars {\n            alpha = 0.9\n            x(Stat.x)\n            y(Stat.count)\n        }\n        line {\n            x(Stat.x)\n            y(Stat.count)\n            color = Color.RED\n            width = 1.5\n            type = LineType.LONGDASH\n        }\n    }\n}\n</code></pre> <p> <pre><code>val random = java.util.Random(42)\n\nval sample = List(1000) { random.nextGaussian() }\n\nplot {\n    statBin(sample, binsOption = BinsOption.byNumber(15)) {\n        bars {\n            alpha = 0.9\n            x(Stat.x)\n            y(Stat.count)\n        }\n        line {\n            x(Stat.x)\n            y(Stat.count)\n            color = Color.RED\n            width = 1.5\n            type = LineType.LONGDASH\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/layout/Axis-And-Legend-Configuration/","title":"Axis And Legend Configuration","text":"<p> Explore 'Axis And Legend Configuration' in Kotlin using Kandy to customize plot axes and legends. </p> <p> 'Axis And Legend Configuration' in Kotlin with Kandy: full customization of all guides on the chart. </p> <p> Dive into 'Axis And Legend Configuration' using Kotlin and Kandy, full and detailed customization of plot legends and axes improving its informativeness. </p> <pre><code>val df =\n    DataFrame.readCSV(\"https://raw.githubusercontent.com/JetBrains/lets-plot-kotlin/master/docs/examples/data/mpg.csv\")\n\ndf.plot {\n    points {\n        x(\"displ\") {\n            axis.name = \"engine displacement, liters\"\n        }\n        y(\"hwy\") {\n            axis {\n                name = \"highway mileage, mpg\"\n                breaks(listOf(15, 25, 35, 45), format = \"d\")\n            }\n        }\n        color(\"cty\") {\n            legend {\n                name = \"city mileage\"\n                breaks(format = \"{d} mpg\")\n            }\n        }\n        symbol(\"drv\") {\n            legend {\n                type = LegendType.DiscreteLegend(nRow = 2)\n                name = \"drive type\"\n                breaksLabeled(\"4\" to \"4WD\", \"r\" to \"RWD\", \"f\" to \"FWD\")\n            }\n        }\n        size = 4.0\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/layout/Base-Layout-Settings/","title":"Base Layout Settings","text":"<p> Explore 'Base Layout Settings' in Kotlin using Kandy to perform base plot layout adjustments: plot size and title. </p> <p> 'Base Layout Settings' in Kotlin with Kandy: simple plot layout customizations - size and title settings. </p> <p> Dive into 'Base Layout Settings' using Kotlin and Kandy, a primary plot adjustments. </p> <pre><code>plot {\n    line {\n        x(listOf(1, 2, 3, 4, 5))\n        y(listOf(5, 4, 7, 9, 10))\n    }\n    layout {\n        title = \"Plot title\"\n        size = 800 to 300\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/layout/Subtitle-And-Caption/","title":"Subtitle And Caption","text":"<p> Explore 'Subtitle And Caption' in Kotlin using Kandy to add additional plot inscriptions. </p> <p> 'Subtitle And Caption' in Kotlin with Kandy: supplement plot layout settings - subtitle and caption. </p> <p> Dive into 'Subtitle And Caption' using Kotlin and Kandy, a secondary plot notations. </p> <pre><code>plot {\n    bars {\n        x(listOf(\"a\", \"b\", \"c\", \"d\", \"e\"))\n        y(listOf(15, 14, 17, 19, 10))\n    }\n    layout {\n        title = \"Plot title\\nwith a line break\"\n        subtitle = \"Plot subtitle\"\n        caption = \"Plot caption\"\n        size = 700 to 350\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Comparing-Line-vs-Path-Plots/","title":"Comparing Line vs. Path Plots","text":"<p> Explore 'Comparing Line vs. Path Plots' in Kotlin using Kandy to understand the differences between line and path plots. This example clearly demonstrates how each plot type uniquely represents data. </p> <p> 'Comparing Line vs. Path Plots' in Kotlin with Kandy: A side-by-side demonstration showcasing the distinct characteristics of line and path plots for data visualization. </p> <p> Dive into the 'Comparing Line vs. Path Plots' example using Kotlin and Kandy, offering a comparative view of how line and path plots are used in graphing data. </p> <pre><code>fun generateArchimedeanDataMap(n: Int = 25, k: Double = 1.0, a: Double = 1.0): Map&lt;String, List&lt;Double&gt;&gt; {\n    val phi = List(n) { i -&gt; 2.0 * PI * k * i.toDouble() / (n - 1) }\n    val r = phi.map { angle -&gt; (a * angle) / (2.0 * PI) }\n    val x = (r zip phi).map { p -&gt; p.first * cos(p.second) }\n    val y = (r zip phi).map { p -&gt; p.first * sin(p.second) }\n    return mapOf(\"x\" to x, \"y\" to y)\n}\n\nval aDataMap = generateArchimedeanDataMap(n = 200, k = 2.0)\n</code></pre> <pre><code>val linePlot = plot(aDataMap) {\n    line {\n        x(\"x\")\n        y(\"y\")\n    }\n    layout.title = \"`line` layer\"\n}\nval pathPlot = plot(aDataMap) {\n    path {\n        x(\"x\")\n        y(\"y\")\n    }\n    layout.title = \"`path` layer\"\n}\nplotGrid(listOf(linePlot, pathPlot))\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Fixed-Line-Coordinate/","title":"Fixed Line Coordinate","text":"<p> Explore the 'Fixed Line Coordinate' example in Kotlin using Kandy, displaying weekly temperatures with a constant average line. This example demonstrates the use of fixed lines in data visualization. </p> <p> Kotlin 'Fixed Line Coordinate' Example: A visual representation of weekly temperatures, enhanced with a constant average line using Kandy. </p> <p> Dive into the 'Fixed Line Coordinate' Kotlin example with Kandy, where weekly temperature trends are complemented by a constant average line. </p> <p> <pre><code>data class DayTemperature(val day: String, val temp: Int)\n\nval weeklyTemp = listOf(\n    DayTemperature(\"Mon\", 10),\n    DayTemperature(\"Tue\", 6),\n    DayTemperature(\"Wed\", 5),\n    DayTemperature(\"Thu\", 7),\n    DayTemperature(\"Fri\", 7),\n    DayTemperature(\"Sat\", 11),\n    DayTemperature(\"Sun\", 9)\n).toDataFrame()\n\nweeklyTemp.plot {\n    x(\"day\")\n    line {\n        y(\"temp\")\n        color = Color.BLUE\n    }\n    line {\n        y.constant(weeklyTemp[DayTemperature::temp].mean())\n        color = Color.GREEN\n        type = LineType.DOTTED\n        width = 2.5\n    }\n}\n</code></pre> <p> <pre><code>val day = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval temp = listOf(10, 6, 5, 7, 7, 11, 9)\n\nplot {\n    x(day)\n    line {\n        y(temp)\n        color = Color.BLUE\n    }\n    line {\n        y.constant(temp.average())\n        color = Color.GREEN\n        type = LineType.DOTTED\n        width = 2.5\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Functional-Line-Plot/","title":"Functional Line Plot","text":"<p> Explore the 'Functional Line Plot' example in Kotlin with Kandy, which visualizes a complex mathematical function. This example demonstrates plotting intricate patterns using line plots. </p> <p> Kotlin 'Functional Line Plot' Example: A visual journey through mathematical functions using Kandy's line plotting capabilities.\" </p> <p> Dive into the 'Functional Line Plot' in Kotlin with Kandy, showcasing the art of plotting functions in a visually appealing way. </p> <pre><code>val xs = (-2000..2000).map { it / 500.0f }\nval function = { x: Float -&gt; sin(x) * cos(x * 2 + 1) * sin(3 * x + 2) }\nval ys = xs.map(function)\n\nplot {\n    line {\n        x(xs)\n        y(ys) {\n            scale = continuous(-1.0f..1.0f)\n        }\n        hLine {\n            yIntercept.constant(0.0)\n            color = Color.RED\n            type = LineType.DASHED\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Line-Gradient/","title":"Line Gradient","text":"<p> Discover the 'Line Gradient' example in Kotlin using Kandy, showcasing monthly temperature changes through a dynamic color gradient. This example demonstrates the impactful use of color transitions in line charts. </p> <p> Kotlin 'Line Gradient' Example: An engaging display of the year's temperature fluctuations, portrayed using a color gradient line with Kandy. </p> <p> Explore the 'Line Gradient' in Kotlin with Kandy, a visually appealing representation of temperature variations over a year using a color gradient line. </p> <p> <pre><code>val monthTemp = dataFrameOf(\"month\", \"temp\")(\n    \"January\", -5,\n    \"February\", -3,\n    \"March\", 2,\n    \"April\", 10,\n    \"May\", 16,\n    \"June\", 20,\n    \"July\", 22,\n    \"August\", 21,\n    \"September\", 15,\n    \"October\", 9,\n    \"November\", 3,\n    \"December\", -2\n)\n\nmonthTemp.plot {\n    line {\n        x(\"month\")\n        y(\"temp\") {\n            scale = continuous(-10..25) // axis scale\n        }\n        color(\"temp\") {\n            scale = continuous(Color.BLUE..Color.RED)\n        }\n        width = 3.0\n    }\n}\n</code></pre> <p> <pre><code>val monthTemp = mapOf(\n    \"month\" to listOf(\n        \"January\", \"February\",\n        \"March\", \"April\", \"May\",\n        \"June\", \"July\", \"August\",\n        \"September\", \"October\", \"November\",\n        \"December\"\n    ),\n    \"temp\" to listOf(-5, -3, 2, 10, 16, 20, 22, 21, 15, 9, 3, -2)\n)\n\nmonthTemp.plot {\n    line {\n        x(\"month\")\n        y(\"temp\") {\n            scale = continuous(-10..25) // axis scale\n        }\n        color(\"temp\") {\n            scale = continuous(Color.BLUE..Color.RED)\n        }\n        width = 3.0\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Line-Settings/","title":"Line Settings","text":"<p> Learn to customize line graphs in Kotlin using the Kandy library with the 'Line Settings' example. This demonstration includes altering line styles and colors for a dataset of museum visitors. </p> <p> 'Line Settings' Example: A Kotlin demonstration with Kandy to customize line graphs, featuring dashed lines and color adjustments. </p> <p> Dive into 'Line Settings' for insights on customizing line graphs in Kotlin with Kandy, showcasing a visualization of museum visitor data. </p> <p> <pre><code>val museumVisitors = dataFrameOf(\"date\", \"visitors\")(\n    LocalDate(2023, 1, 1), 120,\n    LocalDate(2023, 1, 15), 95,\n    LocalDate(2023, 2, 1), 110,\n    LocalDate(2023, 2, 15), 123,\n    LocalDate(2023, 3, 1), 130,\n    LocalDate(2023, 3, 15), 140,\n    LocalDate(2023, 4, 1), 150,\n    LocalDate(2023, 4, 15), 160,\n    LocalDate(2023, 5, 1), 175,\n    LocalDate(2023, 5, 15), 180\n).convert(\"date\").to&lt;String&gt;()\n\nmuseumVisitors.plot {\n    line {\n        x(\"date\")\n        y(\"visitors\")\n        type = LineType.DASHED\n        color = Color.PURPLE\n        width = 2.5\n    }\n}\n</code></pre> <p> <pre><code>val date = listOf(\n    LocalDate(2023, 1, 1),\n    LocalDate(2023, 1, 15),\n    LocalDate(2023, 2, 1),\n    LocalDate(2023, 2, 15),\n    LocalDate(2023, 3, 1),\n    LocalDate(2023, 3, 15),\n    LocalDate(2023, 4, 1),\n    LocalDate(2023, 4, 15),\n    LocalDate(2023, 5, 1),\n    LocalDate(2023, 5, 15)\n).map { it.toString() }\nval visitors = listOf(120, 95, 110, 123, 130, 140, 150, 160, 175, 180)\n\nplot {\n    line {\n        x(date)\n        y(visitors)\n        type = LineType.DASHED\n        color = Color.PURPLE\n        width = 2.5\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Line-with-Points/","title":"Line with Points","text":"<p> Explore the 'Line with Points' example in Kotlin using Kandy, where a line graph is enhanced with distinct points. This example visualizes the relationship between area and price. </p> <p> Kotlin 'Line with Points' Example: A graphical representation combining line and points with Kandy, showcasing area vs. price. </p> <p> See 'Line with Points' in action, a Kotlin example with Kandy that combines line graphs and point markers to represent area and price data. </p> <p> <pre><code>val area by columnOf(30, 40, 50, 60, 70, 80, 90)\nval price by columnOf(60000, 80000, 75000, 90000, 85000, 95000, 90000)\n\nplot {\n    x(price)\n    y(area)\n    line {\n        color = Color.BLUE\n        type = LineType.LONGDASH\n    }\n    points {\n        size = 3.5\n        symbol = Symbol.CIRCLE_OPEN\n        color = Color.BLUE\n    }\n}\n</code></pre> <p> <pre><code>val area by columnOf(30, 40, 50, 60, 70, 80, 90)\nval price by columnOf(60000, 80000, 75000, 90000, 85000, 95000, 90000)\n\nplot {\n    x(price)\n    y(area)\n    line {\n        color = Color.BLUE\n        type = LineType.LONGDASH\n    }\n    points {\n        size = 3.5\n        symbol = Symbol.CIRCLE_OPEN\n        color = Color.BLUE\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Line-with-Reversed-Axis/","title":"Line with Reversed Axis","text":"<p> Delve into the 'Line with Reversed Axis' example in Kotlin with Kandy, demonstrating the impactful use of axis inversion in line graph visualization. </p> <p> Experience the 'Line with Reversed Axis' in Kotlin with Kandy, showcasing how reversing an axis can offer a fresh perspective in graph plotting. </p> <p> Explore the unique approach of 'Line with Reversed Axis' in Kotlin using Kandy, highlighting the effectiveness of axis inversion in data representation. </p> <p> <pre><code>val product = ('A'..'F').toColumn(\"product\")\nval rating = listOf(10, 7, 3, 5, 2, 1).toColumn(\"rating\")\nval dataset = dataFrameOf(product, rating)\n\nplot(dataset) {\n    line {\n        x(rating) {\n            scale = continuous(min = 0, max = 12)\n        }\n        y(product) {\n            scale = continuous(transform = Transformation.REVERSE)\n        }\n        color = Color.RED\n        alpha = 0.85\n    }\n}\n</code></pre> <p> <pre><code>val product = ('A'..'F')\nval rating = listOf(10, 7, 3, 5, 2, 1)\n\nplot {\n    line {\n        x(rating) {\n            scale = continuous(min = 0, max = 12)\n        }\n        y(product) {\n            scale = continuous(transform = Transformation.REVERSE)\n        }\n        color = Color.RED\n        alpha = 0.85\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Marked-Line/","title":"Marked Line","text":"<p> Explore 'Marked Line' in Kotlin using Kandy, showcasing how to highlight key data points in line graphs. This example compares temperatures in Berlin and Madrid with distinct visual markers. </p> <p> Marked Line' in Kotlin with Kandy: An elegant demonstration of line graphs with added emphasis on specific data points for clearer comparisons. </p> <p> Dive into the 'Marked Line' example using Kotlin and Kandy, where line graphs are enhanced with markers to highlight key comparisons. </p> <p> <pre><code>val months = listOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval tempBerlin =\n    listOf(-0.5, 0.0, 4.8, 9.0, 14.3, 17.5, 19.2, 18.9, 14.5, 9.7, 4.7, 1.0)\nval tempMadrid =\n    listOf(6.3, 7.9, 11.2, 12.9, 16.7, 21.1, 24.7, 24.2, 20.3, 15.4, 9.9, 6.6)\n\nval df = dataFrameOf(\n    \"month\" to months + months,\n    \"temperature\" to tempBerlin + tempMadrid,\n    \"city\" to List(12) { \"Berlin\" } + List(12) { \"Madrid\" }\n)\n\ndf.plot {\n    line {\n        x(\"month\")\n        y(\"temperature\")\n        color(\"city\") {\n            scale = categorical(\"Berlin\" to Color.PURPLE, \"Madrid\" to Color.ORANGE)\n        }\n        width = 1.5\n    }\n    hLine {\n        yIntercept.constant(tempBerlin.average())\n        color = Color.PURPLE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    hLine {\n        yIntercept.constant(tempMadrid.average())\n        color = Color.ORANGE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    layout.size = 1000 to 450\n}\n</code></pre> <p> <pre><code>val months = listOf(\n    \"January\", \"February\",\n    \"March\", \"April\", \"May\",\n    \"June\", \"July\", \"August\",\n    \"September\", \"October\", \"November\",\n    \"December\"\n)\nval tempBerlin =\n    listOf(-0.5, 0.0, 4.8, 9.0, 14.3, 17.5, 19.2, 18.9, 14.5, 9.7, 4.7, 1.0)\nval tempMadrid =\n    listOf(6.3, 7.9, 11.2, 12.9, 16.7, 21.1, 24.7, 24.2, 20.3, 15.4, 9.9, 6.6)\n\nval df = mapOf(\n    \"month\" to months + months,\n    \"temperature\" to tempBerlin + tempMadrid,\n    \"city\" to List(12) { \"Berlin\" } + List(12) { \"Madrid\" }\n)\n\ndf.plot {\n    line {\n        x(\"month\")\n        y(\"temperature\")\n        color(\"city\") {\n            scale = categorical(\"Berlin\" to Color.PURPLE, \"Madrid\" to Color.ORANGE)\n        }\n        width = 1.5\n    }\n    hLine {\n        yIntercept.constant(tempBerlin.average())\n        color = Color.PURPLE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    hLine {\n        yIntercept.constant(tempMadrid.average())\n        color = Color.ORANGE\n        alpha = 0.9\n        type = LineType.DASHED\n    }\n    layout.size = 1000 to 450\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Path-Line/","title":"Path Line","text":"<p> Discover the 'Path Line' example in Kotlin with Kandy, where a path line graph is used to illustrate the relationship between temperature and performance. This example is ideal for visualizing trends in challenging conditions. </p> <p> 'Path Line' in Kotlin with Kandy: A graph that cleverly depicts performance changes against temperature, ideal for understanding trends in extreme conditions. </p> <p> Explore the 'Path Line' example in Kotlin using Kandy to see how path lines can effectively represent performance metrics across varying temperatures. </p> <pre><code>val dist = listOf(100, 90, 80, 70, 60, 50, 40)\nval temp = listOf(-45.5, -44.4, -40.0, -43.2, -41.5, -35.5, -39.9)\n\nplot {\n    layout {\n        title = \"Performance Dependency on Temperature\"\n        subtitle = \"Analysis of Material Performance Decline at Extremely Low Temperatures\"\n        yAxisLabel = \"Performance Measure\"\n        size = 600 to 550\n    }\n    path {\n        y(dist)\n        x(temp) {\n            axis.name = \"Temperature (\u00b0C)\"\n        }\n        color = Color.BLUE\n        type = LineType.LONGDASH\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Several-Lines/","title":"Several Lines","text":"<p> Explore the 'Several Lines' example in Kotlin with Kandy to see how multiple line plots can be effectively used for data comparison in a single graph. </p> <p> Kotlin 'Several Lines' Example: Demonstrating the power of multi-line graphs for comparative data analysis with Kandy. </p> <p> Delve into the 'Several Lines' Kotlin example using Kandy, showcasing the use of multiple lines in a single graph for enhanced data visualization. </p> <p> <pre><code>val months = listOf(1, 2, 3, 4, 5)\nval salesProducts = listOf(200.0, 220.0, 180.0, 240.0, 210.0)\nval salesClothes = listOf(150.0, 130.0, 160.0, 140.0, 170.0)\nval salesElectronics = listOf(300.0, 320.0, 310.0, 330.0, 340.0)\n\nval dataset = dataFrameOf(\n    \"month\" to months + months + months,\n    \"sales\" to salesProducts + salesClothes + salesElectronics,\n    \"category\" to List(5) { \"Products\" } + List(5) { \"Clothes\" } + List(5) { \"Electronics\" }\n)\n\ndataset.groupBy(\"category\").plot {\n    line {\n        x(\"month\")\n        y(\"sales\")\n        color(\"category\")\n    }\n}\n</code></pre> <p> <pre><code>val months = listOf(1, 2, 3, 4, 5)\nval salesProducts = listOf(200.0, 220.0, 180.0, 240.0, 210.0)\nval salesClothes = listOf(150.0, 130.0, 160.0, 140.0, 170.0)\nval salesElectronics = listOf(300.0, 320.0, 310.0, 330.0, 340.0)\n\nval dataset = mapOf(\n    \"month\" to months + months + months,\n    \"sales\" to salesProducts + salesClothes + salesElectronics,\n    \"category\" to List(5) { \"Products\" } + List(5) { \"Clothes\" } + List(5) { \"Electronics\" }\n)\n\ndataset.plot {\n    groupBy(\"category\") {\n        line {\n            x(\"month\")\n            y(\"sales\")\n            color(\"category\")\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Simple-Line/","title":"Simple Line","text":"<p> Explore a simple line plot creation with the 'Simple Line' example using the Kandy library in Kotlin, illustrating cost changes over years. </p> <p> 'Simple Line' in Kotlin with Kandy: Effortlessly visualize yearly cost trends in a clear line plot. </p> <p> Check out 'Simple Line' for an easy demonstration of line chart plotting with Kandy in Kotlin, featuring yearly cost data. </p> <p> <pre><code>val years by columnOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval cost by columnOf(62.7, 64.7, 72.1, 73.7, 68.5)\nval df = dataFrameOf(years, cost)\n\ndf.plot {\n    line {\n        x(years)\n        y(cost)\n    }\n}\n</code></pre> <p> <pre><code>val years = listOf(\"2018\", \"2019\", \"2020\", \"2021\", \"2022\")\nval cost = listOf(62.7, 64.7, 72.1, 73.7, 68.5)\n\nplot {\n    line {\n        x(years)\n        y(cost)\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Smoothed-Curve-with-Points/","title":"Smoothed Curve with Points","text":"<p> Discover the 'Smoothed Curve with Points' example in Kotlin using Kandy, where smooth curves and distinct data points come together. This example elegantly combines line smoothing and point plotting. </p> <p> 'Smoothed Curve with Points' in Kotlin with Kandy: A visualization that merges smooth lines with clearly marked points, ideal for detailed trend analysis </p> <p> Explore the 'Smoothed Line with Points' using Kotlin and Kandy, an attractive way to represent data with both smoothed lines and individual points. </p> <pre><code>val xs = listOf(-3.0, -2.5, -2.0, -1.5, -1.0, 0.0, 1.0, 1.5, 2.0, 2.5, 3.0)\nval ys = listOf(-5.4, -1.2, 3.4, 0.1, -0.6, -2.1, 0.6, 2.2, 3.4, 4.5, 6.7)\n\nplot {\n    smoothLine(xs, ys, method = SmoothMethod.LOESS(span = 0.3)) {\n        color = Color.GREEN\n    }\n    points {\n        size = 4.0\n        color = Color.ORANGE\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Smoothed-Line/","title":"Smoothed Line","text":"<p> Explore the 'Smoothed Line' example in Kotlin using Kandy, showcasing how to create a smooth curve from a set of data points. This example is perfect for visualizing trends in scattered data. </p> <p> 'Smoothed Line' in Kotlin with Kandy: A demonstration of smoothing techniques applied to line graphs for a clear and flowing data presentation. </p> <p> Dive into the 'Smoothed Line' example using Kotlin and Kandy, illustrating the elegance of smoothed line graphs in data visualization. </p> <pre><code>val xs = listOf(-3.0, -2.5, -2.0, -1.5, -1.0, 0.0, 1.0, 1.5, 2.0, 2.5, 3.0)\nval ys = listOf(-5.4, -1.2, 3.4, 0.1, -0.6, -2.1, 0.6, 2.2, 3.4, 4.5, 6.7)\n\nplot {\n    smoothLine(xs, ys, smootherPointCount = 30) {\n        width = 2.3\n        color = Color.GREEN\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/line/Step-Line/","title":"Step Line","text":"<p> Explore the 'Step Line' example in Kotlin using Kandy, where step lines are utilized to visualize data changes over a week. This example combines step lines with points for a clear data representation. </p> <p> 'Step Line' in Kotlin with Kandy: A creative depiction of weekly data trends using step lines and distinct points for enhanced clarity. </p> <p> Dive into the 'Step Line' example in Kotlin using Kandy, showcasing an innovative way to represent weekly data variations with step lines and points. </p> <pre><code>val week = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval start = listOf(120, 132, 101, 134, 90, 230, 210)\nval middle = listOf(220, 282, 201, 234, 290, 430, 410)\nval end = listOf(450, 432, 401, 454, 590, 530, 510)\n\nplot {\n    x(week)\n    step { y(start); color = Color.LIGHT_BLUE }\n    points { y(start); symbol = Symbol.CIRCLE_OPEN; color = Color.BLUE }\n\n    step {\n        y(middle)\n        color = Color.GREEN\n        lineType = LineType.LONGDASH\n    }\n    points {\n        y(middle)\n        symbol = Symbol.CIRCLE_PLUS\n        color = Color.GREEN\n    }\n\n    step {\n        y(end)\n        color = Color.YELLOW\n    }\n    points {\n        y(end)\n        symbol = Symbol.CIRCLE_FILLED\n        fillColor = Color.YELLOW\n        color = Color.GREY\n    }\n    layout {\n        title = \"Step line\"\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Basic-Points-Plot/","title":"Basic Points Plot","text":"<p> Discover 'Basic Points Plot' in Kotlin using Kandy, a fundamental example of scatter plot visualization. This example adeptly demonstrates how individual data points can be plotted on a graph to identify patterns and relationships. </p> <p> 'Basic Points Plot' in Kotlin with Kandy: A straightforward scatter plot demonstration, ideal for visualizing relationships between variables through individual data points. </p> <p> Explore 'Basic Points Plot' using Kotlin and Kandy, a simple yet effective way to visualize data sets and uncover potential correlations with scatter plotting. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"xs\" to listOf(\n        5.93, 9.15, 3.76, 5.04, 2.23,\n        7.47, 2.59, 11.67, 7.90, 3.71,\n        0.03, 2.73, 4.61, 5.44, 1.76,\n        14.46, 1.89\n    ),\n    \"ys\" to listOf(\n        14.66, 13.80, 5.37, 6.40, 6.86,\n        2.98, 6.69, 5.48, 3.67, 12.36,\n        0.01, 14.47, 14.56, 9.19, 12.86,\n        5.37, 0.90\n    )\n)\n\ndataset.plot {\n    points {\n        x(\"xs\")\n        y(\"ys\")\n    }\n}\n</code></pre> <p> <pre><code>val xs = listOf(\n    5.93, 9.15, 3.76, 5.04, 2.23,\n    7.47, 2.59, 11.67, 7.90, 3.71,\n    0.03, 2.73, 4.61, 5.44, 1.76,\n    14.46, 1.89\n)\nval ys = listOf(\n    14.66, 13.80, 5.37, 6.40, 6.86,\n    2.98, 6.69, 5.48, 3.67, 12.36,\n    0.01, 14.47, 14.56, 9.19, 12.86,\n    5.37, 0.90\n)\n\nplot {\n    points {\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Bubble-Chart/","title":"Bubble Chart","text":"<p> Explore 'Bubble Chart' in Kotlin using Kandy, a visually engaging way to represent multidimensional data. This example demonstrates how bubble sizes can vary based on data values, adding an extra layer of information to the traditional scatter plot. </p> <p> 'Bubble Chart' in Kotlin with Kandy: An advanced scatter plot that uses bubble sizes to represent additional data dimensions, perfect for a more nuanced data visualization. </p> <p> Dive into 'Bubble Chart' using Kotlin and Kandy, where scatter plots are enhanced with variable-sized bubbles. </p> <pre><code>val dayOfWeek = listOf(\n    \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n    \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\"\n)\nval week = listOf(\n    17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19,\n    19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21\n)\nval contributions = listOf(\n    2, 1, 7, 0, 0, 0, 5, 11, 4, 5, 0, 1, 3, 8, 1,\n    6, 12, 1, 0, 0, 0, 15, 7, 3, 0, 1, 2, 5, 6, 3\n)\n\nplot {\n    points {\n        x(week) {\n            axis {\n                name = \"Week\"\n                breaks(week.distinct(), format = \"d\")\n            }\n        }\n        y(dayOfWeek) {\n            axis {\n                name = \"Day of week\"\n                breaks(listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\").reversed())\n            }\n        }\n        color = Color.BLUE\n        size(contributions) {\n            scale = continuous(5.0..20.0, 1..15)\n            legend.name = \"Contributions\"\n        }\n    }\n    layout.title = \"May GitHub contributions\"\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Complex-Bubble-Chart/","title":"Complex Bubble Chart","text":"<p> Explore the intricacies of data visualization with the \"Complex Bubble Chart\" in Kotlin using Kandy. This example demonstrates how bubble charts can be utilized to represent multidimensional data, providing insights into relationships and distributions through varying bubble sizes and colors. </p> <p> Delve into multi-dimensional data visualization with the \"Complex Bubble Chart\" example using Kandy in Kotlin. It showcases how bubble size and color can enhance understanding of complex datasets. </p> <p> Discover multidimensional insights with 'Complex Bubble Chart' using Kandy, highlighting how bubble size and color reveal dataset complexities. </p> <pre><code>val country by columnOf(\n    \"Australia\", \"Canada\", \"China\", \"Cuba\", \"Finland\", \"France\", \"Germany\",\n    \"Iceland\", \"India\", \"Japan\", \"North Korea\", \"South Korea\", \"New Zealand\",\n    \"Norway\", \"Poland\", \"Russia\", \"Turkey\", \"United Kingdom\", \"United States\"\n)\nval lifeExp1998 = columnOf(\n    75.49, 76.03, 66.35, 58.75, 79.64, 82.92, 80.68,\n    70.71, 60.30, 82.78, 69.57, 74.61, 71.18,\n    71.43, 75.22, 72.65, 74.56, 75.19, 81.12\n) named \"lifeExp\"\nval pop1998 = columnOf(\n    19000, 30000, 1250000, 11000, 5000,\n    59000, 82000, 280, 950000, 126000,\n    24000, 47000, 3800, 4400, 38600,\n    147000, 63000, 59000, 273000\n) named \"population\"\nval gdpPerCapita1998 = columnOf(\n    29000, 32000, 750, 5000, 28000,\n    27000, 32000, 34000, 450, 33000,\n    600, 12000, 22000, 40000, 9000,\n    4000, 3000, 28000, 35000\n) named \"gdp\"\nval dataset1998 = dataFrameOf(country, lifeExp1998, pop1998, gdpPerCapita1998).add(\"year\") { 1998 }\n\nval lifeExp2023 = columnOf(\n    79.44, 73.60, 70.46, 63.34, 72.10, 78.15, 80.70,\n    79.88, 63.13, 81.53, 59.33, 71.59, 76.56,\n    71.97, 78.21, 78.38, 79.76, 84.77, 82.39\n) named \"lifeExp\"\nval pop2023 = columnOf(\n    25000, 38000, 1400000, 11300, 5500,\n    67000, 83000, 340, 1350000, 126000,\n    25000, 51000, 5000, 5300, 38000,\n    146000, 82000, 67000, 331000\n) named \"population\"\nval gdpPerCapita2023 = columnOf(\n    55000, 52000, 10000, 7000, 48000,\n    44000, 50000, 60000, 2000, 45000,\n    1200, 30000, 34000, 70000, 15000,\n    9000, 10000, 40000, 60000\n) named \"gdp\"\nval dataset2023 = dataFrameOf(country, lifeExp2023, pop2023, gdpPerCapita2023).add(\"year\") { 2023 }\n\nval dataset = dataset1998.fullJoin(dataset2023)\n\ndataset.groupBy(\"year\").plot {\n    layout.title = \"Life Expectancy and GDP by Country\"\n    points {\n        x(\"gdp\") { axis.name = \"GDP per capita (in dollars)\" }\n        y(\"lifeExp\") { axis.name = \"Life expectancy (years)\" }\n        size(\"population\") {\n            legend.type = LegendType.None\n            scale = continuous(5.0..20.0)\n        }\n        color(\"year\") {\n            legend {\n                name = \"\"\n                breaks(format = \"d\")\n            }\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <pre><code>dataset.filter { \"year\"&lt;Int&gt;() == 1998 }.plot {\n    layout.title = \"Life Expectancy and GDP by Country (1998)\"\n    points {\n        x(\"gdp\") { axis.name = \"GDP per capita (in dollars)\" }\n        y(\"lifeExp\") { axis.name = \"Life expectancy (years)\" }\n        size(\"population\") {\n            legend.type = LegendType.None\n            scale = continuous(2.0..15.0)\n        }\n        color(\"country\") {\n            scale = categoricalColorHue()\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <pre><code>dataset.filter { \"year\"&lt;Int&gt;() == 2023 }.plot {\n    layout.title = \"Life Expectancy and GDP by Country (2023)\"\n    points {\n        x(\"gdp\") { axis.name = \"GDP per capita (in dollars)\" }\n        y(\"lifeExp\") { axis.name = \"Life expectancy (years)\" }\n        size(\"population\") {\n            legend.type = LegendType.None\n            scale = continuous(2.0..15.0)\n        }\n        color(\"country\") {\n            scale = categoricalColorHue()\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Fixed-Points/","title":"Fixed Points Coordinate","text":"<p> Discover 'Fixed Points Coordinate' in Kotlin using Kandy, a plot showcasing the use of fixed coordinates in a scatter plot. This example is ideal for highlighting specific data points or benchmarks against a backdrop of broader data scatter. </p> <p> 'Fixed Points Coordinate' in Kotlin with Kandy: A unique scatter plot that emphasizes certain data points through fixed coordinates, perfect for detailed comparative analysis. </p> <p> Explore 'Fixed Points Coordinate' using Kotlin and Kandy, where scatter plotting is refined with fixed coordinates to spotlight key data points or benchmarks. </p> <pre><code>plot {\n    points {\n        x.constant(0.5)\n        y(listOf(1, 2, 3, 4, 5, 6, 7))\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Functional-Scatter-Plot/","title":"Functional Scatter Plot","text":"<p> Explore 'Functional Scatter Plot' in Kotlin using Kandy, a visualization that combines scatter plotting with functional data representation. This example is great for demonstrating how mathematical functions can be visually expressed and analyzed through scatter plots. </p> <p> 'Functional Scatter Plot' in Kotlin with Kandy: A creative intersection of math and visualization, ideal for graphically depicting the behavior of mathematical functions. </p> <p> Dive into 'Functional Scatter Plot' using Kandy, where the scatter plot format is used to visually interpret mathematical functions. </p> <pre><code>val xs = (-30..30).map { it / 5.0f }\nval function = { x: Float -&gt; sin(x) }\nval ys = xs.map(function)\n\nplot {\n    points {\n        x(xs)\n        y(ys)\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Jittered-Points/","title":"Jittered Points","text":"<p> Explore 'Jittered Points' in Kotlin using Kandy, a plot that demonstrates the technique of jittering to spread out overlapping data points. This example is perfect for datasets where individual observations need to be distinctly visualized in dense areas. </p> <p> 'Jittered Points' in Kotlin with Kandy: An effective way to prevent data overlap in scatter plots, ideal for clearer visualization of dense data clusters. </p> <p> Dive into 'Jittered Points' using Kotlin and Kandy, where jittering techniques are applied to scatter plots to enhance the readability of closely-packed data points. </p> <p> <pre><code>val random = kotlin.random.Random(42)\nval dataset = dataFrameOf(\n    \"type\" to List(50) { \"a\" } + List(50) { \"b\" },\n    \"value\" to List(50) { kotlin.random.Random.nextDouble(0.1, 0.6) } +\n            List(50) { random.nextDouble(-0.5, 0.4) }\n)\n\nval type = column&lt;String&gt;(\"type\")\nval value = column&lt;Double&gt;(\"value\")\n\ndataset.plot {\n    points {\n        x(type)\n        y(value)\n        color(type)\n        position = Position.jitter()\n    }\n}\n</code></pre> <p> <pre><code>val random = kotlin.random.Random(42)\nval type = List(50) { \"a\" } + List(50) { \"b\" }\nval value = List(50) { random.nextDouble(0.1, 0.6) } +\n        List(50) { random.nextDouble(-0.5, 0.4) }\n\nplot {\n    points {\n        x(type)\n        y(value)\n        color(type)\n        position = Position.jitter()\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Points-Gradient/","title":"Points Gradient","text":"<p> Discover 'Points Gradient' in Kotlin using Kandy, showcasing how gradient colors can be used to enhance scatter plots. This example illustrates the use of color gradients to represent variations in data, adding depth and dimension to the visualization. </p> <p> 'Points Gradient' in Kotlin with Kandy: A visually appealing approach to scatter plots, where gradient colors add layers of meaning to each data point. </p> <p> Explore 'Points Gradient' using Kotlin and Kandy, where color gradients in scatter plots bring a new level of insight and aesthetic to data visualization. </p> <pre><code>val random = kotlin.random.Random(42)\nval xs = List(100) { random.nextDouble(0.0, 10.0) }\nval ys = List(100) { random.nextDouble(0.0, 10.0) }\nval gradient = List(100) { random.nextDouble(0.0, 100.0) }\nplot {\n    points {\n        x(xs)\n        y(ys)\n        size = 7.5\n        color(gradient) {\n            scale = continuous(Color.LIGHT_BLUE..Color.PURPLE, domain = 0.0..100.0)\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Points-Settings/","title":"Points Settings","text":"<p> Explore 'Points Settings' in Kotlin using Kandy, a detailed guide to customizing scatter plots. This example demonstrates various settings for point plots, including adjustments in size, color, and shape, making it an excellent resource for tailored data visualization. </p> <p> 'Points Settings' in Kotlin with Kandy: A deep dive into customizing scatter plot appearances, perfect for creating visually distinct and informative point-based graphs. </p> <p> Dive into 'Points Settings' using Kandy, where scatter plots are fine-tuned with various settings to enhance clarity and visual appeal in data representation. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"xs\" to listOf(\n        5.93, 9.15, 3.76, 5.04, 2.23,\n        7.47, 2.59, 11.67, 7.90, 3.71,\n        0.03, 2.73, 4.61, 5.44, 1.76,\n        14.46, 1.89\n    ),\n    \"ys\" to listOf(\n        14.66, 13.80, 5.37, 6.40, 6.86,\n        2.98, 6.69, 5.48, 3.67, 12.36,\n        0.01, 14.47, 14.56, 9.19, 12.86,\n        5.37, 0.90\n    )\n)\n\ndataset.plot {\n    points {\n        x(\"xs\")\n        y(\"ys\")\n        size = 10.0\n        color = Color.BLUE\n        symbol = Symbol.DIAMOND\n    }\n}\n</code></pre> <p> <pre><code>val xs = listOf(\n    5.93, 9.15, 3.76, 5.04, 2.23,\n    7.47, 2.59, 11.67, 7.90, 3.71,\n    0.03, 2.73, 4.61, 5.44, 1.76,\n    14.46, 1.89\n)\nval ys = listOf(\n    14.66, 13.80, 5.37, 6.40, 6.86,\n    2.98, 6.69, 5.48, 3.67, 12.36,\n    0.01, 14.47, 14.56, 9.19, 12.86,\n    5.37, 0.90\n)\n\nplot {\n    points {\n        x(xs)\n        y(ys)\n        size = 10.0\n        color = Color.BLUE\n        symbol = Symbol.DIAMOND\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Points-with-ABLine/","title":"Points with ABLine","text":"<p> Discover how to enhance scatter plots with an ABLine in Kotlin using the Kandy library. This example illustrates the integration of a reference line to scatter plots, aiding in data analysis and trend visualization.  </p> <p> Enhance data visualization with the \"Points with ABLine\" example in Kotlin using Kandy. This plot combines scatter points with a reference line, offering deeper insights into data trends and correlations. </p> <p> Explore data trends with 'Points with ABLine' using Kandy, blending scatter points and a reference line for deeper insights. </p> <p> <pre><code>val xValues by columnOf(\n    7.13, 9.30, 7.84, 7.08, 5.51,\n    8.40, 5.69, 11.59, 12.53, 4.98,\n    10.29, 6.88, 7.38, 12.03, 0.92\n)\nval yValues by columnOf(\n    7.05, 8.23, 6.74, 7.95, 5.38,\n    7.47, 4.88, 9.17, 9.30, 6.17,\n    6.58, 5.87, 6.45, 10.53, 3.13\n)\n\nplot {\n    points {\n        x(xValues)\n        y(yValues)\n        size = 7.0\n        color = Color.LIGHT_BLUE\n    }\n    abLine {\n        slope.constant(0.5)\n        intercept.constant(3)\n        color = Color.RED\n    }\n}\n</code></pre> <p> <pre><code>val xValues = listOf(\n    7.13, 9.30, 7.84, 7.08, 5.51,\n    8.40, 5.69, 11.59, 12.53, 4.98,\n    10.29, 6.88, 7.38, 12.03, 0.92\n)\nval yValues = listOf(\n    7.05, 8.23, 6.74, 7.95, 5.38,\n    7.47, 4.88, 9.17, 9.30, 6.17,\n    6.58, 5.87, 6.45, 10.53, 3.13\n)\n\nplot {\n    points {\n        x(xValues)\n        y(yValues)\n        size = 7.0\n        color = Color.LIGHT_BLUE\n    }\n    abLine {\n        slope.constant(0.5)\n        intercept.constant(3)\n        color = Color.RED\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/points/Points-with-Color-by-Category/","title":"Points with Color by Category","text":"<p> Discover 'Points with Color by Category' in Kotlin using Kandy, a scatter plot example that uses color coding to differentiate data categories. This approach highlights the distribution and relationships between groups in a dataset, making it ideal for comparative analysis. </p> <p> 'Points with Color by Category' in Kotlin with Kandy: A scatter plot that brings clarity to data grouping through color differentiation, perfect for visualizing multi-category datasets. </p> <p> Explore 'Points with Color by Category' using Kandy, where color coding in scatter plots provides a clear distinction between data categories. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"xShot\" to listOf(\n        4.02, 5.24, 4.41, 3.99, 3.10, 4.73, 3.20, 6.53, 7.05, 2.81,\n        5.80, 3.87, 4.16, 6.78, 0.52, 0.64, 0.15, 6.09, 5.70, 6.37\n    ),\n    \"yShot\" to listOf(\n        2.39, 1.95, 1.13, 1.90, 0.29, 1.56, 0.35, 2.30, 1.27, 1.01,\n        0.65, 1.89, 1.11, 1.39, 0.05, 1.51, 1.49, 1.51, 2.30, 1.66\n    ),\n    \"outcome\" to listOf(\n        false, true, false, true, true, true, true, true, true, false,\n        true, true, false, false, true, false, false, true, true, false\n    )\n)\n\ndataset.plot {\n    points {\n        x(\"xShot\") { axis.name = \"Horizontal Position (meters)\" }\n        y(\"yShot\") { axis.name = \"Vertical Position (meters)\" }\n        size = 8.5\n        color(\"outcome\") {\n            scale = categorical(\n                true to Color.GREEN, false to Color.RED\n            )\n            legend {\n                name = \"Outcome\"\n                breaksLabeled(true to \"Goal\", false to \"Miss\")\n            }\n        }\n    }\n    layout.title = \"Penalty Shot Outcomes Analysis\"\n}\n</code></pre> <p> <pre><code>val xShot = listOf(\n    4.02, 5.24, 4.41, 3.99, 3.10, 4.73, 3.20, 6.53, 7.05, 2.81,\n    5.80, 3.87, 4.16, 6.78, 0.52, 0.64, 0.15, 6.09, 5.70, 6.37\n)\nval yShot = listOf(\n    2.39, 1.95, 1.13, 1.90, 0.29, 1.56, 0.35, 2.30, 1.27, 1.01,\n    0.65, 1.89, 1.11, 1.39, 0.05, 1.51, 1.49, 1.51, 2.30, 1.66\n)\nval outcome = listOf(\n    false, true, false, true, true, true, true, true, true, false,\n    true, true, false, false, true, false, false, true, true, false\n)\n\nval dataset = mapOf(\n    \"xShot\" to xShot,\n    \"yShot\" to yShot,\n    \"outcome\" to outcome\n)\n\n\nplot(dataset) {\n    points {\n        x(\"xShot\") { axis.name = \"Horizontal Position (meters)\" }\n        y(\"yShot\") { axis.name = \"Vertical Position (meters)\" }\n        size = 8.5\n        color(\"outcome\") {\n            scale = categorical(\n                true to Color.GREEN, false to Color.RED\n            )\n            legend {\n                name = \"Outcome\"\n                breaksLabeled(true to \"Goal\", false to \"Miss\")\n            }\n        }\n    }\n    layout.title = \"Penalty Shot Outcomes Analysis\"\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Function-Ribbon-Graph/","title":"Function Ribbon Graph","text":"<p> Explore 'Function Ribbon Graph' in Kotlin using Kandy to visualize complex mathematical functions. This example uniquely demonstrates how ribbon plots can be used to represent intricate function behaviors and patterns. </p> <p> 'Function Ribbon Graph' in Kotlin with Kandy: A mathematical journey into visualizing complex functions using ribbon plots, perfect for an analytical view of functional dynamics. </p> <p> Dive into 'Function Ribbon Graph' using Kotlin and Kandy, where mathematics meets art in the visualization of complex functional relationships with ribbon plots. </p> <pre><code>val xs = (-1000..1000).map { it / 250.0f }\nval function = { x: Float -&gt; sin(2 * x) * cos(x / 2 - 3.0) }\nval yActual = xs.map(function)\nval yLow = yActual.map { it - 0.25 }\nval yHigh = yActual.map { it + 0.25 }\n\nplot {\n    ribbon {\n        x(xs)\n        yMin(yLow)\n        yMax(yHigh)\n        fillColor = Color.LIGHT_BLUE\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Regression-Confidence-Band/","title":"Regression Confidence Band","text":"<p> Explore the 'Regression Confidence Band' plot in Kotlin using Kandy to see how line smoothing techniques can be enhanced with ribbon plot. </p> <p> 'Regression Confidence Band' in Kotlin with Kandy: A seamless blend of data smoothing and ribbon plotting, ideal for portraying subtle data patterns in a visually appealing way. </p> <p> Dive into 'Regression Confidence Band' using Kotlin and Kandy, showcasing the elegance and clarity of smoothed curves extension with ribbon plot. </p> <pre><code>val xs = listOf(\n    -3.0, -2.8, -2.7, -2.6, -2.6, -2.5, -2.2, -3.1, -1.5,\n    -0.2,  2.0, 1.2, 2.6, 2.1, 0.1, 1.2, 1.7, 0.0, 2.8,\n    2.5, 0.2, 1.3, 2.5\n)\nval ys = listOf(\n    -1.4, -1.2, -1.4, -1.3, -1.2, -1.1, 1.5, 2.4, 1.1, -0.9,\n    3.5, 1.6, -0.7, 1.2, 0.1, 3.4, 2.8, 4.2, 1.16, 4.1, 2.2,\n    1.4, 5.1\n)\n\nplot {\n    statSmooth(xs, ys) {\n        line {\n            x(Stat.x)\n            y(Stat.y)\n            width = 2.0\n            color = Color.BLUE\n        }\n        ribbon {\n            x(Stat.x)\n            yMin(Stat.yMin)\n            yMax(Stat.yMax)\n            borderLine.width = 0.0\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Ribbon-Settings/","title":"Ribbon Settings","text":"<p> Learn to customize ribbon graphs in Kotlin using the Kandy library with the 'Ribbon Settings' example. This demonstration includes altering ribbon styles and colors for a dataset of minimal and maximal cost over years. </p> <p> 'Ribbon Settings' Example: A Kotlin demonstration with Kandy to customize ribbon graphs, featuring dashed ribbons and color adjustments. </p> <p> Dive into 'Ribbon Settings' for insights on customizing ribbon graphs in Kotlin with Kandy, showcasing a visualization of years cost changes data. </p> <p> <pre><code>val year by columnOf(\"2019\", \"2020\", \"2021\", \"2022\", \"2023\")\nval minCost by columnOf(56.5, 59.9, 60.8, 78.9, 75.5)\nval maxCost by columnOf(58.1, 69.3, 66.4, 108.3, 92.2)\nval df = dataFrameOf(year, minCost, maxCost)\n\ndf.plot {\n    ribbon {\n        x(year)\n        y {\n            axis.name = \"cost\"\n            scale = continuous(55.0..110.0)\n        }\n        yMin(minCost)\n        yMax(maxCost)\n        fillColor = Color.hex(0x3f21e6)\n        alpha = 0.65\n        borderLine {\n            color = Color.RED\n            width = 0.8\n            type = LineType.DASHED\n        }\n    }\n}\n</code></pre> <p> <pre><code>val year = listOf(\"2019\", \"2020\", \"2021\", \"2022\", \"2023\")\nval minCost = listOf(56.5, 59.9, 60.8, 78.9, 75.5)\nval maxCost = listOf(58.1, 69.3, 66.4, 108.3, 92.2)\n\nplot {\n    ribbon {\n        x(year)\n        y {\n            axis.name = \"cost\"\n            scale = continuous(55.0..110.0)\n        }\n        yMin(minCost)\n        yMax(maxCost)\n        fillColor = Color.hex(0x3f21e6)\n        alpha = 0.65\n        borderLine {\n            color = Color.RED\n            width = 0.8\n            type = LineType.DASHED\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Ribbon-With-Line/","title":"Ribbon With Line","text":"<p> Discover 'Ribbon with Line' in Kotlin using Kandy, where ribbon plots are enhanced with mark line. This example compares the minimal, middle and maximal price value over week. </p> <p> 'Ribbon with Line' in Kotlin with Kandy: An innovative plot combining ribbon charts with line, providing a visual comparison of price value characteristics. </p> <p> Explore 'Ribbon with Line' in Kotlin using Kandy, a creative approach to show value interval with middle value. </p> <p> <pre><code>val day by columnOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval low by columnOf(16345f, 18718f, 17541f, 17302f, 15991f, 18315f, 20189f)\nval high by columnOf(18252f, 19912f, 19001f, 21540f, 18770f, 20945f, 23007f)\nval mid by (low.values().zip(high.values()).map { (it.second + it.first) / 2 }).toColumn()\nval df = dataFrameOf(day, low, mid, high)\n\ndf.plot {\n    x(day) { axis.name = \"day of week\" }\n    y {\n        axis.name = \"price\"\n        scale = continuous(15000f..24000f)\n    }\n    line {\n        y(mid)\n        color = Color.GREEN\n        type = LineType.DOTTED\n        width = 2.0\n    }\n    ribbon {\n        yMin(low)\n        yMax(high)\n        borderLine.color = Color.BLUE\n    }\n}\n</code></pre> <p> <pre><code>val day = listOf(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\nval low = listOf(16345f, 18718f, 17541f, 17302f, 15991f, 18315f, 20189f)\nval high = listOf(18252f, 19912f, 19001f, 21540f, 18770f, 20945f, 23007f)\nval mid = low.zip(high).map { (it.second + it.first) / 2 }\n\nplot {\n    x(day) { axis.name = \"day of week\" }\n    y {\n        axis.name = \"price\"\n        scale = continuous(15000f..24000f)\n    }\n    line {\n        y(mid)\n        color = Color.GREEN\n        type = LineType.DOTTED\n        width = 2.0\n    }\n    ribbon {\n        yMin(low)\n        yMax(high)\n        borderLine.color = Color.BLUE\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Several-Ribbons/","title":"Several Ribbons","text":"<p> Explore 'Several Ribbons' in Kotlin using Kandy to see how multiple ribbon plots can be combined for comparative data analysis. This example skillfully illustrates the overlaying of different currencies change data in a single chart for a comprehensive view. </p> <p> 'Several Ribbons' in Kotlin with Kandy: A demonstration of layering multiple ribbon plots, ideal for juxtaposing varied data sets in an insightful and visually appealing manner. </p> <p> Dive into 'Several Ribbons' using Kotlin and Kandy, a sophisticated example of blending multiple ribbon plots, perfect for in-depth comparative data visualization. </p> <p> <pre><code>val times = listOf(\"00:00\", \"06:00\", \"12:00\", \"18:00\", \"24:00\")\nval btcMin = listOf(310, 225, 202, 278, 360)\nval btcMax = listOf(334, 307, 243, 293, 388)\nval ethMin = listOf(180, 205, 256, 300, 280)\nval ethMax = listOf(210, 234, 299, 322, 331)\n\nval dataset = dataFrameOf(\n    \"time\" to times + times,\n    \"min\" to btcMin + ethMin,\n    \"max\" to btcMax + ethMax,\n    \"currency\" to List(5) { \"btc\" } + List(5) { \"eth\" }\n)\n\ndataset.groupBy(\"currency\").plot {\n    ribbon {\n        x(\"time\")\n        y {\n            limits = 170..400\n            axis.name = \"price, tokens\"\n        }\n        yMin(\"min\")\n        yMax(\"max\")\n        fillColor(\"currency\") {\n            legend.breaksLabeled(\"btc\" to \"Bubble Tea\\nCoin\", \"eth\" to \"E-Traders\\nHedgehogs\")\n        }\n        alpha = 0.6\n        borderLine.width = 0.0\n    }\n}\n</code></pre> <p> <pre><code>val times = listOf(\"00:00\", \"06:00\", \"12:00\", \"18:00\", \"24:00\")\nval btcMin = listOf(310, 225, 202, 278, 360)\nval btcMax = listOf(334, 307, 243, 293, 388)\nval ethMin = listOf(180, 205, 256, 300, 280)\nval ethMax = listOf(210, 234, 299, 322, 331)\n\nval dataset = mapOf(\n    \"time\" to times + times,\n    \"min\" to btcMin + ethMin,\n    \"max\" to btcMax + ethMax,\n    \"currency\" to List(5) { \"btc\" } + List(5) { \"eth\" }\n)\n\ndataset.plot {\n    groupBy(\"currency\") {\n        ribbon {\n            x(\"time\")\n            y {\n                limits = 170..400\n                axis.name = \"price, tokens\"\n            }\n            yMin(\"min\")\n            yMax(\"max\")\n            fillColor(\"currency\") {\n                legend.breaksLabeled(\"btc\" to \"Bubble Tea\\nCoin\", \"eth\" to \"E-Traders\\nHedgehogs\")\n            }\n            alpha = 0.6\n            borderLine.width = 0.0\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/ribbon/Simple-Ribbon/","title":"Simple Ribbon","text":"<p> Explore a simple ribbon plot creation with the 'Simple Ribbon' example using the Kandy library in Kotlin. </p> <p> 'Simple Ribbon' in Kotlin with Kandy: Effortlessly visualize min/max range trends in a clear ribbon plot. </p> <p> Check out 'Simple Ribbon' for an easy demonstration of ribbon chart plotting with Kandy in Kotlin. </p> <p> <pre><code>val xs by columnOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\nval mins by columnOf(0.2, 0.9, 0.55, 1.32, 2.2, 1.5)\nval maxs by columnOf(0.7, 1.4, 1.1, 2.1, 2.6, 2.2)\nval df = dataFrameOf(xs, mins, maxs)\n\ndf.plot {\n    ribbon {\n        x(xs)\n        yMin(mins)\n        yMax(maxs)\n    }\n}\n</code></pre> <p> <pre><code>val xs = listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0)\nval mins = listOf(0.2, 0.9, 0.55, 1.32, 2.2, 1.5)\nval maxs = listOf(0.7, 1.4, 1.1, 2.1, 2.6, 2.2)\n\nplot {\n    ribbon {\n        x(xs)\n        yMin(mins)\n        yMax(maxs)\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Basic-Heatmap/","title":"Basic Heatmap","text":"<p> Immerse in the basics of heatmap creation with 'Basic Heatmap' in Kandy. This example provides a straightforward approach to visualizing matrix data through color intensity variations. </p> <p> Get a grasp of heatmap fundamentals in 'Basic Heatmap' using Kandy. This example demonstrates the power of visualizing complex data in a simple, color-coded format. </p> <p> Dive into the world of heatmaps with 'Basic Heatmap' in Kandy. This introductory example showcases how to effectively represent matrix data using color gradients. </p> <pre><code>val random = kotlin.random.Random(42)\nval cols = (List(20) { \"col1\" } + List(50) { \"col2\" } + List(70) { \"col3\" }).shuffled(random)\nval rows = (List(40) { \"row1\" } + List(80) { \"row2\" } + List(20) { \"row3\" }).shuffled(random)\n\nplot {\n    heatmap(cols, rows)\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Basic-Tile-Plot/","title":"Basic Tile Plot","text":"<p> Discover the power of heatmaps with 'Basic Tile Plot' in Kandy. This example illustrates how tile plots can be used to visualize data patterns and densities effectively. </p> <p> Visualize data density and patterns with 'Basic Tile Plot' in Kandy, a compelling example of heatmap utilization. </p> <p> Explore data visualization through heatmaps with 'Basic Tile Plot' in Kandy, offering clear insights into data patterns and densities. </p> <pre><code>plot {\n    tiles {\n        x(listOf(\"A\", \"B\"))\n        y(listOf(1.0, 2.0))\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Fixed-Tiles/","title":"Fixed Tiles Coordinate","text":"<p> Discover the precision of 'Fixed Tiles Coordinate' in Kandy. This example demonstrates how to effectively anchor tile plots, ensuring consistent and accurate data representation. </p> <p> Learn the art of precise tile plot positioning with 'Fixed Tiles Coordinate' in Kandy, enhancing data clarity and consistency. </p> <p> Master accurate heatmap plotting with 'Fixed Tiles Coordinate' in Kandy, perfect for ensuring data precision in your visualizations. </p> <pre><code>val ys = listOf(\"a\", \"b\", \"c\", \"d\")\n\nplot {\n    tiles {\n        x.constant(0.0)\n        y(ys)\n        alpha = 0.4\n        fillColor = Color.PEACH\n        borderLine.width = 0.5\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Tiles-Color-Categories/","title":"Tiles with Color by Category","text":"<p> Discover the colorful insights of 'Tiles with Color by Category' in Kandy. This example demonstrates the effective use of categorical colors in tile plots for enhanced data categorization. </p> <p> Explore categorical color schemes in 'Tiles with Color by Category' using Kandy. This example illustrates how different hues can categorize data in tile plots. </p> <p> Learn about categorical color usage in tile plots with 'Tiles with Color by Category' in Kandy. This example highlights how color enhances data differentiation. </p> <p> <pre><code>val cities = listOf(\"Yerevan\", \"Berlin\", \"Amsterdam\", \"Paphos\")\nval types = listOf(\"A\", \"B\", \"C\")\nval random = kotlin.random.Random(42)\nval year22 = List(4) { types.random(random) }\nval year23 = List(4) { types.random(random) }\nval year24 = List(4) { types.random(random) }\n\nval dataset = dataFrameOf(\n    \"city\" to cities,\n    \"2022\" to year22,\n    \"2023\" to year23,\n    \"2024\" to year24\n).gather(\"2022\", \"2023\", \"2024\").into(\"year\", \"value\")\n\nplot(dataset) {\n    tiles {\n        x(\"city\")\n        y(\"year\") {\n            scale = categorical()\n            axis.breaks(format = \"d\")\n        }\n        width = 0.5\n        height = 0.9\n        fillColor(\"value\") {\n            legend.breaks(types)\n        }\n    }\n}\n</code></pre> <p> <pre><code>val types = listOf(\"A\", \"B\", \"C\")\nval cities = listOf(\"Yerevan\", \"Berlin\", \"Amsterdam\", \"Paphos\")\nval years = listOf(2022, 2023, 2024)\nval random = kotlin.random.Random(42)\nval tripples = cities.flatMap { city -&gt;\n    years.map { year -&gt; (city to year) to types.random(random) }\n}\n\nval (cityToYear, value) = tripples.unzip()\nval (city, year) = cityToYear.unzip()\n\nplot {\n    tiles {\n        x(city)\n        y(year) {\n            scale = categorical()\n            axis.breaks(format = \"d\")\n        }\n        width = 0.5\n        height = 0.9\n        fillColor(value) {\n            legend.breaks(types)\n        }\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Tiles-Gradient/","title":"Tiles Gradient","text":"<p> Enhance your data visualization skills with 'Tiles Gradient' in Kandy. This example showcases how gradient colors can be used to represent varying data intensities in tile plots. </p> <p> 'Tiles Gradient' in Kandy \u2014 a striking example of using gradients to convey data intensity in tile plots. </p> <p> Delve into 'Tiles Gradient' in Kandy, where gradients bring a new dimension to data representation in tile plots. </p> <p> <pre><code>val cities = listOf(\"Yerevan\", \"Berlin\", \"Amsterdam\", \"Paphos\")\nval random = kotlin.random.Random(42)\nval year22 = List(4) { random.nextDouble() }\nval year23 = List(4) { random.nextDouble() }\nval year24 = List(4) { random.nextDouble() }\n\nval dataset = dataFrameOf(\n    \"city\" to cities,\n    \"2022\" to year22,\n    \"2023\" to year23,\n    \"2024\" to year24\n).gather(\"2022\", \"2023\", \"2024\").into(\"year\", \"value\")\n\ndataset.plot {\n    tiles {\n        x(\"city\")\n        y(\"year\") {\n            scale = categorical()\n            axis.breaks(format = \"d\")\n        }\n        fillColor(\"value\")\n    }\n}\n</code></pre> <p> <pre><code>val cities = listOf(\"Yerevan\", \"Berlin\", \"Amsterdam\", \"Paphos\")\nval random = kotlin.random.Random(42)\nval year22 = List(4) { random.nextDouble() }\nval year23 = List(4) { random.nextDouble() }\nval year24 = List(4) { random.nextDouble() }\n\nval dataset = mapOf(\n    \"city\" to cities + cities + cities,\n    \"year\" to List(4) { \"2022\" } + List(4) { \"2023\" } + List(4) { \"2024\" },\n    \"value\" to year22 + year23 + year24,\n)\n\ndataset.plot {\n    tiles {\n        x(\"city\")\n        y(\"year\") {\n            scale = categorical()\n            axis.breaks(format = \"d\")\n        }\n        fillColor(\"value\")\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Tiles-Logo/","title":"Ktnb Logo Tiles","text":"<p> Experience creative data visualization with 'Ktnb Logo Tiles' in Kandy. This unique example artfully combines the use of tiles to form the Ktnb logo, showcasing the versatility of data representation. </p> <p> 'Ktnb Logo Tiles' in Kandy artfully demonstrates how tiles can be used to create visually striking patterns and images, like the Ktnb logo, offering a novel take on data visualization. </p> <p> Explore the artistic side of data with 'Ktnb Logo Tiles' in Kandy. This imaginative example uses tile plots to form the Ktnb logo, highlighting innovative ways to present data. </p> <pre><code>val zipperCells = (0 until 40).flatMap { x -&gt;\n    val n = 3\n    val sector = if (x &lt;= 15) {\n        0\n    } else if (x &lt;= 23) {\n        1\n    } else 2\n    when (sector) {\n        0 -&gt; {\n            (0 until n).map { y -&gt; x to x + (x - 1) / 2 + y }\n        }\n\n        1 -&gt; {\n            (0 until n).map { y -&gt; x to 38 - x + y }\n        }\n\n        else -&gt; {\n            (0 until n).map { y -&gt; x to x - 11 + (x - 19) / 2 + y }\n        }\n    }\n}\n\nval cells = (0 until 40).flatMap { x -&gt; (0 until 40).map { y -&gt; x to y } }.filter {\n    it !in zipperCells\n}\n\nval xs = cells.map { it.first }\nval ys = cells.map { it.second }\nval colorFactor = xs.zip(ys).map { it.first + it.second }\n\nplot {\n    tiles {\n        x(xs)\n        y(ys)\n        fillColor(colorFactor) {\n            scale = continuous(Color.hex(\"#7d52fc\")..Color.hex(\"#e34860\"))\n            legend.type = LegendType.None\n        }\n    }\n    layout {\n        theme(Theme.Classic) {\n            blankAxes()\n        }\n    }\n}\n</code></pre> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/docs/topics/samples/tiles/Tiles-Settings/","title":"Tiles Settings","text":"<p> Enhance your heatmap skills with 'Tiles Settings' in Kandy. This example showcases advanced techniques in tile plot customization for more informative and visually appealing data presentations. </p> <p> Advance your heatmap capabilities with 'Tiles Settings' in Kandy, featuring in-depth customization options for tile plots. </p> <p> Dive into sophisticated heatmap customizations with 'Tiles Settings' in Kandy, perfect for elevating your data visualization techniques. </p> <p> <pre><code>val dataset = dataFrameOf(\n    \"store\" to listOf(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"),\n    \"time\" to listOf(\n        \"morning\", \"morning\", \"morning\",\n        \"afternoon\", \"afternoon\", \"afternoon\",\n        \"evening\", \"evening\", \"evening\"\n    ),\n    \"money\" to listOf(75, 64, 59, 82, 88, 91, 69, 77, 73)\n)\n\ndataset.plot {\n    tiles {\n        x(\"store\")\n        y(\"time\")\n        height = 0.7\n        borderLine {\n            width = 0.8\n            color = Color.BLACK\n        }\n        fillColor(\"money\") {\n            scale = continuous(Color.RED..Color.GREEN)\n        }\n        alpha = 0.5\n    }\n}\n</code></pre> <p> <pre><code>val store = listOf(\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\")\nval time = listOf(\n    \"morning\", \"morning\", \"morning\",\n    \"afternoon\", \"afternoon\", \"afternoon\",\n    \"evening\", \"evening\", \"evening\"\n)\nval money = listOf(75, 64, 59, 82, 88, 91, 69, 77, 73)\n\nplot {\n    tiles {\n        x(store)\n        y(time)\n        height = 0.7\n        borderLine {\n            width = 0.8\n            color = Color.BLACK\n        }\n        fillColor(money) {\n            scale = continuous(Color.RED..Color.GREEN)\n        }\n        alpha = 0.5\n    }\n}\n</code></pre> <p></p> <p> { border-effect=\"rounded\" }</p> <p> GitHub Notebook Datalore Notebook </p>"},{"location":"kandy/examples/","title":"Examples of Kandy","text":""},{"location":"kandy/examples/#table-of-contents","title":"Table of Contents","text":"<ul> <li>User Guide</li> <li>IDEA Examples</li> <li>Notebook Examples<ul> <li>Line</li> <li>Area</li> <li>Bars</li> <li>Points</li> <li>Error Bars</li> <li>Boxplot</li> <li>Tiles</li> <li>Histogram</li> <li>Density Plot</li> <li>Count Plot</li> <li>Heatmap</li> <li>Layout</li> </ul> </li> </ul>"},{"location":"kandy/examples/#user-guide","title":"User Guide","text":"<ul> <li>Quick Start Guide \u2014 Notebook / Datalore</li> <li>Geoms<ul> <li>Algebraic Curve \u2014 Notebook / Datalore</li> <li>ErrorBars \u2014 Notebook / Datalore</li> <li>Jitter Points \u2014 Notebook / Datalore</li> <li>Lines \u2014 Notebook / Datalore</li> <li>Pie \u2014 Notebook / Datalore</li> <li>Ribbon \u2014 Notebook / Datalore</li> <li>Scatter \u2014 Notebook / Datalore</li> </ul> </li> <li>Statistical<ul> <li>Statistics Guide \u2014 Notebook / Datalore</li> <li>Smoothing \u2014 Notebook / Datalore</li> <li>Histogram \u2014 Notebook / Datalore</li> <li>Boxplot \u2014 Notebook / Datalore</li> <li>Heatmap \u2014 Notebook / Datalore</li> <li>Count Plot \u2014 Notebook / Datalore</li> <li>Density Plot \u2014 Notebook / Datalore</li> </ul> </li> <li>Multiplot<ul> <li>Anscombe's quartet \u2014 Notebook / Datalore</li> <li>Facets \u2014 Notebook / Datalore</li> <li>Plot Bunch \u2014 Notebook / Datalore</li> </ul> </li> <li>Layout customization<ul> <li>Formatting \u2014 Notebook / Datalore</li> <li>Legend and Axis \u2014 Notebook / Datalore</li> <li>Themes \u2014 Notebook / Datalore</li> <li>Title, subtitle, and caption \u2014 Notebook / Datalore</li> <li>Tooltips \u2014 Notebook / Datalore</li> </ul> </li> <li>Other guides<ul> <li>Export to File \u2014 Notebook / Datalore</li> <li>Kotlin Notebook Features \u2014 Notebook / Datalore</li> <li>Series Hack \u2014 Notebook / Datalore</li> </ul> </li> </ul>"},{"location":"kandy/examples/#idea-examples","title":"IDEA examples","text":"<p>lets-plot-simple \u2014 The following is an example of using the <code>kandy-lets-plot</code> library in an IntelliJ IDEA project.</p> <p>echarts-simple \u2014 The following is an example of using the <code>kandy-echarts</code> library in an IntelliJ IDEA project.</p>"},{"location":"kandy/examples/#notebook-examples","title":"Notebook Examples","text":""},{"location":"kandy/examples/#line","title":"Line","text":"Simple Line Line Settings Line with Points Fixed Line Coordinate Line Gradient Line with Reversed Axis Several Lines Functional Line Plot Marked Line Path Line Step Line Smoothed Line Smoothed Curve with Points Comparing Line vs. Path Plots"},{"location":"kandy/examples/#area","title":"Area","text":"Simple Area Area Settings Area with Fixed Coordinate Area with Reversed Axis Several Areas Functional Area Plot Area with Mark Line Smoothed Area Smoothed Area with Points Density Plot"},{"location":"kandy/examples/#bars","title":"Bars","text":"Simple Bar Bar Settings Bar Gradient Fixed Bar Coordinate Bar with Reversed Axis Horizontal Bars Grouped Bars Stacked Bars Functional Bar Plot Histogram Plot"},{"location":"kandy/examples/#points","title":"Points","text":"Basic Points Plot Points Settings Points with ABLine Points Gradient Points with Color by Category Fixed Points Coordinate Jittered Points Bubble Chart Complex Bubble Chart Functional Scatter Plot"},{"location":"kandy/examples/#error-bars","title":"Error Bars","text":"Simple ErrorBars ErrorBars Settings ErrorBars with Line Fixed ErrorBars Coordinate BorderLine in ErrorBars Grouped ErrorBars ErrorBars with Boxplot"},{"location":"kandy/examples/#ribbon","title":"Ribbon","text":"Simple Ribbon Ribbon Settings Ribbon with Line Several Ribbons Function Ribbon Graph Regression Confidence Band"},{"location":"kandy/examples/#boxplot","title":"Boxplot","text":"Boxplot of Experiments Boxplot Life Expectations by Country Boxplot Categories"},{"location":"kandy/examples/#tiles","title":"Tiles","text":"Basic Tile Plot Tiles Settings Fixed Tiles Coordinate Tiles Gradient Tiles with Color by Category Basic Heatmap Ktnb Logo Tiles"},{"location":"kandy/examples/#histogram","title":"Histogram","text":"Histogram Simple Histogram Settings Histogram Grouped Histogram With Line"},{"location":"kandy/examples/#density-plot","title":"Density Plot","text":"Density Plot Simple Density Plot Settings Density Plot Grouped Density Plot With Histogram"},{"location":"kandy/examples/#count-plot","title":"Count Plot","text":"Count Plot Simple Count Plot Settings Count Plot Grouped Count Plot Horizontal"},{"location":"kandy/examples/#heatmap","title":"Heatmap","text":"Heatmap Simple Heatmap Settings"},{"location":"kandy/examples/#layout","title":"Layout","text":"Base Layout Settings Subtitle And Caption Axis And Legend Configuration"},{"location":"lets-plot/","title":"Lets-Plot Kotlin API","text":"<p>Lets-Plot Kotlin API is a Kotlin API for Lets-Plot Multiplatform   plotting library, \\ which is built on the principles of layered graphics first described in the \\ Leland Wilkinson work The Grammar of Graphics.</p> <p>Lets-Plot Kotlin API is largely based on the APIprovided by              ggplot2 package well-known to data scientists who use R.</p> <p>To learn more about the Grammar of Graphics,we recommend an excellent book called \u201cggplot2: Elegant Graphics for Data Analysis\u201d.</p> <p>This will be a good prerequisite for further exploration of the Lets-Plot library.</p> <p></p>"},{"location":"lets-plot/#quickstart","title":"Quickstart","text":"<p>Inside Kotlin Notebook, Datalore or Jupyter with Kotlin Kernel:</p> <pre><code>%use lets-plot\n</code></pre> <pre><code>val rand = java.util.Random()\nval data = mapOf(\n    \"rating\" to List(200) { rand.nextGaussian() } + List(200) { rand.nextGaussian() * 1.5 + 1.5 },\n    \"cond\" to List(200) { \"A\" } + List(200) { \"B\" }\n)\n\nvar p = letsPlot(data)\np += geomDensity(color = \"dark_green\", alpha = .3) { x = \"rating\"; fill = \"cond\" }\np + ggsize(700, 350)\n</code></pre> <p> </p> <p>See the \"Quickstart\" notebook in Datalore or Jupyter nbviewer.</p> <p></p>"},{"location":"lets-plot/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Usage</li> <li>Notebooks</li> <li>Compose Multiplatform</li> <li>JVM and Kotlin/JS</li> <li>Documentation</li> <li>What is new in 4.6.0</li> <li>Change Log</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"lets-plot/#usage","title":"Usage","text":""},{"location":"lets-plot/#notebooks","title":"Notebooks","text":"<p>With the help of Lets-Plot Kotlin API you can easily create plots in Kotlin Notebook, Datalore, Jupyter with Kotlin Kernel \\ or any other notebook that supports <code>Kotlin Kernel</code>.</p>"},{"location":"lets-plot/#line-magics","title":"\"Line Magics\"","text":"<p><pre><code>%use lets-plot\n</code></pre> This \"line magic\" will apply Lets-Plot library descriptor which adds to your notebook all the boilerplate code necessary to create plots.</p> <p>By default, <code>library descriptor</code> is bundled with the Kotlin Jupyter Kernel installed in your environment. \\ However, you can override the default settings using: <pre><code>%useLatestDescriptors\n</code></pre> In this case the latest <code>library descriptor</code> will be pulled from the Kotlin Jupyter Libraries repository.</p>"},{"location":"lets-plot/#library-descriptor-parameters","title":"Library Descriptor Parameters","text":"<p><pre><code>%use lets-plot(api=4.6.0, lib=4.2.0, js=4.2.0, isolatedFrame=false)\n</code></pre> - <code>api</code> - version of the Lets-Plot Kotlin API. - <code>lib</code> - version of the Lets-Plot Multiplatform (JARs). - <code>js</code>  - version of the Lets-PLot Multiplatform JavaScript bundle. - <code>isolatedFrame</code> - If <code>false</code>: load JS just once per notebook (default in Jupyter).   If <code>true</code>: include Lets-Plot JS in each output (default in Datalore notebooks).</p> <p></p>"},{"location":"lets-plot/#compose-multiplatform","title":"Compose Multiplatform","text":"<p>To learn how to embed Lets-Plot charts in Compose Multiplatform applications, please check out the Lets-Plot Skia Frontend project.</p> <p></p>"},{"location":"lets-plot/#jvm-and-kotlinjs","title":"JVM and Kotlin/JS","text":"<p>To learn more about creating plots in JVM or Kotlin/JS environment please read USAGE_SWING_JFX_JS.md. </p>"},{"location":"lets-plot/#examples","title":"Examples","text":"<p>Examples of using of the Lets-Plot Kotlin API in JVM and Kotlin/JS applications are available in the Lets-Plot Kotlin Mini Apps (Demos) GitHub repository.</p> <p></p>"},{"location":"lets-plot/#documentation","title":"Documentation","text":"<ul> <li> <p>A quick introduction to the Grammar of Graphics and Lets-Plot Kotlin API: Lets-Plot Usage Guide </p> </li> <li> <p>Lets-Plot Kotlin API docs: docs/README.md</p> </li> <li> <p>Lets-Plot Kotlin API reference: https://lets-plot.org/kotlin</p> </li> <li> <p>The \"Example Notebooks\" reference: examples.md</p> </li> <li> <p>Example notebooks in the Binder: mybinder.org</p> </li> </ul> <p></p>"},{"location":"lets-plot/#what-is-new-in-460","title":"What is new in 4.6.0","text":"<p>See: example notebook.</p> <p> </p> <p>See: example notebook.</p> <p>See: example notebook.</p> <p> </p> <p>See: example notebook.</p> <ul> <li> <p><code>scaleXLog2()</code>, <code>scaleYLog2()</code></p> </li> <li>New variables computed by <code>'count'</code> and <code>'count2d'</code> statistics: <code>'..sumprop..'</code>, <code>'..sumpct..'</code>.     See: example notebook.</li> <li>Support using dictionaries for breaks/labels/values customization in <code>scaleXxx()</code> functions.     See: example notebook.</li> <li>The <code>lablim</code> parameter in <code>scaleXxx()</code> functions.     See: example notebook.</li> <li><code>labelText</code> parameter in <code>theme()</code> for annotation text settings.     See: example notebook.</li> <li>NumberFormat: new flag <code>~</code> to trim trailing zeros.</li> </ul> <p></p>"},{"location":"lets-plot/#support-for-categoricals-the-levels-parameter-in-asdiscrete","title":"Support for <code>\"Categoricals\"</code>: the <code>levels</code> parameter in <code>asDiscrete()</code>","text":""},{"location":"lets-plot/#superscript-for-numbers-in-scientific-notation","title":"Superscript for Numbers in Scientific Notation","text":""},{"location":"lets-plot/#sharing-of-xy-scale-limits-between-subplots-in-gggrid","title":"Sharing of X,Y-scale Limits Between Subplots in <code>gggrid()</code>","text":""},{"location":"lets-plot/#geomspoke","title":"<code>geomSpoke()</code>","text":""},{"location":"lets-plot/#other-new-features-and-improvements","title":"Other New Features and Improvements","text":""},{"location":"lets-plot/#change-log","title":"Change Log","text":"<p>See CHANGELOG.md.</p> <p></p>"},{"location":"lets-plot/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and the corresponding community are governed by the  JetBrains Open Source and Community Code of Conduct.  Please make sure you read it.</p> <p></p>"},{"location":"lets-plot/#license","title":"License","text":"<p>Code and documentation released under the MIT license. Copyright \u00a9 2019-2024, JetBrains s.r.o.</p>"},{"location":"lets-plot/demo/js-frontend-app/","title":"Index","text":""},{"location":"lets-plot/demo/js-frontend-app/#lets-plot-in-kotlin-js-frontend","title":"Lets-PLot in Kotlin JS frontend","text":"<p>To run this app use the <code>browserDevelopmentRun</code> or <code>browserProductionRun</code> task:</p> <pre><code>./gradlew build\n\n./gradlew :js-frontend-app:jsBrowserDevelopmentRun\n</code></pre>"},{"location":"lets-plot/docs/","title":"Index","text":""},{"location":"lets-plot/docs/#lets-plot-kotlin-api","title":"Lets-Plot Kotlin API","text":"<ul> <li> <p>Lets-Plot Kotlin API reference: https://lets-plot.org/kotlin</p> </li> <li> <p>The \"Example Notebooks\" reference: examples.md</p> </li> <li> <p>Example notebooks in the Binder: mybinder.org</p> </li> </ul> <p></p>"},{"location":"lets-plot/docs/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Tooltip Customization</li> <li>Formatting</li> <li>Data Sampling</li> <li>Saving Plot in a File</li> <li>GeoTools Support</li> </ul>"},{"location":"lets-plot/docs/#tooltip-customization","title":"Tooltip Customization","text":"<p>You can customize the content, values formatting and appearance of tooltip for any geometry layer in your plot.</p> <p>Learn more: Tooltip Customization.</p> <p></p>"},{"location":"lets-plot/docs/#formatting","title":"Formatting","text":"<p>Formatting of numeric and date-time values in tooltips, legends, on the axes and text geometry layer.</p> <p>Learn more: Formatting.</p> <p></p>"},{"location":"lets-plot/docs/#data-sampling","title":"Data Sampling","text":"<p>Sampling is a special technique of data transformation, which helps to deal with large datasets and overplotting.</p> <p>Learn more: Data Sampling.</p> <p></p>"},{"location":"lets-plot/docs/#saving-plot-in-a-file","title":"Saving Plot in a File","text":"<p>The <code>ggsave()</code> function is a convenient way of saving a plot or a GGBunch object in a file.</p> <p>The supported export formats are: <code>SVG, HTML, PNG, JPEG and TIFF</code>.</p> <p>For example, the code below will save plot as a PNG image in the file <code>&lt;user dir&gt;//lets-plot-images/density.png</code>:</p> <pre><code>val rand = java.util.Random(123)\nval n = 400\nval data = mapOf (\n    \"rating\" to List(n/2) { rand.nextGaussian() } + List(n/2) { rand.nextGaussian() * 1.5 + 1.5 },\n    \"cond\" to List(n/2) { \"A\" } + List(n/2) { \"B\" }\n)\n\nvar p = letsPlot(data) +\n        geomDensity { x = \"rating\"; color = \"cond\" } + ggsize(500, 250)\n\nggsave(p, \"density.png\")        \n</code></pre> <p></p> <p>See <code>ggsave()</code> documentation for more information about the function arguments and default values.</p> <p>Example notebook: ggsave demo.</p> <p></p>"},{"location":"lets-plot/docs/#geotools-support","title":"GeoTools support","text":"<p>GeoTools is an open source Java GIS Toolkit.</p> <p>Lets-Plot supports visualization of a set of <code>SimpleFeature</code>-s stored in <code>SimpleFeatureCollection</code>, as well as individual <code>Geometry</code> and <code>ReferencedEnvelope</code> objects.</p> <p>Learn more: GeoTools Support.</p>"},{"location":"kalasim/","title":"kalasim","text":"<p>Discrete Event Simulator</p> <p> </p> <p><code>kalasim</code> is a discrete event simulator. It provides a statically typed API, dependency injection, modern persistence, structured logging and automation capabilities.</p> <p>kalasim is designed for simulation practitioners, process analysts and industrial engineers, who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases.</p> <p>In contrast to many other simulation tools, <code>kalasim</code> is neither low-code nor no-code. It is code-first to enable change tracking, scaling, refactoring, CI/CD, unit-tests, and the rest of the gang that makes simulation development fun.</p>"},{"location":"kalasim/#documentation","title":"Documentation","text":"<p>All docs are hosted under http://www.kalasim.org/</p>"},{"location":"kalasim/modules/animation/","title":"OPENRNDR Examples","text":""},{"location":"kalasim/modules/animation/#how-to-run","title":"How to run?","text":"<p>TODO </p>"},{"location":"kalasim/modules/animation/#image-attributions","title":"Image Attributions","text":"<ul> <li>office tower was licensed under Creative Commons Attribution-Share Alike 4.0 International on wikimedia </li> </ul>"},{"location":"kalasim/modules/benchmarks/","title":"Benchmarks","text":"<p>Objective</p> <p>A benchmark suite to track kalasim performance over time, and to enable library optimization</p> <p>For gradle plugin options see https://github.com/melix/jmh-gradle-plugin</p>"},{"location":"kalasim/modules/benchmarks/#how-to-run","title":"How to run?","text":"<ul> <li>This will execute all (methods annotated with <code>@Benchmark</code>) benchmarks with their predefined parameters:</li> </ul> <pre><code># cd /d/projects/scheduling/kalasim/modules/benchmarks\n./gradlew --console=plain clean jmh`\n</code></pre> <ul> <li>Output is saved as CSV in <code>benchmarks/build/results/jmh/results.csv</code></li> </ul>"},{"location":"kalasim/modules/benchmarks/#how-to-build-report","title":"How to build report","text":""},{"location":"kalasim/modules/benchmarks/#how-is-repo-history-preserved","title":"How is repo history preserved?","text":""},{"location":"kalasim/modules/benchmarks/#run-directly","title":"Run directly","text":"<p>A bit clunky but gives more control over parameters and what is actually getting executed </p> <ul> <li> <p>Display command line options: <pre><code>cd benchmarks$\n./gradlew jar\njava -jar build/libs/benchmarks-jmh.jar -h`\n</code></pre></p> </li> <li> <p>Run specific benchmark(s) with specific parameters:  <pre><code>cd benchmarks\njava -jar build/libs/benchmarks-jmh.jar -wi 2 -i 2 -f 1 -tu ms -bm avgt CompressedTsvBenchmarks\n\njava -jar build/libs/benchmarks-jmh.jar  org.kalasim.benchmarks.FabBench\n</code></pre></p> </li> </ul>"},{"location":"kalasim/modules/benchmarks/#references","title":"References","text":"<p>https://github.com/Kotlin/kotlinx-benchmark</p> <p>https://howtodoinjava.com/java/library/jmh-java-microbenchmark-harness/</p>"},{"location":"kalasim/modules/benchmarks/#how-to-automate-benchmarking-as-part-of-the-release-process","title":"How to automate benchmarking as part of the release process?","text":"<p>Idea:  * use https://github.com/gradle/gradle-build-action to run the benchmark and then add the result file back to the repo via https://github.com/orgs/community/discussions/25234 * Next, we could also automate the reporting with https://www.simonpcouch.com/blog/r-github-actions-commit/. Other nice tutorial https://www.rforseo.com/ressources/launch-an-r-script-using-github-actions</p>"},{"location":"kalasim/modules/json/","title":"Web Interface for simulation","text":"<p>8080</p>"},{"location":"kalasim/modules/json/#how-to-run","title":"How to run?","text":""},{"location":"kalasim/modules/json/#references","title":"References","text":"<p>Spring Boot with echarts * https://github.com/jinzita007/spring-boot-echarts * nice recent walkthrough https://www.wimdeblauwe.com/blog/2021/01/05/usig-google-charts-with-thymeleaf/ * https://echarts.apache.org/examples/en/index.html * site map https://echarts.apache.org/examples/en/editor.html?c=geo-seatmap-flight * simple echarts spring-boot https://asbnotebook.com/google-chart-example-with-spring-boot/ * data via rest https://medium.com/thinkspecial/play-time-with-d3js-springboot-and-mongodb-35bdf1d2faef</p>"},{"location":"kalasim/modules/k5/","title":"K5 Examples","text":"<p>https://github.com/CuriousNikhil/k5-compose</p>"},{"location":"kalasim/modules/k5/#how-to-run","title":"How to run?","text":"<p>TODO </p>"},{"location":"kalasim/modules/logistics/","title":"Logistics ToolBox","text":"<p>An extension module for <code>kalasim</code> to enable process simulations involving in the movement and coordination of resources. This includes logistics networks, supply chains, and resource management.</p>"},{"location":"kalasim/modules/logistics/#how-to-run","title":"How to run?","text":"<p>Simply add it as dependency via gradle/maven with <pre><code>implementation \"com.github.holgerbrandl:kalasim:X.Y.Z\"\n</code></pre></p> <p>It includes the base library of kalasim as transitive dependency.</p>"},{"location":"kalasim/modules/webui/","title":"Web Interface for simulation","text":"<p>8080</p>"},{"location":"kalasim/modules/webui/#how-to-run","title":"How to run?","text":""},{"location":"kalasim/modules/webui/#references","title":"References","text":"<p>Spring Boot with echarts * https://github.com/jinzita007/spring-boot-echarts * nice recent walkthrough https://www.wimdeblauwe.com/blog/2021/01/05/usig-google-charts-with-thymeleaf/ * https://echarts.apache.org/examples/en/index.html * site map https://echarts.apache.org/examples/en/editor.html?c=geo-seatmap-flight * simple echarts spring-boot https://asbnotebook.com/google-chart-example-with-spring-boot/ * data via rest https://medium.com/thinkspecial/play-time-with-d3js-springboot-and-mongodb-35bdf1d2faef</p>"},{"location":"kalasim/simulations/","title":"Example Simulations","text":"<p>In addition to the documentation examples that do not have additional dependencies, we also provide more complex examples in here</p> <p>{tbd} list them here</p>"},{"location":"kalasim/simulations/covid19-openrndr/","title":"Covid19","text":"<p>A kalasim simulation to simulate contact, infections and spread of the virus.</p>"},{"location":"kalasim/simulations/covid19-openrndr/#references","title":"References","text":"<p>https://www.youtube.com/watch?v=dW6df7SdX-4</p>"},{"location":"kalasim/simulations/covid19-openrndr/#gradle-tasks","title":"Gradle tasks","text":"<ul> <li><code>run</code> runs the TemplateProgram</li> <li><code>jar</code> creates an executable platform specific jar file with all dependencies</li> <li><code>zipDistribution</code> creates a zip file containing the application jar and the data folder</li> <li><code>jpackageZip</code> creates a zip with a stand-alone executable for the current platform (works with Java 14 only)</li> </ul>"},{"location":"kalasim/simulations/covid19-openrndr/#cross-builds","title":"Cross builds","text":"<p>To create runnable jars for a platform different from the platform you use to build one uses <code>./gradlew jar --PtargetPlatform=&lt;platform&gt;</code>. The supported platforms are <code>windows</code>, <code>macos</code>, <code>linux-x64</code> and <code>linux-arm64</code>. Note that the <code>linux-arm64</code> platform will only work with OPENRNDR snapshot builds from master and OPENRNDR 0.3.39 (a future version).</p>"},{"location":"kalasim/simulations/fsmsim/","title":"Index","text":""},{"location":"kalasim/simulations/fsmsim/#references","title":"References","text":"<p>See overview presentation https://speakerdeck.com/corneil/kfsm-a-kotlin-dsl-for-finite-state-machines or project website https://open.jumpco.io/projects/kfsm</p> <p>Most popular FSM library https://github.com/statelyai/xstate (javascript)</p> <p>Great conceptual overview https://flaviocopes.com/finite-state-machines/</p>"},{"location":"kalasim/simulations/fsmsim/#nice-examples","title":"Nice Examples","text":"<p>Pedestrian Crossing https://www.hackster.io/robin-herrmann/traffic-lights-using-finite-state-machine-in-c-for-arduino-26169c</p> <p></p> <p>https://flaviocopes.com/finite-state-machines/</p> <p>house, with one door, 2 buttons and 3 lights.</p> <p> </p>"},{"location":"kalasim/simulations/hospital/","title":"Index","text":"<pre><code>export KALASIM_HOME=/d/projects/scheduling/kalasim\ncd ${KALASIM_HOME}/simulations/hospital/\n\n# cmd.exe \"/K\" C:\\Users\\brandl\\Anaconda3\\Scripts\\activate.bat C:\\Users\\brandl\\Anaconda3\n\njupyter notebook --kernel=kotlin hospital.ipynb\n</code></pre>"},{"location":"kalasim/simulations/lunar-mining/","title":"Lunar Mining","text":"<p>See Lunar Mining in the manual.</p> <p>Resource agents scan the ground of the moon for depletable water  deposits.</p>"},{"location":"kalasim/simulations/lunar-mining/#image-references","title":"Image References","text":"<p>Surface Background </p> <p>harvester</p> <p>base</p>"},{"location":"dataframe/","title":"Kotlin Dataframe: typesafe in-memory structured data processing for JVM","text":"<p>Kotlin Dataframe aims to reconcile Kotlin's static typing with the dynamic nature of data by utilizing both the full power of the Kotlin language and the opportunities provided by intermittent code execution in Jupyter notebooks and REPL.   </p> <ul> <li>Hierarchical \u2014 represents hierarchical data structures, such as JSON or a tree of JVM objects.</li> <li>Functional \u2014 data processing pipeline is organized in a chain of <code>DataFrame</code> transformation operations. Every operation returns a new instance of <code>DataFrame</code> reusing underlying storage wherever it's possible.</li> <li>Readable \u2014 data transformation operations are defined in DSL close to natural language.</li> <li>Practical \u2014 provides simple solutions for common problems and the ability to perform complex tasks.</li> <li>Minimalistic \u2014 simple, yet powerful data model of three column kinds.</li> <li>Interoperable \u2014 convertable with Kotlin data classes and collections.</li> <li>Generic \u2014 can store objects of any type, not only numbers or strings.</li> <li>Typesafe \u2014 on-the-fly generation of extension properties for type safe data access with Kotlin-style care for null safety.</li> <li>Polymorphic \u2014 type compatibility derives from column schema compatibility. You can define a function that requires a special subset of columns in dataframe but doesn't care about other columns.</li> </ul> <p>Integrates with Kotlin kernel for Jupyter. Inspired by krangl, Kotlin Collections and pandas</p>"},{"location":"dataframe/#documentation","title":"Documentation","text":"<p>Explore documentation for details.</p> <p>You could find the following articles there:</p> <ul> <li>Get started with Kotlin DataFrame</li> <li>Working with Data Schemas</li> <li>Full list of all supported operations<ul> <li>Reading from SQL databases</li> <li>Reading/writing from/to different file formats like JSON, CSV, Apache Arrow</li> <li>Joining a few dataframes</li> <li>GroupBy operation</li> </ul> </li> <li>Rendering to HTML</li> </ul>"},{"location":"dataframe/#setup","title":"Setup","text":""},{"location":"dataframe/#gradle-for-jvm","title":"Gradle for JVM","text":"<pre><code>// build.gradle\n\nplugins {\n    // Optional Gradle plugin for enhanced type safety and schema generation\n    // https://kotlin.github.io/dataframe/gradle.html\n    id 'org.jetbrains.kotlinx.dataframe' version '0.12.0'\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'org.jetbrains.kotlinx:dataframe:0.12.0'\n}\n</code></pre> <pre><code>// build.gradle.kts\n\nplugins {\n    // Optional Gradle plugin for enhanced type safety and schema generation\n    // https://kotlin.github.io/dataframe/gradle.html\n    id(\"org.jetbrains.kotlinx.dataframe\") version \"0.12.0\"\n}\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"org.jetbrains.kotlinx:dataframe:0.12.0\")\n}\n</code></pre>"},{"location":"dataframe/#gradle-for-android","title":"Gradle for Android","text":"<pre><code>// build.gradle\n\nplugins {\n    // Optional Gradle plugin for enhanced type safety and schema generation\n    // https://kotlin.github.io/dataframe/gradle.html\n    id 'org.jetbrains.kotlinx.dataframe' version '0.12.0'\n}\n\ndependencies {\n    implementation 'org.jetbrains.kotlinx:dataframe:0.12.0'\n}\n\nandroid {\n    defaultConfig {\n        minSdk 26 // Android O+\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n    packagingOptions {\n        resources {\n            pickFirsts = [\"META-INF/AL2.0\",\n                          \"META-INF/LGPL2.1\",\n                          \"META-INF/ASL-2.0.txt\",\n                          \"META-INF/LICENSE.md\",\n                          \"META-INF/NOTICE.md\",\n                          \"META-INF/LGPL-3.0.txt\"]\n            excludes = [\"META-INF/kotlin-jupyter-libraries/libraries.json\",\n                        \"META-INF/{INDEX.LIST,DEPENDENCIES}\",\n                        \"{draftv3,draftv4}/schema\",\n                        \"arrow-git.properties\"]\n        }\n    }\n}\n\n// optional, could be required for KSP\ntasks.withType(KotlinCompile).configureEach {\n    kotlinOptions {\n        jvmTarget = '1.8'\n    }\n}\n</code></pre> <pre><code>// build.gradle.kts\n\nplugins {\n    // Optional Gradle plugin for enhanced type safety and schema generation\n    // https://kotlin.github.io/dataframe/gradle.html\n    id(\"org.jetbrains.kotlinx.dataframe\") version \"0.12.0\"\n}\n\ndependencies {\n    implementation(\"org.jetbrains.kotlinx:dataframe:0.12.0\")\n}\n\nandroid {\n    defaultConfig {\n        minSdk = 26 // Android O+\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n    packaging {\n        resources {\n            pickFirsts += listOf(\n                \"META-INF/AL2.0\",\n                \"META-INF/LGPL2.1\",\n                \"META-INF/ASL-2.0.txt\",\n                \"META-INF/LICENSE.md\",\n                \"META-INF/NOTICE.md\",\n                \"META-INF/LGPL-3.0.txt\",\n            )\n            excludes += listOf(\n                \"META-INF/kotlin-jupyter-libraries/libraries.json\",\n                \"META-INF/{INDEX.LIST,DEPENDENCIES}\",\n                \"{draftv3,draftv4}/schema\",\n                \"arrow-git.properties\",\n            )\n        }\n    }\n}\n\n// required for KSP\ntasks.withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; {\n    kotlinOptions.jvmTarget = \"1.8\"\n}\n</code></pre>"},{"location":"dataframe/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>Install Kotlin kernel for Jupyter</p> <p>Import stable <code>dataframe</code> version into notebook:  <pre><code>%use dataframe\n</code></pre> or specific version: <pre><code>%use dataframe(&lt;version&gt;)\n</code></pre></p>"},{"location":"dataframe/#data-model","title":"Data model","text":"<ul> <li><code>DataFrame</code> is a list of columns with equal sizes and distinct names.</li> <li><code>DataColumn</code> is a named list of values. Can be one of three kinds:</li> <li><code>ValueColumn</code> \u2014 contains data</li> <li><code>ColumnGroup</code> \u2014 contains columns</li> <li><code>FrameColumn</code> \u2014 contains dataframes</li> </ul>"},{"location":"dataframe/#usage-example","title":"Usage example","text":"<p>Create: <pre><code>// create columns\nval fromTo by columnOf(\"LoNDon_paris\", \"MAdrid_miLAN\", \"londON_StockhOlm\", \"Budapest_PaRis\", \"Brussels_londOn\")\nval flightNumber by columnOf(10045.0, Double.NaN, 10065.0, Double.NaN, 10085.0)\nval recentDelays by columnOf(\"23,47\", null, \"24, 43, 87\", \"13\", \"67, 32\")\nval airline by columnOf(\"KLM(!)\", \"{Air France} (12)\", \"(British Airways. )\", \"12. Air France\", \"'Swiss Air'\")\n\n// create dataframe\nval df = dataFrameOf(fromTo, flightNumber, recentDelays, airline)\n\n// print dataframe\ndf.print()\n</code></pre></p> <p>Clean: <pre><code>// typed accessors for columns\n// that will appear during\n// dataframe transformation\nval origin by column&lt;String&gt;()\nval destination by column&lt;String&gt;()\n\nval clean = df\n    // fill missing flight numbers\n    .fillNA { flightNumber }.with { prev()!!.flightNumber + 10 }\n\n    // convert flight numbers to int\n    .convert { flightNumber }.toInt()\n\n    // clean 'airline' column\n    .update { airline }.with { \"([a-zA-Z\\\\s]+)\".toRegex().find(it)?.value ?: \"\" }\n\n    // split 'fromTo' column into 'origin' and 'destination'\n    .split { fromTo }.by(\"_\").into(origin, destination)\n\n    // clean 'origin' and 'destination' columns\n    .update { origin and destination }.with { it.lowercase().replaceFirstChar(Char::uppercase) }\n\n    // split lists of delays in 'recentDelays' into separate columns\n    // 'delay1', 'delay2'... and nest them inside original column `recentDelays`\n    .split { recentDelays }.inward { \"delay$it\" }\n\n    // convert string values in `delay1`, `delay2` into ints\n    .parse { recentDelays }\n</code></pre></p> <p>Aggregate: <pre><code>clean\n    // group by the flight origin renamed into \"from\"\n    .groupBy { origin named \"from\" }.aggregate {\n        // we are in the context of a single data group\n\n        // total number of flights from origin\n        count() into \"count\"\n\n        // list of flight numbers\n        flightNumber into \"flight numbers\"\n\n        // counts of flights per airline\n        airline.valueCounts() into \"airlines\"\n\n        // max delay across all delays in `delay1` and `delay2`\n        recentDelays.maxOrNull { delay1 and delay2 } into \"major delay\"\n\n        // separate lists of recent delays for `delay1`, `delay2` and `delay3`\n        recentDelays.implode(dropNA = true) into \"recent delays\"\n\n        // total delay per destination\n        pivot { destination }.sum { recentDelays.colsOf&lt;Int?&gt;() } into \"total delays to\"\n    }\n</code></pre></p> <p>Try it in Datalore and explore more examples here.</p>"},{"location":"dataframe/#kotlin-kotlin-jupyter-openapi-arrow-and-jdk-versions","title":"Kotlin, Kotlin Jupyter, OpenAPI, Arrow and JDK versions","text":"<p>This table shows the mapping between main library component versions and minimum supported Java versions.</p> Kotlin DataFrame Version Minimum Java Version Kotlin Version Kotlin Jupyter Version OpenAPI version Apache Arrow version 0.10.0 8 1.8.20 0.11.0-358 3.0.0 11.0.0 0.10.1 8 1.8.20 0.11.0-358 3.0.0 11.0.0 0.11.0 8 1.8.20 0.11.0-358 3.0.0 11.0.0 0.11.1 8 1.8.20 0.11.0-358 3.0.0 11.0.0 0.12.0 8 1.9.0 0.11.0-358 3.0.0 11.0.0 0.12.1 8 1.9.0 0.11.0-358 3.0.0 11.0.0"},{"location":"dataframe/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and the corresponding community are governed by the JetBrains Open Source and Community Code of Conduct. Please make sure you read it.</p>"},{"location":"dataframe/#license","title":"License","text":"<p>Kotlin Dataframe is licensed under the Apache 2.0 License.</p>"},{"location":"dataframe/binder/","title":"Index","text":"<p>This folder contains configuration files for Binder. It makes it possible to build the repository on Binder and view interactive notebooks from samples without installing kernel locally.</p>"},{"location":"dataframe/examples/","title":"Examples of Kotlin Dataframe","text":""},{"location":"dataframe/examples/#idea-examples","title":"Idea examples","text":"<ul> <li>movies Using 3 different Access APIs to perform data cleaning task</li> <li>titanic</li> <li>youtube</li> <li>json Using OpenAPI support in DataFrame's Gradle and KSP plugins to access data from API guru in a type-safe manner</li> </ul>"},{"location":"dataframe/examples/#notebook-examples","title":"Notebook examples","text":"<ul> <li>people (Datalore) \u2013 Small artificial dataset used in DataFrame API examples </li> </ul> <ul> <li>puzzles (notebook/Datalore) \u2013 Inspired by 100 pandas puzzles. You will go from the simplest tasks to  complex problems where need to think. This notebook will show you how to solve these tasks with the Kotlin  Dataframe in a laconic, beautiful style.</li> </ul> <ul> <li>movies (notebook/Datalore) \u2013 In this notebook you can see the basic operations of the Kotlin Dataframe on data from movielens. You can take the data from the link.</li> </ul> <ul> <li>netflix (notebook/Datalore) \u2013 Explore TV shows and movies from Netflix with the powerful Kotlin Dataframe API and beautiful visualizations from lets-plot.</li> </ul> <ul> <li>github (notebook/Datalore) \u2013 This notebook shows the hierarchical dataframes look like and how to work with them.</li> </ul> <ul> <li>titanic (notebook/Datalore) \u2013 Let's see how the new library will show itself on the famous Titanic dataset.</li> </ul> <ul> <li>wine (notebook/Datalore) \u2013   Wine. Kotlin Dataframe. KotlinDL. What came out of this can be seen in this notebook.</li> </ul> <ul> <li>youtube (notebook/Datalore) \u2013 Explore YouTube videos with YouTube REST API and Kotlin Dataframe </li> </ul>"},{"location":"kravis/","title":"<code>kravis</code> - A {k}otlin {gra}mmar for data {vis}ualization","text":"<p>Visualizing tabular and relational data is the core of data-science. <code>kravis</code> implements a grammar to create a wide range of plots using a standardized set of verbs.</p> <p>The grammar implemented by <code>kravis</code> is inspired from <code>ggplot2</code>. In fact, all it provides is a more typesafe wrapper around it.  Internally, <code>ggplot2</code> is used as rendering engine. The API of <code>kravis</code> is highly similar to allow even reusing their excellent cheatsheet.</p> <p>R is required to use <code>ggplot</code>. However, <code>kravis</code> works with various integration backend ranging such as docker or remote webservices.</p> <ul> <li><code>kravis</code> - A {k}otlin {gra}mmar for data {vis}ualization</li> <li>Jupyter</li> <li>Setup</li> <li>First Example</li> <li>The Grammar of Graphics</li> <li>Module Architecture</li> <li>Supported Data Input Formats<ul> <li>Iterators</li> <li>Tables</li> </ul> </li> <li>Output Devices</li> <li>Rendering<ul> <li>(1) Local R</li> <li>(2) Dockerized R.</li> <li>(3) Rserve</li> </ul> </li> <li>Plot Immutability</li> <li>API Coverage<ul> <li>How to use missing API elements from ggplot2?</li> </ul> </li> <li>References</li> <li>Acknowledgements</li> </ul> <p>This is an experimental API and is subject to breaking changes until a first major release</p>"},{"location":"kravis/#jupyter","title":"Jupyter","text":"<p>An easy way to get started with <code>kravis</code> is with jupyter, you simply need to install the kotlin-jupyter kernel.</p> <p>See here for a notebook example.</p>"},{"location":"kravis/#setup","title":"Setup","text":"<p>Add the following artifact to your <code>gradle.build</code></p> <pre><code>compile \"com.github.holgerbrandl:kravis:0.8.5\"\n</code></pre> <p>You can also use JitPack with Maven or Gradle to build the latest snapshot as a dependency in your project.</p> <pre><code>repositories {\n    maven { url 'https://jitpack.io' }\n}\ndependencies {\n        compile 'com.github.holgerbrandl:kravis:-SNAPSHOT'\n}\n</code></pre> <p>To build and install it into your local maven cache, simply clone the repo and run <pre><code>./gradlew install\n</code></pre></p>"},{"location":"kravis/#first-example","title":"First Example","text":"<p>Let's start by analyzing mamalian sleep patterns <pre><code>import kravis.*\nimport org.jetbrains.kotlinx.dataframe.datasets.sleepData\n\n\nsleepData\n    .add(\"rem_proportion\") { \"sleep_rem\"&lt;Double&gt;() / \"sleep_total\"&lt;Double&gt;() }\n    // Analyze correlation\n    .plot(x = \"sleep_total\", y = \"rem_proportion\", color = \"vore\", size = \"brainwt\")\n        .geomPoint(alpha = 0.7)\n        .guides(size = LegendType.none)\n        .title(\"Correlation between dream and total sleep time\")\n</code></pre></p> <p></p> <p>Find more examples in our gallery {comding soon}.</p>"},{"location":"kravis/#the-grammar-of-graphics","title":"The Grammar of Graphics","text":"<p><code>ggplot2</code> and thus <code>kravis</code> implement a grammar for graphics to build plots with</p> <p><code>aesthetics</code> + <code>layers</code>  + <code>coordinates system</code> + <code>transformations</code> + <code>facets</code></p> <p>Which reads as <code>map variables from data space to visual space</code> + <code>add one or more layers</code>  + <code>configure the coordinates system</code> + <code>optionally apply statistical transformations</code> + <code>optionally add facets</code>. That's the way!</p>"},{"location":"kravis/#module-architecture","title":"Module Architecture","text":""},{"location":"kravis/#supported-data-input-formats","title":"Supported Data Input Formats","text":""},{"location":"kravis/#iterators","title":"Iterators","text":"<p>Every <code>Iterable&lt;T&gt;</code> is a valid data source for <code>kravis</code>, which allows to create plots using a type-save builder DSL. Essentially we first digest it into a table and use it as data source for visualization. Here's an example:</p> <pre><code>//  deparse records using property references (which will allow to infer variable names via reflection)\nval basePlot = sleepPatterns.plot(\n        x = SleepPattern::sleep_rem,\n        y = SleepPattern::sleep_total,\n        color = SleepPattern::vore,\n        size = SleepPattern::brainwt\n    )\n\nbasePlot\n    .geomPoint()\n    .title(\"Correlation of total sleep and and rem sleep by food preference\")\n    .show()\n</code></pre> <p></p> <p>In the previous example  we have used property references. <code>kravis</code> also supports an extractor lambda function syntax, which allow for on-the-fly data transformations when deparsing an <code>Iterable&lt;T&gt;</code>. The (not yet solved) disadvantage is that we need to assign axis labels manually</p> <p><pre><code>sleepPatterns\n    .plot(x = { sleep_total/60 })\n    .geomHistogram()\n    .xLabel(\"sleep[h]\")\n</code></pre> </p> <p>And here's another example using a custom data class:</p> <pre><code>enum class Gender { male, female }\n\ndata class Person(val name: String, val gender: Gender, val heightCm: Int, val weightKg: Double)\n\n// define some persons\nval persons = listOf(\n    Person(\"Max\", Gender.male, 192, 80.3),\n    Person(\"Anna\", Gender.female, 162, 56.3),\n    Person(\"Maria\", Gender.female, 172, 66.3)\n)\n\n// visualize sizes by gender\npersons.plot(x = {name}, y = { weightKg }, fill = { gender.toString() })\n    .geomCol()\n    .xLabel(\"height [m]\")\n    .yLabel(\"weight [kg]\")\n    .title(\"Body Size Distribution\")\n</code></pre> <p></p>"},{"location":"kravis/#tables","title":"Tables","text":"<p><code>kravis</code> can handle any kind of tabular data via data-frames</p> <pre><code>import kravis.*\nimport org.jetbrains.kotlinx.dataframe.datasets.irisData\n\nirisData.plot(x=\"Species\" , y=\"Petal.Length\" )\n    .geomBoxplot()\n    .geomPoint(position = PositionJitter(width = 0.1), alpha = 0.3)\n    .title(\"Petal Length by Species\")\n</code></pre> <p></p>"},{"location":"kravis/#output-devices","title":"Output Devices","text":"<p><code>kravis</code> auto-detects the environment, and will try to guess the most reasonable output device to show your plots. The following output devices are available.</p> <ol> <li>A swing graphics device for rendering when running in interactive mode.</li> <li>A javaFX  graphics device for rendering when running in interactive mode.</li> <li>It can render directly into files</li> <li>will render directly into jupyter notebooks.</li> </ol> <p>By default <code>kravis</code> will render as <code>png</code> on all devices, but it also supports vector rendering using <code>svg</code> as output format.</p> <p>The preferred output can be configured using the <code>SessionPrefs</code> object</p> <pre><code>SessionPrefs.OUTPUT_DEVICE = SwingPlottingDevice()\n</code></pre>"},{"location":"kravis/#rendering","title":"Rendering","text":"<p>Currently <code>kravis</code> provided 3 different options to bind an R engine which is required to render plots.</p>"},{"location":"kravis/#1-local-r","title":"(1) Local R","text":"<p>This is the default mode which can be configured by using</p> <pre><code>SessionPrefs.RENDER_BACKEND = LocalR()\n</code></pre>"},{"location":"kravis/#2-dockerized-r","title":"(2) Dockerized R.","text":"<pre><code>SessionPrefs.RENDER_BACKEND = Docker()\n</code></pre> <p>This will pull and use by default the container <code>rocker/tidyverse:3.5.1</code>, but can be configured to use more custom images as needed.</p>"},{"location":"kravis/#3-rserve","title":"(3) Rserve","text":"<p>An (optionally) remote backend based using Rserve</p> <p>Simply install the corresponding R package and start the daemon with</p> <pre><code>R -e \"install.packages('Rserve',,'http://rforge.net/',type='source')\"\nR CMD Rserve\n</code></pre> <p>For configuration details see https://www.rforge.net/Rserve/doc.html</p> <p>Alternatively, in case you don't have or want a local R installation, you can also run it dockerized locally or remotly with <pre><code># docker run -p &lt;public_port&gt;:&lt;private_port&gt; -d &lt;image&gt;  \ndocker run -dp 6311:6311 holgerbrandl/kravis_rserve \n</code></pre> See Dockerfile for the spec of this image.</p> <p>To use the Rserve backend, configure the kravis <code>SessionPrefs</code> accordingly by pointing to the correct host and port. <pre><code>SessionPrefs.RENDER_BACKEND = RserveEngine(host=\"localhost\", port=6302)\n</code></pre></p>"},{"location":"kravis/#plot-immutability","title":"Plot Immutability","text":"<p>Plots are -- similar to <code>dataframe</code> data-frames -- immutable.</p> <pre><code>val basePlot = mpgData.plot(\"displ\" to x, \"hwy\" to y).geomPoint()\n\n// create one version with adjusted axis text size\nbasePlot.theme(axisText = ElementText(size = 20.0, color = RColor.red))\n\n// create another version with unchanged axis labels but using a log scale instead\nbasePlot.scaleXLog10()\n</code></pre>"},{"location":"kravis/#api-coverage","title":"API Coverage","text":"<p>Currently we just map a subset of the <code>ggplot2</code> API.</p> <p> </p> <ul> <li>Checks - implemented already</li> <li>Crosses - Planned but not yet done</li> </ul> <p>Feel welcome to submit a ticket or PR if some important usecase is missing.</p>"},{"location":"kravis/#how-to-use-missing-api-elements-from-ggplot2","title":"How to use missing API elements from ggplot2?","text":"<p>Since <code>kravis</code> just mimics some parts of <code>ggplot2</code>, and because user may want to create more custom plots we do support preambles (e.g. to define new geoms) and custom layer specs.</p> <p>Example</p> <pre><code>irisData.plot(x = \"Species\", y = \"Sepal.Length\", fill = \"Species\")\n    .addPreamble(\"\"\"devtools::source_url(\"https://git.io/fAiQN\")\"\"\")\n    .addCustom(\"\"\"geom_flat_violin(scale = \"count\", trim = FALSE)\"\"\")\n    .geomDotplot(binaxis = \"y\", dotsize = 0.5, stackdir = \"down\", binwidth = 0.1, position = PositionNudge(-0.025))\n    .theme(legendPosition = \"none\")\n    .labs(x = \"Species\", y = \"Sepal length (cm)\")\n</code></pre> <p></p>"},{"location":"kravis/#how-to-run-tests-on-your-local-machine","title":"How to run tests on your local machine","text":"<p>Run the following commands.</p> <pre><code>cd misc/docker/kravis_test/ &amp;&amp; docker build --progress=plain -t kravis_test .\n./gradlew test\n</code></pre>"},{"location":"kravis/#references","title":"References","text":"<p>You don't like it? Here are some other projects which may better suit your purpose. Before you leave, consider dropping us a ticket with some comments about whats missing, badly designed or simply broken in <code>kravis</code>.</p> <p>GGplot Wrappers</p> <ul> <li>gg4clj Another ggplot2 wrapper written in java</li> </ul> <p>Other JVM visualization libraries ordered by -- personally biased -- usefullness</p> <ul> <li>SmilePlot provides data visualization tools such as plots and maps for researchers to understand information more easily and quickly.</li> <li>XChart is a light-weight Java library for plotting data</li> <li>data2viz is a multi platform data visualization library with comprehensive DSL</li> <li>Kubed is a Kotlin library for manipulating the JavaFX scenegraph based on data.</li> <li>TornadoFX provides some Kotlin wrappers around JavaFX</li> <li>plotly-scala which provides scala bindings for plotly.js and works within jupyter</li> <li>breeze-viz which is a Visualization library backed by Breeze and JFreeChart</li> <li>grafana is an open platform for beautiful analytics and monitoring</li> <li>Jzy3d is an open source java library that allows to easily draw 3d scientific data: surfaces, scatter plots, bar charts</li> </ul> <p>Other * https://github.com/bloomberg/bqplot is a plotting library for IPython/Jupyter Notebooks</p> <p>Vega-lite based * Vegas aims to be the missing MatPlotLib for Scala + Spark * altair provides declarative statistical visualization library for Python * vega-embed allows to publish Vega visualizations as embedded web components with interactive parameters. * hrbrmstr/vegalite provides R ggplot2 \"bindings\" for Vega-Lite</p>"},{"location":"kravis/#acknowledgements","title":"Acknowledgements","text":"<p>Thanks to vega-lite team for making this project possible.</p> <p>Thanks to the ggplot2 team for providing the best data vis API to date.</p>"},{"location":"kmath/","title":"kmath","text":""},{"location":"kmath/#kmath","title":"KMath","text":"<p>Could be pronounced as <code>key-math</code>. The Kotlin Mathematics library was initially intended as a Kotlin-based analog to Python's NumPy library. Later we found that kotlin is much more flexible language and allows superior architecture designs. In contrast to <code>numpy</code> and <code>scipy</code> it is modular and has a lightweight core. The <code>numpy</code>-like experience could be achieved with kmath-for-real extension module.</p> <p>Documentation site (WIP)</p>"},{"location":"kmath/#publications-and-talks","title":"Publications and talks","text":"<ul> <li>A conceptual article about context-oriented design</li> <li>Another article about context-oriented design</li> <li>ACAT 2019 conference paper</li> </ul>"},{"location":"kmath/#goal","title":"Goal","text":"<ul> <li>Provide a flexible and powerful API to work with mathematics abstractions in Kotlin-multiplatform (JVM, JS and Native)   .</li> <li>Provide basic multiplatform implementations for those abstractions (without significant performance optimization).</li> <li>Provide bindings and wrappers with those abstractions for popular optimized platform libraries.</li> </ul>"},{"location":"kmath/#non-goals","title":"Non-goals","text":"<ul> <li>Be like NumPy. It was the idea at the beginning, but we decided that we can do better in API.</li> <li>Provide the best performance out of the box. We have specialized libraries for that. Need only API wrappers for them.</li> <li>Cover all cases as immediately and in one bundle. We will modularize everything and add new features gradually.</li> <li>Provide specialized behavior in the core. API is made generic on purpose, so one needs to specialize for types, like   for <code>Double</code> in the core. For that we will have specialization modules like <code>kmath-for-real</code>, which will give better   experience for those, who want to work with specific types.</li> </ul>"},{"location":"kmath/#features-and-stability","title":"Features and stability","text":"<p>KMath is a modular library. Different modules provide different features with different API stability guarantees. All core modules are released with the same version, but with different API change policy. The features are described in module definitions below. The module stability could have the following levels:</p> <ul> <li>PROTOTYPE. On this level there are no compatibility guarantees. All methods and classes form those modules could   break any moment. You can still use it, but be sure to fix the specific version.</li> <li>EXPERIMENTAL. The general API is decided, but some changes could be made. Volatile API is marked   with <code>@UnstableKMathAPI</code> or other stability warning annotations.</li> <li>DEVELOPMENT. API breaking generally follows semantic versioning ideology. There could be changes in minor   versions, but not in patch versions. API is protected   with binary-compatibility-validator tool.</li> <li>STABLE. The API stabilized. Breaking changes are allowed only in major releases.</li> </ul>"},{"location":"kmath/#modules","title":"Modules","text":""},{"location":"kmath/#benchmarks","title":"benchmarks","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#examples","title":"examples","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#kmath-ast","title":"kmath-ast","text":"<p>Maturity: EXPERIMENTAL</p> <p>Features: - expression-language : Expression language and its parser - mst-jvm-codegen : Dynamic MST to JVM bytecode compiler - mst-js-codegen : Dynamic MST to JS compiler - rendering : Extendable MST rendering</p>"},{"location":"kmath/#kmath-commons","title":"kmath-commons","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#kmath-complex","title":"kmath-complex","text":"<p>Complex numbers and quaternions.</p> <p>Maturity: PROTOTYPE</p> <p>Features: - complex : Complex numbers operations - quaternion : Quaternions and their composition</p>"},{"location":"kmath/#kmath-core","title":"kmath-core","text":"<p>Core classes, algebra definitions, basic linear algebra</p> <p>Maturity: DEVELOPMENT</p> <p>Features: - algebras : Algebraic structures like rings, spaces and fields. - nd : Many-dimensional structures and operations on them. - linear : Basic linear algebra operations (sums, products, etc.), backed by the <code>Space</code> API. Advanced linear algebra operations like matrix inversion and LU decomposition. - buffers : One-dimensional structure - expressions : By writing a single mathematical expression once, users will be able to apply different types of  objects to the expression by providing a context. Expressions can be used for a wide variety of purposes from high  performance calculations to code generation. - domains : Domains - autodiff : Automatic differentiation</p>"},{"location":"kmath/#kmath-coroutines","title":"kmath-coroutines","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#kmath-dimensions","title":"kmath-dimensions","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-ejml","title":"kmath-ejml","text":"<p>Maturity: PROTOTYPE</p> <p>Features: - ejml-vector : Point implementations. - ejml-matrix : Matrix implementation. - ejml-linear-space : LinearSpace implementations.</p>"},{"location":"kmath/#kmath-for-real","title":"kmath-for-real","text":"<p>Extension module that should be used to achieve numpy-like behavior. All operations are specialized to work with <code>Double</code> numbers without declaring algebraic contexts. One can still use generic algebras though.</p> <p>Maturity: EXPERIMENTAL</p> <p>Features: - DoubleVector : Numpy-like operations for Buffers/Points - DoubleMatrix : Numpy-like operations for 2d real structures - grids : Uniform grid generators</p>"},{"location":"kmath/#kmath-functions","title":"kmath-functions","text":"<p>Maturity: EXPERIMENTAL</p> <p>Features: - piecewise : Piecewise functions. - polynomials : Polynomial functions. - linear interpolation : Linear XY interpolator. - spline interpolation : Cubic spline XY interpolator. - integration : Univariate and multivariate quadratures</p>"},{"location":"kmath/#kmath-geometry","title":"kmath-geometry","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-histograms","title":"kmath-histograms","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-jafama","title":"kmath-jafama","text":"<p>Maturity: PROTOTYPE</p> <p>Features: - jafama-double : Double ExtendedField implementations based on Jafama</p>"},{"location":"kmath/#kmath-jupyter","title":"kmath-jupyter","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-kotlingrad","title":"kmath-kotlingrad","text":"<p>Maturity: EXPERIMENTAL</p> <p>Features: - differentiable-mst-expression : MST based DifferentiableExpression. - scalars-adapters : Conversions between Kotlin\u2207's SFun and MST</p>"},{"location":"kmath/#kmath-memory","title":"kmath-memory","text":"<p>An API and basic implementation for arranging objects in a continuous memory block.</p> <p>Maturity: DEVELOPMENT</p>"},{"location":"kmath/#kmath-multik","title":"kmath-multik","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-nd4j","title":"kmath-nd4j","text":"<p>Maturity: EXPERIMENTAL</p> <p>Features: - nd4jarraystructure : NDStructure wrapper for INDArray - nd4jarrayrings : Rings over Nd4jArrayStructure of Int and Long - nd4jarrayfields : Fields over Nd4jArrayStructure of Float and Double</p>"},{"location":"kmath/#kmath-optimization","title":"kmath-optimization","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#kmath-stat","title":"kmath-stat","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#kmath-symja","title":"kmath-symja","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-tensorflow","title":"kmath-tensorflow","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"kmath/#kmath-tensors","title":"kmath-tensors","text":"<p>Maturity: PROTOTYPE</p> <p>Features: - tensor algebra : Basic linear algebra operations on tensors (plus, dot, etc.) - tensor algebra with broadcasting : Basic linear algebra operations implemented with broadcasting. - linear algebra operations : Advanced linear algebra operations like LU decomposition, SVD, etc.</p>"},{"location":"kmath/#kmath-viktor","title":"kmath-viktor","text":"<p>Maturity: DEVELOPMENT</p>"},{"location":"kmath/#test-utils","title":"test-utils","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"kmath/#multi-platform-support","title":"Multi-platform support","text":"<p>KMath is developed as a multi-platform library, which means that most of the interfaces are declared in the common source sets and implemented there wherever it is possible. In some cases, features are delegated to platform-specific implementations even if they could be provided in the common module for performance reasons. Currently, the Kotlin/JVM is the primary platform, however Kotlin/Native and Kotlin/JS contributions and feedback are also welcome.</p>"},{"location":"kmath/#performance","title":"Performance","text":"<p>Calculation performance is one of major goals of KMath in the future, but in some cases it is impossible to achieve both performance and flexibility.</p> <p>We expect to focus on creating convenient universal API first and then work on increasing performance for specific cases. We expect the worst KMath benchmarks will perform better than native Python, but worse than optimized native/SciPy (mostly due to boxing operations on primitive numbers). The best performance of optimized parts could be better than SciPy.</p>"},{"location":"kmath/#requirements","title":"Requirements","text":"<p>KMath currently relies on JDK 11 for compilation and execution of Kotlin-JVM part. We recommend to use GraalVM-CE 11 for execution to get better performance.</p>"},{"location":"kmath/#repositories","title":"Repositories","text":"<p>Release and development artifacts are accessible from mipt-npm Space repository <code>https://maven.pkg.jetbrains.space/mipt-npm/p/sci/maven</code> (see documentation of Kotlin Multiplatform for more details). The repository could be reached through repo.kotlin.link proxy:</p> <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n}\n\ndependencies {\n    api(\"space.kscience:kmath-core:$version\")\n    // api(\"space.kscience:kmath-core-jvm:$version\") for jvm-specific version\n}\n</code></pre> <p>Gradle <code>6.0+</code> is required for multiplatform artifacts.</p>"},{"location":"kmath/#contributing","title":"Contributing","text":"<p>The project requires a lot of additional work. The most important thing we need is a feedback about what features are required the most. Feel free to create feature requests. We are also welcome to code contributions, especially in issues marked with waiting for a hero label.</p>"},{"location":"kmath/benchmarks/","title":"Module benchmarks","text":""},{"location":"kmath/examples/","title":"Module examples","text":""},{"location":"kmath/kmath-ast/","title":"Module kmath-ast","text":"<p>Extensions to MST API: transformations, dynamic compilation and visualization.</p> <ul> <li>expression-language : Expression language and its parser</li> <li>mst-jvm-codegen : Dynamic MST to JVM bytecode compiler</li> <li>mst-js-codegen : Dynamic MST to JS compiler</li> <li>rendering : Extendable MST rendering</li> </ul>"},{"location":"kmath/kmath-ast/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-ast:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-ast:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-ast:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-ast/#parsing-expressions","title":"Parsing expressions","text":"<p>In this module there is a parser from human-readable strings like <code>\"x^3-x+3\"</code> (in the more specific grammar) to MST instances.</p> <p>Supported literals: 1. Constants and variables (consist of latin letters, digits and underscores, can't start with digit): <code>x</code>, <code>_Abc2</code>. 2. Numbers: <code>123</code>, <code>1.02</code>, <code>1e10</code>, <code>1e-10</code>, <code>1.0e+3</code>\u2014all parsed either as <code>kotlin.Long</code> or <code>kotlin.Double</code>.</p> <p>Supported binary operators (from the highest precedence to the lowest one): 1. <code>^</code> 2. <code>*</code>, <code>/</code> 3. <code>+</code>, <code>-</code></p> <p>Supported unary operator: 1. <code>-</code>, e.\u00a0g. <code>-x</code></p> <p>Arbitrary unary and binary functions are also supported: names consist of latin letters, digits and underscores, can't start with digit. Examples: 1. <code>sin(x)</code> 2. <code>add(x, y)</code></p>"},{"location":"kmath/kmath-ast/#dynamic-expression-code-generation","title":"Dynamic expression code generation","text":""},{"location":"kmath/kmath-ast/#on-jvm","title":"On JVM","text":"<p><code>kmath-ast</code> JVM module supports runtime code generation to eliminate overhead of tree traversal. Code generator builds a special implementation of <code>Expression&lt;T&gt;</code> with implemented <code>invoke</code> function.</p> <p>For example, the following code:</p> <pre><code>import space.kscience.kmath.asm.compileToExpression\nimport space.kscience.kmath.operations.DoubleField\n\n\"x^3-x+3\".parseMath().compileToExpression(DoubleField)\n</code></pre> <p>\u2026 leads to generation of bytecode, which can be decompiled to the following Java class:</p> <pre><code>import java.util.*;\nimport kotlin.jvm.functions.*;\nimport space.kscience.kmath.asm.internal.*;\nimport space.kscience.kmath.complex.*;\nimport space.kscience.kmath.expressions.*;\n\npublic final class CompiledExpression_45045_0 implements Expression&lt;Complex&gt; {\n    private final Object[] constants;\n\n    public Complex invoke(Map&lt;Symbol, ? extends Complex&gt; arguments) {\n        Complex var2 = (Complex)MapIntrinsics.getOrFail(arguments, \"x\");\n        return (Complex)((Function2)this.constants[0]).invoke(var2, (Complex)this.constants[1]);\n    }\n}\n</code></pre> <p>For <code>LongRing</code>, <code>IntRing</code>, and <code>DoubleField</code> specialization is supported for better performance:</p> <pre><code>import java.util.*;\nimport space.kscience.kmath.asm.internal.*;\nimport space.kscience.kmath.expressions.*;\n\npublic final class CompiledExpression_-386104628_0 implements DoubleExpression {\n    private final SymbolIndexer indexer;\n\n    public SymbolIndexer getIndexer() {\n        return this.indexer;\n    }\n\n    public double invoke(double[] arguments) {\n        double var2 = arguments[0];\n        return Math.pow(var2, 3.0D) - var2 + 3.0D;\n    }\n\n    public final Double invoke(Map&lt;Symbol, ? extends Double&gt; arguments) {\n        double var2 = ((Double)MapIntrinsics.getOrFail(arguments, \"x\")).doubleValue();\n        return Math.pow(var2, 3.0D) - var2 + 3.0D;\n    }\n}\n</code></pre> <p>Setting JVM system property <code>space.kscience.kmath.ast.dump.generated.classes</code> to <code>1</code> makes the translator dump class files to program's working directory, so they can be reviewed manually.</p>"},{"location":"kmath/kmath-ast/#limitations","title":"Limitations","text":"<ul> <li>The same classes may be generated and loaded twice, so it is recommended to cache compiled expressions to avoid class loading overhead.</li> <li>This API is not supported by non-dynamic JVM implementations like TeaVM or GraalVM Native Image because they may not support class loaders.</li> </ul>"},{"location":"kmath/kmath-ast/#on-js","title":"On JS","text":"<p>A similar feature is also available on JS.</p> <pre><code>import space.kscience.kmath.expressions.Symbol.Companion.x\nimport space.kscience.kmath.expressions.*\nimport space.kscience.kmath.operations.*\nimport space.kscience.kmath.estree.*\n\nMstField { x + 2 }.compileToExpression(DoubleField)\n</code></pre> <p>The code above returns expression implemented with such a JS function:</p> <pre><code>var executable = function (constants, arguments) {\n    return constants[1](constants[0](arguments, \"x\"), 2);\n};\n</code></pre> <p>JS also supports experimental expression optimization with WebAssembly IR generation. Currently, only expressions inside <code>DoubleField</code> and <code>IntRing</code> are supported.</p> <pre><code>import space.kscience.kmath.expressions.Symbol.Companion.x\nimport space.kscience.kmath.expressions.*\nimport space.kscience.kmath.operations.*\nimport space.kscience.kmath.wasm.*\n\nMstField { x + 2 }.compileToExpression(DoubleField)\n</code></pre> <p>An example of emitted Wasm IR in the form of WAT:</p> <pre><code>(func \\$executable (param \\$0 f64) (result f64)\n  (f64.add\n    (local.get \\$0)\n    (f64.const 2)\n  )\n)\n</code></pre>"},{"location":"kmath/kmath-ast/#limitations_1","title":"Limitations","text":"<ul> <li>ESTree expression compilation uses <code>eval</code> which can be unavailable in several environments.</li> <li>WebAssembly isn't supported by old versions of browsers (see https://webassembly.org/roadmap/).</li> </ul>"},{"location":"kmath/kmath-ast/#rendering-expressions","title":"Rendering expressions","text":"<p>kmath-ast also includes an extensible engine to display expressions in LaTeX or MathML syntax.</p> <p>Example usage:</p> <pre><code>import space.kscience.kmath.ast.*\nimport space.kscience.kmath.ast.rendering.*\nimport space.kscience.kmath.misc.*\n\n@OptIn(UnstableKMathAPI::class)\npublic fun main() {\n    val mst = \"exp(sqrt(x))-asin(2*x)/(2e10+x^3)/(12)+x^(2/3)\".parseMath()\n    val syntax = FeaturedMathRendererWithPostProcess.Default.render(mst)\n    val latex = LatexSyntaxRenderer.renderWithStringBuilder(syntax)\n    println(\"LaTeX:\")\n    println(latex)\n    println()\n    val mathML = MathMLSyntaxRenderer.renderWithStringBuilder(syntax)\n    println(\"MathML:\")\n    println(mathML)\n}\n</code></pre> <p>Result LaTeX:</p> \\[\\operatorname{exp}\\\\,\\left(\\sqrt{x}\\right)-\\frac{\\frac{\\operatorname{arcsin}\\\\,\\left(2\\\\,x\\right)}{2\\times10^{10}+x^{3}}}{12}+x^{2/3}\\] <p>Result MathML (can be used with MathJax or other renderers):</p> <pre><code>&lt;math xmlns=\"https://www.w3.org/1998/Math/MathML\"&gt;\n    &lt;mrow&gt;\n        &lt;mo&gt;exp&lt;/mo&gt;\n        &lt;mspace width=\"0.167em\"&gt;&lt;/mspace&gt;\n        &lt;mfenced open=\"(\" close=\")\" separators=\"\"&gt;\n            &lt;msqrt&gt;\n                &lt;mi&gt;x&lt;/mi&gt;\n            &lt;/msqrt&gt;\n        &lt;/mfenced&gt;\n        &lt;mo&gt;-&lt;/mo&gt;\n        &lt;mfrac&gt;\n            &lt;mrow&gt;\n                &lt;mfrac&gt;\n                    &lt;mrow&gt;\n                        &lt;mo&gt;arcsin&lt;/mo&gt;\n                        &lt;mspace width=\"0.167em\"&gt;&lt;/mspace&gt;\n                        &lt;mfenced open=\"(\" close=\")\" separators=\"\"&gt;\n                            &lt;mn&gt;2&lt;/mn&gt;\n                            &lt;mspace width=\"0.167em\"&gt;&lt;/mspace&gt;\n                            &lt;mi&gt;x&lt;/mi&gt;\n                        &lt;/mfenced&gt;\n                    &lt;/mrow&gt;\n                    &lt;mrow&gt;\n                        &lt;mn&gt;2&lt;/mn&gt;\n                        &lt;mo&gt;&amp;times;&lt;/mo&gt;\n                        &lt;msup&gt;\n                            &lt;mrow&gt;\n                                &lt;mn&gt;10&lt;/mn&gt;\n                            &lt;/mrow&gt;\n                            &lt;mrow&gt;\n                                &lt;mn&gt;10&lt;/mn&gt;\n                            &lt;/mrow&gt;\n                        &lt;/msup&gt;\n                        &lt;mo&gt;+&lt;/mo&gt;\n                        &lt;msup&gt;\n                            &lt;mrow&gt;\n                                &lt;mi&gt;x&lt;/mi&gt;\n                            &lt;/mrow&gt;\n                            &lt;mrow&gt;\n                                &lt;mn&gt;3&lt;/mn&gt;\n                            &lt;/mrow&gt;\n                        &lt;/msup&gt;\n                    &lt;/mrow&gt;\n                &lt;/mfrac&gt;\n            &lt;/mrow&gt;\n            &lt;mrow&gt;\n                &lt;mn&gt;12&lt;/mn&gt;\n            &lt;/mrow&gt;\n        &lt;/mfrac&gt;\n        &lt;mo&gt;+&lt;/mo&gt;\n        &lt;msup&gt;\n            &lt;mrow&gt;\n                &lt;mi&gt;x&lt;/mi&gt;\n            &lt;/mrow&gt;\n            &lt;mrow&gt;\n                &lt;mn&gt;2&lt;/mn&gt;\n                &lt;mo&gt;/&lt;/mo&gt;\n                &lt;mn&gt;3&lt;/mn&gt;\n            &lt;/mrow&gt;\n        &lt;/msup&gt;\n    &lt;/mrow&gt;\n&lt;/math&gt;\n</code></pre> <p>It is also possible to create custom algorithms of render, and even add support of other markup languages (see API reference).</p>"},{"location":"kmath/kmath-commons/","title":"Module kmath-commons","text":"<p>Commons math binding for kmath</p>"},{"location":"kmath/kmath-commons/#usage","title":"Usage","text":""},{"location":"kmath/kmath-commons/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-commons:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-commons:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-commons:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-complex/","title":"Module kmath-complex","text":"<p>Complex and hypercomplex number systems in KMath.</p> <ul> <li>complex : Complex numbers operations</li> <li>quaternion : Quaternions and their composition</li> </ul>"},{"location":"kmath/kmath-complex/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-complex:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-complex:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-complex:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-core/","title":"Module kmath-core","text":"<p>The core interfaces of KMath.</p> <ul> <li>algebras : Algebraic structures like rings, spaces and fields.</li> <li>nd : Many-dimensional structures and operations on them.</li> <li>linear : Basic linear algebra operations (sums, products, etc.), backed by the <code>Space</code> API. Advanced linear algebra operations like matrix inversion and LU decomposition.</li> <li>buffers : One-dimensional structure</li> <li>expressions : By writing a single mathematical expression once, users will be able to apply different types of  objects to the expression by providing a context. Expressions can be used for a wide variety of purposes from high  performance calculations to code generation.</li> <li>domains : Domains</li> <li>autodiff : Automatic differentiation</li> </ul>"},{"location":"kmath/kmath-core/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-core:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-core:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-core:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-coroutines/","title":"Module kmath-coroutines","text":""},{"location":"kmath/kmath-coroutines/#usage","title":"Usage","text":""},{"location":"kmath/kmath-coroutines/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-coroutines:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-coroutines:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-coroutines:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-dimensions/","title":"Module kmath-dimensions","text":"<p>A proof of concept module for adding type-safe dimensions to structures</p>"},{"location":"kmath/kmath-dimensions/#usage","title":"Usage","text":""},{"location":"kmath/kmath-dimensions/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-dimensions:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-dimensions:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-dimensions:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-ejml/","title":"Module kmath-ejml","text":"<p>EJML based linear algebra implementation.</p> <ul> <li>ejml-vector : Point implementations.</li> <li>ejml-matrix : Matrix implementation.</li> <li>ejml-linear-space : LinearSpace implementations.</li> </ul>"},{"location":"kmath/kmath-ejml/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-ejml:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-ejml:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-ejml:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-for-real/","title":"Module kmath-for-real","text":"<p>Specialization of KMath APIs for Double numbers.</p> <ul> <li>DoubleVector : Numpy-like operations for Buffers/Points</li> <li>DoubleMatrix : Numpy-like operations for 2d real structures</li> <li>grids : Uniform grid generators</li> </ul>"},{"location":"kmath/kmath-for-real/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-for-real:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-for-real:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-for-real:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-functions/","title":"Module kmath-functions","text":"<p>Functions and interpolations.</p> <ul> <li>piecewise : Piecewise functions.</li> <li>polynomials : Polynomial functions.</li> <li>linear interpolation : Linear XY interpolator.</li> <li>spline interpolation : Cubic spline XY interpolator.</li> <li>integration : Univariate and multivariate quadratures</li> </ul>"},{"location":"kmath/kmath-functions/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-functions:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-functions:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-functions:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-geometry/","title":"Module kmath-geometry","text":""},{"location":"kmath/kmath-geometry/#usage","title":"Usage","text":""},{"location":"kmath/kmath-geometry/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-geometry:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-geometry:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-geometry:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-histograms/","title":"Module kmath-histograms","text":""},{"location":"kmath/kmath-histograms/#usage","title":"Usage","text":""},{"location":"kmath/kmath-histograms/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-histograms:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-histograms:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-histograms:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-jafama/","title":"Module kmath-jafama","text":"<p>Integration with Jafama.</p> <ul> <li>jafama-double : Double ExtendedField implementations based on Jafama</li> </ul>"},{"location":"kmath/kmath-jafama/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-jafama:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-jafama:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-jafama:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-jafama/#example-usage","title":"Example usage","text":"<p>All the <code>DoubleField</code> uses can be replaced with <code>JafamaDoubleField</code> or <code>StrictJafamaDoubleField</code>.</p> <pre><code>import space.kscience.kmath.jafama.*\nimport space.kscience.kmath.operations.*\n\nfun main() {\n    val a = 2.0\n    val b = StrictJafamaDoubleField { exp(a) }\n    println(JafamaDoubleField { b + a })\n    println(StrictJafamaDoubleField { ln(b) })\n}\n</code></pre>"},{"location":"kmath/kmath-jafama/#performance","title":"Performance","text":"<p>According to KMath benchmarks on GraalVM, Jafama functions are slower than JDK math; however, there are indications that on Hotspot Jafama is a bit faster.</p> <p>Can't find appropriate benchmark data. Try generating readme files after running benchmarks.</p>"},{"location":"kmath/kmath-jupyter/","title":"Module kmath-jupyter","text":""},{"location":"kmath/kmath-jupyter/#usage","title":"Usage","text":""},{"location":"kmath/kmath-jupyter/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-jupyter:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-jupyter:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-jupyter:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-kotlingrad/","title":"Module kmath-kotlingrad","text":"<p>Kotlin\u2207 integration module.</p> <ul> <li>differentiable-mst-expression : MST based DifferentiableExpression.</li> <li>scalars-adapters : Conversions between Kotlin\u2207's SFun and MST</li> </ul>"},{"location":"kmath/kmath-kotlingrad/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-kotlingrad:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-kotlingrad:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-kotlingrad:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-memory/","title":"Module kmath-memory","text":""},{"location":"kmath/kmath-memory/#usage","title":"Usage","text":""},{"location":"kmath/kmath-memory/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-memory:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-memory:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-memory:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-multik/","title":"Module kmath-multik","text":"<p>JetBrains Multik connector</p>"},{"location":"kmath/kmath-multik/#usage","title":"Usage","text":""},{"location":"kmath/kmath-multik/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-multik:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-multik:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-multik:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-nd4j/","title":"Module kmath-nd4j","text":"<p>ND4J based implementations of KMath abstractions.</p> <ul> <li>nd4jarraystructure : NDStructure wrapper for INDArray</li> <li>nd4jarrayrings : Rings over Nd4jArrayStructure of Int and Long</li> <li>nd4jarrayfields : Fields over Nd4jArrayStructure of Float and Double</li> </ul>"},{"location":"kmath/kmath-nd4j/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-nd4j:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-nd4j:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-nd4j:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-nd4j/#examples","title":"Examples","text":"<p>NDStructure wrapper for INDArray:</p> <pre><code>import org.nd4j.linalg.factory.*\nimport scientifik.kmath.nd4j.*\nimport scientifik.kmath.structures.*\n\nval array = Nd4j.ones(2, 2).asDoubleStructure()\nprintln(array[0, 0]) // 1.0\narray[intArrayOf(0, 0)] = 24.0\nprintln(array[0, 0]) // 24.0\n</code></pre> <p>Fast element-wise and in-place arithmetics for INDArray:</p> <pre><code>import org.nd4j.linalg.factory.*\nimport scientifik.kmath.nd4j.*\nimport scientifik.kmath.operations.*\n\nval field = DoubleNd4jArrayField(intArrayOf(2, 2))\nval array = Nd4j.rand(2, 2).asDoubleStructure()\n\nval res = field {\n    (25.0 / array + 20) * 4\n}\n\nprintln(res.ndArray)\n// [[  250.6449,  428.5840], \n//  [  269.7913,  202.2077]]\n</code></pre> <p>Contributed by Iaroslav Postovalov.</p>"},{"location":"kmath/kmath-optimization/","title":"Module kmath-optimization","text":""},{"location":"kmath/kmath-optimization/#usage","title":"Usage","text":""},{"location":"kmath/kmath-optimization/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-optimization:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-optimization:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-optimization:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-stat/","title":"Module kmath-stat","text":""},{"location":"kmath/kmath-stat/#usage","title":"Usage","text":""},{"location":"kmath/kmath-stat/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-stat:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-stat:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-stat:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-symja/","title":"Module kmath-symja","text":"<p>Symja integration module</p>"},{"location":"kmath/kmath-symja/#usage","title":"Usage","text":""},{"location":"kmath/kmath-symja/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-symja:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-symja:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-symja:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-tensorflow/","title":"Module kmath-tensorflow","text":"<p>Google tensorflow connector</p>"},{"location":"kmath/kmath-tensorflow/#usage","title":"Usage","text":""},{"location":"kmath/kmath-tensorflow/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-tensorflow:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-tensorflow:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-tensorflow:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-tensors/","title":"Module kmath-tensors","text":"<p>Common linear algebra operations on tensors.</p> <ul> <li>tensor algebra : Basic linear algebra operations on tensors (plus, dot, etc.)</li> <li>tensor algebra with broadcasting : Basic linear algebra operations implemented with broadcasting.</li> <li>linear algebra operations : Advanced linear algebra operations like LU decomposition, SVD, etc.</li> </ul>"},{"location":"kmath/kmath-tensors/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-tensors:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-tensors:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-tensors:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/kmath-viktor/","title":"Module kmath-viktor","text":"<p>Binding for https://github.com/JetBrains-Research/viktor</p>"},{"location":"kmath/kmath-viktor/#usage","title":"Usage","text":""},{"location":"kmath/kmath-viktor/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:kmath-viktor:0.4.0-dev-1</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:kmath-viktor:0.4.0-dev-1'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:kmath-viktor:0.4.0-dev-1\")\n}\n</code></pre></p>"},{"location":"kmath/license/","title":"Index","text":"<p>The Apache 2 license (given in full in LICENSE.txt) applies to all code in this repository, which is copyright by the contributors of KMath. The following sections of the repository contain third-party code, to which different licenses may apply:</p>"},{"location":"kmath/license/#kmath-libraries","title":"KMath Libraries","text":"<p>The following modules contain third-party code and are incorporated into the KMath Libraries:</p> <ul> <li>Path: kmath-functions/src/commonMain/kotlin/space/kscience/kmath/interpolation/SplineInterpolator.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons Math, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-functions/src/commonMain/kotlin/space/kscience/kmath/interpolation/LinearInterpolator.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons Math, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-functions/src/commonMain/kotlin/space/kscience/kmath/interpolation/LoessInterpolator.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons Math, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-functions/src/commonMain/kotlin/space/kscience/kmath/integration/GaussIntegratorRuleFactory.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons Math, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-for-real/src/commonMain/kotlin/space/kscience/kmath/real/RealMatrix.kt<ul> <li>License: Apache 2 (numky)</li> <li>Origin: Initial implementation was taken from Numky</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/AhrensDieterExponentialSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/AhrensDieterMarsagliaTsangGammaSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/AliasMethodDiscreteSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/BoxMullerSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/GaussianSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/KempSmallMeanPoissonSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/MarsagliaNormalizedGaussianSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/NormalizedGaussianSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/PoissonSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> <li>Path: kmath-stat/src/commonMain/kotlin/space/kscience/kmath/samplers/ZigguratNormalizedGaussianSampler.kt<ul> <li>License: Apache 2 (cm)</li> <li>Origin: Derived from Apache Commons RNG, \u00a9 2001-2020 The Apache Software Foundation</li> </ul> </li> </ul>"},{"location":"kmath/test-utils/","title":"Module test-utils","text":""},{"location":"dataforge-core/","title":"dataforge-core","text":""},{"location":"dataforge-core/#dataforge-context","title":"dataforge-context","text":"<p>Context and provider definitions</p> <p>Maturity: DEVELOPMENT</p>"},{"location":"dataforge-core/#dataforge-data","title":"dataforge-data","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"dataforge-core/#dataforge-io","title":"dataforge-io","text":"<p>IO module</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"dataforge-core/#dataforge-meta","title":"dataforge-meta","text":"<p>Meta definition and basic operations on meta</p> <p>Maturity: DEVELOPMENT</p>"},{"location":"dataforge-core/#dataforge-scripting","title":"dataforge-scripting","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"dataforge-core/#dataforge-workspace","title":"dataforge-workspace","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"dataforge-core/#dataforge-iodataforge-io-yaml","title":"dataforge-io/dataforge-io-yaml","text":"<p>YAML meta converters and Front Matter envelope format</p> <p>Maturity: PROTOTYPE</p>"},{"location":"dataforge-core/dataforge-context/","title":"Module dataforge-context","text":"<p>Context and provider definitions</p>"},{"location":"dataforge-core/dataforge-context/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-context/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-context:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-context:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-data/","title":"Module dataforge-data","text":""},{"location":"dataforge-core/dataforge-data/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-data/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-data:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-data:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-io/","title":"Module dataforge-io","text":"<p>IO module</p>"},{"location":"dataforge-core/dataforge-io/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-io/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-io:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-io:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-io/dataforge-io-yaml/","title":"Module dataforge-io-yaml","text":"<p>YAML meta IO</p>"},{"location":"dataforge-core/dataforge-io/dataforge-io-yaml/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-io/dataforge-io-yaml/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-io-yaml:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-io-yaml:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-meta/","title":"Module dataforge-meta","text":"<p>Meta definition and basic operations on meta</p>"},{"location":"dataforge-core/dataforge-meta/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-meta/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-meta:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-meta:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-scripting/","title":"Module dataforge-scripting","text":""},{"location":"dataforge-core/dataforge-scripting/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-scripting/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-scripting:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-scripting:0.7.0\")\n}\n</code></pre></p>"},{"location":"dataforge-core/dataforge-workspace/","title":"Module dataforge-workspace","text":""},{"location":"dataforge-core/dataforge-workspace/#usage","title":"Usage","text":""},{"location":"dataforge-core/dataforge-workspace/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:dataforge-workspace:0.7.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:dataforge-workspace:0.7.0\")\n}\n</code></pre></p>"},{"location":"plotly-kt/","title":"plotly.kt","text":""},{"location":"plotly-kt/#artifact-details","title":"Artifact details","text":"<p>Dev builds and intermediate artifacts are available via <code>https://repo.kotlin.link</code> maven repository.</p>"},{"location":"plotly-kt/#compatibility-note","title":"Compatibility note","text":"<p>The current <code>$version</code> version of the library is compatible with kotlin 1.4 with JS-IR and kotlinx-serialization 1.1.0. The JVM part requires JVM 11 to run.</p>"},{"location":"plotly-kt/#tldr","title":"TL;DR","text":"<p>See examples. See original library samples to understand capabilities.</p>"},{"location":"plotly-kt/#description","title":"Description","text":"<p>This project is developed to allow simple access to plotly functionality from kotlin-multiplatform. The API allows to create plotly configuration and render it as a plotly chart.</p> <p>The library supports three drawable plot objects: * <code>Plot</code> itself stands for a stand-alone plot frame. It requires external infrastructure to load appropriate JavaScript libraries. * <code>PlotFragment</code> is an HTML fragment possibly including several plots. The API for html is provided by kotlinx-html library. * <code>PlotlyPage</code> is a complete page, including body fragment and page headers (needed to load JavaScript part of Plotly).</p> <p>The work with plotly graphs could be rendered in following modes:</p>"},{"location":"plotly-kt/#html-page-export","title":"HTML page export","text":"<p>(JVM and native) Export plot or page in a standalone html file, using CDN distribution or local JS file (JVM only). This mode does not support updates.</p> <p>See staticPlot and customPage for examples.</p>"},{"location":"plotly-kt/#ktor-based-server-with-dynamic-updates","title":"Ktor-based server with dynamic updates","text":"<p>(JVM only) A Ktor CIO server with full multi-page and update capabilities.</p> <p>See simpleServer and dynamicServer for examples.</p>"},{"location":"plotly-kt/#kotlin-js","title":"Kotlin-JS","text":"<p>Plotly is a JavaScript library, yet it is convenient to have a type-safe API when using in with Kotlin-JS. The sample application is available in js-demo module. One should node that Plotly.kt for JS is not a zero-cost wrapper like TypeScript definitions, it maintains its own object structure, could generate stand-alone models and some internal optimizations.</p> <p>Plotly-kt does not support <code>LEGACY</code> JS target. Be sure to use IR compiler</p>"},{"location":"plotly-kt/#javafx-browser","title":"JavaFX browser","text":"<p>Plotly.kt could be run in a JavaFX browser. An example project is presented in fx-demo.</p>"},{"location":"plotly-kt/#kotlin-jupyter-kernel","title":"Kotlin jupyter kernel","text":"<p>Plotly.kt comes with (beta-version) support for integration with Kotlin Jupyter kernel. See details here.</p> <p>The examples of the notebooks are shown in notebooks directory. Plotly.kt uses Kotlin jupyter notebook API for integration (available in kernel version <code>0.8.3.236</code> and later). In order to load the library together with automatic imports one need to simply load a library in a following way:</p> <pre><code>@file:Repository(\"https://repo.kotlin.link\")\n@file:DependsOn(\"space.kscience:plotlykt-jupyter:$version\")\n//@file:DependsOn(\"space.kscience:plotlykt-server:$version\") // Use this one for sever integration.\n</code></pre> <p>The module <code>plotly</code> allows rendering static plots in Jupyter. Jupyter lab is currently supported. Jupyter notebook (classic) is able to render only <code>PlotlyPage</code> objects, so one must convert plots to pages to be able to use notebook (see demo notebook).</p> <p>The module <code>plotly-server</code> adds server capabilities and allows to render dynamic plots in notebooks (see demo notebook). One must note that for dynamic pages, one must pass <code>renderer</code> parameter explicitly to plot like it is done in examples.</p> <p>IMPORTANT: By default, Plotly-kt jupyter integration is configured to work with Jupyter Lab frontend, which renders all cells in the same page. Jupyter classic notebook and DataLore use cell isolation with iframes, so you will see blanks instead of plots. It could be fixed by switching into a notebook mode by running <code>Plotly.jupyter.notebook()</code> in a cell after plotly library is loaded. </p>"},{"location":"plotly-kt/#direct-image-render-via-orca-experimental","title":"Direct image render via Orca (experimental)","text":"<p>Plotly Orca application allows direct rendering of plots (not fragments or pages) to raster of vector images. <code>Plot.export</code> extension could be used to call it. It requires for orca to be installed in the system and available on the system path.</p>"},{"location":"plotly-kt/#kotlin-scripting-experimental","title":"Kotlin-scripting (experimental)","text":"<p>It is possible to separate script logic into stand-alone <code>plotly.kts</code> script file and generate an html from the command line. See plotlykt-script module for details.</p>"},{"location":"plotly-kt/#kotlinnative-experimental","title":"Kotlin/Native (experimental)","text":"<p>Plotly model now fully supports Kotlin/Native. It means that you can use it to create a proper Plotly-based HTML file. You will still need browser to view it. You can use native-demo example.</p>"},{"location":"plotly-kt/#the-feature-i-need-is-not-implemented","title":"The feature I need is not implemented!","text":"<p>There are three ways to solve it: 1. Contribute! It is easy! Just add a model you need. 2. Create a model you need in your project or add an extension. Since the inner model is dynamic, you can add features on flight. 3. You can dynamically add missing features directly into configuration like it done in unsupportedFeature example.</p>"},{"location":"plotly-kt/#build-and-usage","title":"Build and usage","text":"<p>In order to use the library, one needs to use following <code>gradle.kts</code> configuration:</p> <pre><code>plugins {\n    kotlin(\"jvm\")\n}\n\nrepositories {\n    maven(\"https://repo.kotlin.link\")\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-server:$version\")\n}\n</code></pre> <p>If you do not need the server, then use plotlykt-core instead.</p>"},{"location":"plotly-kt/#naming","title":"Naming","text":"<p>The library keeps original Plotly API naming wherever it is possible. There are some usability shortcuts, usually provided via kotlin extensions, included in order to simplify user interaction. For example, <code>text</code> and <code>shape</code> extensions in the top level API.</p> <p>Keeping the original naming sometimes causes clashes with Kotlin code style. For example enum names are unorthodox.</p>"},{"location":"plotly-kt/#planned-features","title":"Planned features","text":"<ul> <li>Table widgets</li> <li>Serverside plot events</li> <li>Online plot editor</li> <li>Dynamic data</li> <li>Mathjax and latex support</li> </ul>"},{"location":"plotly-kt/#contributions-and-thanks","title":"Contributions and thanks","text":"<ul> <li>Vasily Chernov - initial project foundation</li> <li>Alexander Nozik - dynamic core and server</li> <li>Mikhail Zeleniy - basic models</li> <li>Ekaterina Samorodova (JBR-2020 summer internship) - Model refactoring, tutorials and <code>0.2</code> release.</li> </ul> <p>The project was partially founded by JetBrains Research grant.</p>"},{"location":"plotly-kt/docs/templates/ARTIFACT-TEMPLATE/","title":"ARTIFACT TEMPLATE","text":""},{"location":"plotly-kt/docs/templates/ARTIFACT-TEMPLATE/#artifact","title":"Artifact:","text":"<p>This module artifact: <code>${group}:${name}:${version}</code>.</p> <p>[</p> <p>Gradle:</p> <p><pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n}\n\ndependencies {\n    implementation '${group}:${name}:${version}'\n}\n</code></pre> Gradle Kotlin DSL:</p> <pre><code>repositories {\n    maven(\"https://https://repo.kotlin.link\")\n}\n\ndependencies {\n    implementation(\"${group}:${name}:${version}\")\n}\n</code></pre>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/","title":"README TEMPLATE","text":""},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#artifact-details","title":"Artifact details","text":"<p>Dev builds and intermediate artifacts are available via <code>https://repo.kotlin.link</code> maven repository.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#compatibility-note","title":"Compatibility note","text":"<p>The current <code>$version</code> version of the library is compatible with kotlin 1.4 with JS-IR and kotlinx-serialization 1.1.0. The JVM part requires JVM 11 to run.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#tldr","title":"TL;DR","text":"<p>See examples. See original library samples to understand capabilities.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#description","title":"Description","text":"<p>This project is developed to allow simple access to plotly functionality from kotlin-multiplatform. The API allows to create plotly configuration and render it as a plotly chart.</p> <p>The library supports three drawable plot objects: * <code>Plot</code> itself stands for a stand-alone plot frame. It requires external infrastructure to load appropriate JavaScript libraries. * <code>PlotFragment</code> is an HTML fragment possibly including several plots. The API for html is provided by kotlinx-html library. * <code>PlotlyPage</code> is a complete page, including body fragment and page headers (needed to load JavaScript part of Plotly).</p> <p>The work with plotly graphs could be rendered in following modes:</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#html-page-export","title":"HTML page export","text":"<p>(JVM and native) Export plot or page in a standalone html file, using CDN distribution or local JS file (JVM only). This mode does not support updates.</p> <p>See staticPlot and customPage for examples.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#ktor-based-server-with-dynamic-updates","title":"Ktor-based server with dynamic updates","text":"<p>(JVM only) A Ktor CIO server with full multi-page and update capabilities.</p> <p>See simpleServer and dynamicServer for examples.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#kotlin-js","title":"Kotlin-JS","text":"<p>Plotly is a JavaScript library, yet it is convenient to have a type-safe API when using in with Kotlin-JS. The sample application is available in js-demo module. One should node that Plotly.kt for JS is not a zero-cost wrapper like TypeScript definitions, it maintains its own object structure, could generate stand-alone models and some internal optimizations.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#javafx-browser","title":"JavaFX browser","text":"<p>Plotly.kt could be run in a JavaFX browser. An example project is presented in fx-demo.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#kotlin-jupyter-kernel","title":"Kotlin jupyter kernel","text":"<p>Plotly.kt comes with (beta-version) support for integration with Kotlin Jupyter kernel. See details here.</p> <p>The examples of the notebooks are shown in notebooks directory. Plotly.kt uses Kotlin jupyter notebook API for integration (available in kernel version <code>0.8.3.236</code> and later). In order to load the library together with automatic imports one need to simply load a library in a following way:</p> <pre><code>@file:Repository(\"https://repo.kotlin.link\")\n@file:DependsOn(\"space.kscience:plotlykt-jupyter:$version\")\n//@file:DependsOn(\"space.kscience:plotlykt-server:$version\") // Use this one for sever integration.\n</code></pre> <p>The module <code>plotly</code> allows rendering static plots in Jupyter. Jupyter lab is currently supported. Jupyter notebook (classic) is able to render only <code>PlotlyPage</code> objects, so one must convert plots to pages to be able to use notebook (see demo notebook).</p> <p>The module <code>plotly-server</code> adds server capabilities and allows to render dynamic plots in notebooks (see demo notebook). One must note that for dynamic pages, one must pass <code>renderer</code> parameter explicitly to plot like it is done in examples.</p> <p>IMPORTANT: By default, Plotly-kt jupyter integration is configured to work with Jupyter Lab frontend, which renders all cells in the same page. Jupyter classic notebook and DataLore use cell isolation with iframes, so you will see blanks instead of plots. It could be fixed by switching into a notebook mode by running <code>Plotly.jupyter.notebook()</code> in a cell after plotly library is loaded. </p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#direct-image-render-via-orca-experimental","title":"Direct image render via Orca (experimental)","text":"<p>Plotly Orca application allows direct rendering of plots (not fragments or pages) to raster of vector images. <code>Plot.export</code> extension could be used to call it. It requires for orca to be installed in the system and available on the system path.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#kotlin-scripting-experimental","title":"Kotlin-scripting (experimental)","text":"<p>It is possible to separate script logic into stand-alone <code>plotly.kts</code> script file and generate an html from the command line. See plotlykt-script module for details.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#kotlinnative-experimental","title":"Kotlin/Native (experimental)","text":"<p>Plotly model now fully supports Kotlin/Native. It means that you can use it to create a proper Plotly-based HTML file. You will still need browser to view it. You can use native-demo example.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#the-feature-i-need-is-not-implemented","title":"The feature I need is not implemented!","text":"<p>There are three ways to solve it: 1. Contribute! It is easy! Just add a model you need. 2. Create a model you need in your project or add an extension. Since the inner model is dynamic, you can add features on flight. 3. You can dynamically add missing features directly into configuration like it done in unsupportedFeature example.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#build-and-usage","title":"Build and usage","text":"<p>In order to use the library, one needs to use following <code>gradle.kts</code> configuration:</p> <pre><code>plugins {\n    kotlin(\"jvm\")\n}\n\nrepositories {\n    maven(\"https://repo.kotlin.link\")\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-server:$version\")\n}\n</code></pre> <p>If you do not need the server, then use plotlykt-core instead.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#naming","title":"Naming","text":"<p>The library keeps original Plotly API naming wherever it is possible. There are some usability shortcuts, usually provided via kotlin extensions, included in order to simplify user interaction. For example, <code>text</code> and <code>shape</code> extensions in the top level API.</p> <p>Keeping the original naming sometimes causes clashes with Kotlin code style. For example enum names are unorthodox.</p>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#planned-features","title":"Planned features","text":"<ul> <li>Table widgets</li> <li>Serverside plot events</li> <li>Online plot editor</li> <li>Dynamic data</li> <li>Mathjax and latex support</li> </ul>"},{"location":"plotly-kt/docs/templates/README-TEMPLATE/#contributions-and-thanks","title":"Contributions and thanks","text":"<ul> <li>Vasily Chernov - initial project foundation</li> <li>Alexander Nozik - dynamic core and server</li> <li>Mikhail Zeleniy - basic models</li> <li>Ekaterina Samorodova (JBR-2020 summer internship) - Model refactoring, tutorials and <code>0.2</code> release.</li> </ul> <p>The project was partially founded by JetBrains Research grant.</p>"},{"location":"plotly-kt/docs/tutorials/HowToDrawASinus/","title":"HowToDrawASinus","text":""},{"location":"plotly-kt/docs/tutorials/HowToDrawASinus/#how-to-draw-a-sinus","title":"How To Draw A Sinus?","text":"<p>In data visualization tasks, quite often there is a need to depict mathematical  functions - for example, to compare the convergence rate of a model with ideal one or to find an approximation for a given time series. Such charts  have a number of features that are not inherent in most other charts: for example, visualizing the perpendicular axes (OX, OY) from (0, 0) and a large number of additional information. This can be the expected value of the function, its extremum points, deviation at various points, etc.</p> <p>This article will tell you how to depict an ordinary sinus using the library <code>Plotly.kt</code> so that in the end you will get a visual and informative plot.</p> <ol> <li> <p>Let's start with drawing perpendicular OX and OY axes. This requires to do a few things:    hide default axes lines, hide zero lines (it's impossible to draw an arrow on the end of it),    add perpendicular arrows using annotations (<code>Text</code>) with visible arrows on the end, but without    text. After that, let's sign the axes themselves. It is also important to specify the required     chart sizes (<code>width</code>,<code>height</code>) so that after saving the graph will look the same as in the browser.</p> <pre><code>Plotly.page {                                // making new html page with plot\n    layout {\n        width = 900                          // width of the plot (in px.)\n        height = 500                         // height of the plot (in px.)\n\n        text {                               // vertical axis\n            x = Value.of(0)                  // position of the top end of the arrow = (0, 1+eps)\n            y = Value.of(1 + eps)\n            ax = Value.of(0)                 // ax, ay means the offset of the bottom edge relative to the top\n            ay = Value.of(430)               // positive (negative) value is the arrow length\n                                             // upwards (top down) and from right to left (from left to right)\n        }\n\n        text {                               // horizontal axis\n            y = Value.of(0)                  // arrow left position = (2PI + eps, 0)\n            x = Value.of(2 * PI + eps)\n            ax = Value.of(-800)              // position of the left end of the arrow\n            ay = Value.of(0)\n        }\n\n        xaxis {                              // OX parameters\n            showline = false                 // hide OX line\n            zeroline = false                 // hide zero line\n        }\n        yaxis {                              // OY parameters\n            showline = false                 // hide OY line\n            zeroline = false                 // hide zero line\n        }\n    }\n}.makeFile()                                 // making temporary file and visualing plot in the browser\n</code></pre> </li> <li> <p>Now we will draw the sinus function itself - for its visualization let's choose a bright blue color,    contrasting with both the white background and the black ticks on the axes. After that using     the variation of the <code>mode</code> parameter (<code>ScatterMode: lines, markers</code>) the intersection points with the OY axis    will be marked with a slightly darker shade of the same color.</p> <p><pre><code>x1 = (-410..410).map{ it / 200 * PI }        // function domain (-2PI - eps, 2PI + eps)\ny1 = sin(x1)                                 // function values\n\nPlotly.page {\n    scatter {                                // making Scatter plot (sinus)\n        x.set(x1)                            // assigning OX values\n        y.set(y1)                            // assigning OY values\n        line { color(XKCD.CERULEAN) }        // color of the line is cerulean\n    }\n\n    scatter {                                // making Scatter plot (OX axis dots)\n        mode = ScatterMode.markers           // visualizing only dots\n        x(-2* PI, -PI, PI, 2* PI)            // points of intersection of sinus with OX (values \u200b\u200balong the X axis)\n        y(0, 0, 0, 0)                        // points of intersection of sinus with OX (values \u200b\u200balong the Y axis)\n        line { color(XKCD.CERULEAN_BLUE) }   // color of the dots is darker cerulean\n        marker { size = 8 }                  // dot's diameter is 8 px.\n    }\n\n    layout { ... }\n}.makeFile()\n</code></pre> 3. Let's draw horizontal dashed lines on the chart, corresponding to values \u200b\u200bequal to -1, 1 (extremum lines) and \u00bd.    This requires changing <code>line.dash</code> parameter to <code>Dash.dash</code> value. The specified values \u200b\u200bwill be plotted after that     on the OY axis using the <code>tickvals</code> and<code>ticklabels</code> parameters.</p> <pre><code>...\nPlotly.page {\n    ...\n    layout {\n        shape {                               // adding new figure (line y = 1)\n            x0 = Value.of(-2*PI)              // (-2PI, 1) and (2PI, 1) coordinates  \n            x1 = Value.of(2*PI)               // will be connected by a line\n            y0 = Value.of(1)\n            y1 = Value.of(1)\n            line { dash = Dash.dash }         // dashed type of the line\n        }\n\n        shape {                               // adding new figure (line y = 1/2)\n            x0 = Value.of(-2*PI)              // coordinates (-2PI, 1/2) and (2PI, 1/2) \n            x1 = Value.of(2*PI)               // will be connected by a line\n            y0 = Value.of(0.5)\n            y1 = Value.of(0.5)\n            line {\n                color(\"red\")                  // red color of the line\n                dash = Dash.dash              // dashed type of the line\n            }\n        }\n\n        shape {                               // adding new figure (line y = -1)\n            x0 = Value.of(-2*PI)              // coordinates (-2PI, -1) and (2PI, -1) \n            x1 = Value.of(2*PI)               // will be connected by a line\n            y0 = Value.of(-1)\n            y1 = Value.of(-1)\n            line { dash = Dash.dash }         // dashed type of the line\n        }\n        ...\n    }\n}.makeFile()\n</code></pre> </li> <li> <p>After that, it is worth adding vertical lines connecting points on OX, the values in    which equals \u00bd, and the value itself in LaTeX format. Shapes are used again for this - an array    values \u200b\u200bof type <code>Shape.line</code>. To use LaTeX format you need to include the <code>MathJax</code> header.</p> <pre><code>...\nval sub = PI / 6\nval xElems = listOf(-2PI + sub, -PI - sub, 0 + sub, PI - sub)\n// points, where sinus equals 1/2\n\nval shapesList = mutableListOf&lt;Shape&gt;()        // making list of lines\nfor (x: xElems) {\n    val shape = Shape {\n        x0 = Value.of(x)                       // (x, 0) and (x, 0.5) will be connected\n        y0 = Value.of(0)\n        x1 = Value.of(x)\n        y0 = Value.of(1/2)\n        line { color(\"red\") }                  // red color of the line\n    }\n    shapesList.add(shape)                      // adding new figure to the list\n}\n\nPlotly.page(mathJaxHeader, cdnPlotlyHeader) {\n    scatter {                                  // add string \"1/2\"\n        mode = ScatterMode.text                // visualing only text\n        x(-0.35)                               // text position on the OX axis\n        y(0.56)                                // text position on the OX axis\n        text = listOf(\"$\\Large{1/2}$\")         // increasing font size with \u0422\u0435\u0425\n        textfont { color(\"red\") }              // red color of the font\n        showlegend = false                     // do not show this trace in the legend\n        hoverinfo = \"none\"                     // do not show anything on hover\n    }\n    ...\n    layout {                                   // adding figure list to the plot\n        shapes = shapesList                      \n        ...\n    }\n}.makeFile()\n</code></pre> </li> <li> <p>It remains to add labels on OX corresponding to the intersections of the sinus with the axis. It    is done in a similar way, using axis labels (<code>tickvals</code>,<code>ticktext</code>) and writing text in LaTeX format.</p> <pre><code>...\nPlolty.page(mathJaxHeader, cdnPlotlyHeader) {\n    ...\n    layout {\n        xaxis {                                // OX axis parameters\n            ...\n            anchor = \"free\"                    // axis position is set manually\n            position = 0.43                    // assigning axis position\n            tickvals(listOf(-2 * PI-0.05, -PI - 0.15, PI - 0.05, 2 * PI + 0.1))\n            ticktext(listOf(\"\\$\\\\huge{-2\\\\pi}\\$\", \"\\$\\\\huge{-\\\\pi}\\$\", \"\\$\\\\huge{\\\\pi}\\$\", \"\\$\\\\huge{2\\\\pi}\\$\"))\n            // ticks positions and text\n        }\n        yaxis {                                // OY axis parameters\n            ...\n            anchor = \"free\"                    // axis position is set manually\n            position = 0.485                   // assigning axis position\n            tickvals(listOf(-0.91, 0.09, 1.09))\n            ticktext(listOf(\"\\$\\\\Large{-1}\\$\", \"\\$\\\\Large{0}\\$\", \"\\$\\\\Large{1}\\$\"))\n            // ticks positions and text\n        }\n        ...\n    }\n}.makeFile()\n</code></pre> </li> <li> <p>As a final improvement, let's add a legend to the plot, which will be placed in upper right corner of the graph.    First you need to set the name of the corresponding line, after which with using the parameters <code>xanchor = right</code>     and<code>yanchor = top</code> set the position of the legend so that the coordinates specified by the parameters     <code>x = 1</code>,<code>y = 1</code> correspond to the position in the upper right corner of the image.</p> <pre><code>...\nPlotly.page(mathJaxHeader, cdnPlotlyHeader) {\n    scatter {                                   // sinus Scatter trace\n        ...\n        name = \"\\$\\\\Large{y = \\\\mathrm{sin}\\\\,x}\\$\"\n        // the name of the plot displayed in the legend\n    }\n\n    layout {\n        legend {                                // legend parameters\n            x = 0.97                            // horizontal position of the legend\n            y = 1                               // vertical position of the legend\n            borderwidth = 1                     // width of the legend border\n            font { size = 32 }                  // size of the legend font\n            xanchor = XAnchor.right             // \"anchoring\" the position of the legend to the right corner\n            yanchor = YAnchor.top               // \"anchoring\" the position of the legend to the bottom of the graph\n        }\n        ...\n    }\n}.makeFile()\n</code></pre> </li> <li> <p>Final picture:</p> </li> </ol> <p></p> <p>Source code is available at: https://github.com/mipt-npm/plotly.kt/tree/dev/examples/src/main/kotlin/tutorials/SinusPicture.kt</p>"},{"location":"plotly-kt/docs/tutorials/jupyter/","title":"Plotly.kt Jupyter kernel integration","text":"<p>Being a JavaScript library with a Kotlin-JVM backend, Plotly.kt is ideally suited for Jupyter kotlin kernel integration. The integration is supported in two modes:</p> <ul> <li>Static rendering in plotlykt-jupyter module.</li> <li>Dynamic updates processing via plotlykt-server module.</li> </ul>"},{"location":"plotly-kt/docs/tutorials/jupyter/#loading-the-library","title":"Loading the library","text":"<ul> <li>Install or update Jupyter kotlin kernel to version <code>0.9</code> or later.</li> <li>Launch kotlin kernel in <code>jupyter lab</code> (classic jupyter notebook is not supported).</li> <li>Use <code>@file:DependsOn(\"space.kscience:plotlykt-jupyter:$plotlyVersion\")</code> annotation directive to load library, where <code>$plotlyVersion</code> is the required version of the library. This approach uses Kotlin jupyter notebook API. For dynamic version one should replace <code>plotlykt-server</code> instead of <code>plotlykr-jupyter</code>.</li> <li>Alternatively one could use <code>%use plotly</code> directive. For dynamic version one should replace <code>plotly-server</code> instead of <code>plotly</code>.</li> </ul>"},{"location":"plotly-kt/docs/tutorials/jupyter/#automatic-rendering","title":"Automatic rendering","text":"<p>The integration automatically imports <code>space.kscience.plotlykt.*</code> and <code>space.kscience.plotlykt.models.*</code> and provides automatic rendering for three basic plotly objects: <code>Plot</code>, <code>PlotlyFragment</code> and <code>PlotlyPage</code>. One needs to return those object as result of last expressions in a cell in order to automatically render them.</p>"},{"location":"plotly-kt/docs/tutorials/jupyter/#dynamic-update-server","title":"Dynamic update server","text":"<p>The dynamic server uses three-way communication to provide updates for the jupyter cell content:</p> <ul> <li>Jupyter kernel server</li> <li>Browser Plotly API (websockets)</li> <li>Ktor server which provides both static data and updates via web-sockets.</li> </ul> <p>When the plot is placed into the page, its initial data is embedded into the page as plotly-compatible JSON alongside the path to data server and updates server.</p> <p>The resulting HTML looks like this: <pre><code>&lt;div id=\"space.kscience.plotly.Plot@502ed4cc\"&gt;\n    &lt;script&gt;\n        makePlot(\n           'space.kscience.plotly.Plot@502ed4cc',\n            [/*plot data*/],\n            {/*layout*/},\n            {}\n        );\n        startPush('space.kscience.plotly.Plot@502ed4cc', 'ws://127.0.0.1:3872//ws/space.kscience.plotly.Plot@502ed4cc');\n    &lt;/script&gt;\n&lt;/div&gt;\n</code></pre></p> <p>The changes in the back-end model are automatically collected and sent to the notebook with fixed intervals (if present). The interval is <code>100 ms</code> by default and could be changed via <code>plotly.updateInterval = 200</code> line. The server is restarted on interval change.</p> <p>The local port used for the server (default is <code>8882</code>) also could be changed via configuration object (<code>plotly.port = 8884</code>). After port change, all plots that use dynamic updates must be re-created to ensure they use correct update location.</p>"},{"location":"plotly-kt/docs/tutorials/jupyter/#what-about-classic-notebook","title":"What about classic notebook?","text":"<p>At this moment only Jupyter lab is supported. Classic notebook does not work well because it does not allow loading JS resources globally after the notebook is started. We will research the possibility to support classic notebook as well as other IPython kernels in the future.</p>"},{"location":"plotly-kt/examples/","title":"Module examples","text":""},{"location":"plotly-kt/examples/fx-demo/","title":"Module fx-demo","text":""},{"location":"plotly-kt/examples/js-demo/","title":"Module js-demo","text":""},{"location":"plotly-kt/examples/src/main/kotlin/script/","title":"Run script","text":"<p><code>plotlykt-script customPage.plotly.kts</code></p>"},{"location":"plotly-kt/plotlykt-core/","title":"Module plotlykt-core","text":""},{"location":"plotly-kt/plotlykt-core/#usage","title":"Usage","text":""},{"location":"plotly-kt/plotlykt-core/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:plotlykt-core:0.6.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:plotlykt-core:0.6.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-core:0.6.0\")\n}\n</code></pre></p>"},{"location":"plotly-kt/plotlykt-geo/","title":"Module plotlykt-geo","text":""},{"location":"plotly-kt/plotlykt-geo/#usage","title":"Usage","text":""},{"location":"plotly-kt/plotlykt-geo/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:plotlykt-geo:0.6.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:plotlykt-geo:0.6.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-geo:0.6.0\")\n}\n</code></pre></p>"},{"location":"plotly-kt/plotlykt-jupyter/","title":"Module plotlykt-jupyter","text":""},{"location":"plotly-kt/plotlykt-jupyter/#usage","title":"Usage","text":""},{"location":"plotly-kt/plotlykt-jupyter/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:plotlykt-jupyter:0.6.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:plotlykt-jupyter:0.6.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-jupyter:0.6.0\")\n}\n</code></pre></p>"},{"location":"plotly-kt/plotlykt-script/","title":"Module plotlykt-script","text":""},{"location":"plotly-kt/plotlykt-script/#usage","title":"Usage","text":""},{"location":"plotly-kt/plotlykt-script/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:plotlykt-script:0.6.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:plotlykt-script:0.6.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-script:0.6.0\")\n}\n</code></pre></p>"},{"location":"plotly-kt/plotlykt-server/","title":"Module plotlykt-server","text":""},{"location":"plotly-kt/plotlykt-server/#usage","title":"Usage","text":""},{"location":"plotly-kt/plotlykt-server/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:plotlykt-server:0.6.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:plotlykt-server:0.6.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:plotlykt-server:0.6.0\")\n}\n</code></pre></p>"},{"location":"visionforge/","title":"DataForge Visualization Platform","text":""},{"location":"visionforge/#dataforge-visualization-platform","title":"DataForge Visualization Platform","text":""},{"location":"visionforge/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Requirements</li> <li>Features</li> <li>About DataForge</li> <li>Modules contained in this repository</li> <li>Visualization for External Systems</li> <li>Demonstrations</li> <li>Simple Example - Solid Showcase</li> <li>Full-Stack Application Example - Muon Monitor</li> <li>GDML Example</li> </ul>"},{"location":"visionforge/#introduction","title":"Introduction","text":"<p>This repository contains a DataForge-based framework used for visualization in various scientific applications.</p> <p>The main framework's use case for now is 3D visualization for particle physics experiments. Other applications including 2D plots are planned for the future.</p> <p>The project is developed as a Kotlin multiplatform application, currently targeting browser JavaScript and JVM.</p>"},{"location":"visionforge/#requirements","title":"Requirements","text":"<p>JVM backend requires JDK 11 or later</p>"},{"location":"visionforge/#features","title":"Features","text":"<p>The main framework's features for now include: - 3D visualization of complex experimental set-ups - Event display such as particle tracks, etc. - Scales up to few hundred thousands of elements - Camera move, rotate, zoom-in and zoom-out - Scene graph as an object tree with property editor - Settings export and import - Multiple platform support</p>"},{"location":"visionforge/#about-dataforge","title":"About DataForge","text":"<p>DataForge is a software framework for automated scientific data processing. DataForge Visualization Platform uses some of the concepts and modules of DataForge, including: <code>Meta</code>, <code>Configuration</code>, <code>Context</code>, <code>Provider</code>, and some others.</p> <p>To learn more about DataForge, please consult the following URLs: * Kotlin multiplatform implementation of DataForge * DataForge documentation * Original implementation of DataForge</p>"},{"location":"visionforge/#modules-contained-in-this-repository","title":"Modules contained in this repository","text":"<p>Class diagram:</p> <p></p>"},{"location":"visionforge/#cern-root-loader","title":"cern-root-loader","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#demo","title":"demo","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#jupyter","title":"jupyter","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#ui","title":"ui","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-core","title":"visionforge-core","text":"<p>Maturity: DEVELOPMENT</p>"},{"location":"visionforge/#visionforge-fx","title":"visionforge-fx","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"visionforge/#visionforge-gdml","title":"visionforge-gdml","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-markdown","title":"visionforge-markdown","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-plotly","title":"visionforge-plotly","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-server","title":"visionforge-server","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-solid","title":"visionforge-solid","text":"<p>Maturity: DEVELOPMENT</p>"},{"location":"visionforge/#visionforge-tables","title":"visionforge-tables","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"visionforge/#visionforge-threejs","title":"visionforge-threejs","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#gdml","title":"gdml","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#js-playground","title":"js-playground","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#muon-monitor","title":"muon-monitor","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#playground","title":"playground","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#plotly-fx","title":"plotly-fx","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#sat-demo","title":"sat-demo","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#solid-showcase","title":"solid-showcase","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-jupyter-gdml","title":"visionforge-jupyter-gdml","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#bootstrap","title":"bootstrap","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#react","title":"react","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#ring","title":"ring","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#visionforge-threejs-server","title":"visionforge-threejs-server","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"visionforge/#prototypes","title":"Prototypes","text":"<p>One of the important features of the framework is support for 3D object prototypes (sometimes also referred to as templates). The idea is that prototype geometry can be rendered once and reused for multiple objects. This helps to significantly decrease memory usage.</p> <p>The <code>prototypes</code> property tree is defined in <code>SolidGroup</code> class via <code>PrototypeHolder</code> interface, and <code>SolidReference</code> class helps to reuse a template object.</p>"},{"location":"visionforge/#styles","title":"Styles","text":"<p><code>VisionGroup</code> has a <code>styleSheet</code> property that can optionally define styles at the Group's level. Styles are applied to child (descendant) objects using <code>Vision.styles: List&lt;String&gt;</code> property.</p>"},{"location":"visionforge/#visionforge-threejs_1","title":"visionforge-threejs","text":""},{"location":"visionforge/#visualization-for-external-systems","title":"Visualization for External Systems","text":"<p>The <code>visionforge</code> framework can be used to visualize geometry and events from external, non-Kotlin based systems, such as ROOT. This will require a plugin to convert data model of the external system to that of <code>visionforge</code>. Performing such integration is a work currently in progress.</p>"},{"location":"visionforge/#demonstrations","title":"Demonstrations","text":"<p>The <code>demo</code> module contains several example projects (demonstrations) of using the <code>visionforge</code> framework. They are briefly described in this section, for more details please consult the corresponding per-project README file.</p>"},{"location":"visionforge/#simple-example-solid-showcase","title":"Simple Example - Solid Showcase","text":"<p>Contains a simple demonstration with a grid including a few shapes that you can rotate, move camera, and so on. Some shapes will also periodically change their color and visibility.</p> <p>More details</p> <p>Example view:</p> <p></p>"},{"location":"visionforge/#full-stack-application-example-muon-monitor-visualization","title":"Full-Stack Application Example - Muon Monitor Visualization","text":"<p>A full-stack application example, showing the Muon Monitor experiment set-up.</p> <p>More details</p> <p>Example view:</p> <p></p>"},{"location":"visionforge/#gdml-example","title":"GDML Example","text":"<p>Visualization example for geometry defined as GDML file.</p> <p>More details</p>"},{"location":"visionforge/#example-view","title":"Example view:","text":""},{"location":"visionforge/#thanks-and-references","title":"Thanks and references","text":"<p>The original three.js bindings were made by Lars Ivar Hatledal, but the project is discontinued right now.</p> <p>All other libraries are explicitly shown as dependencies. We would like to express specific thanks to JetBrains Kotlin-JS team for consulting us during the work.</p>"},{"location":"visionforge/cern-root-loader/","title":"Module cern-root-loader","text":""},{"location":"visionforge/demo/","title":"Module demo","text":""},{"location":"visionforge/demo/gdml/","title":"Module gdml","text":""},{"location":"visionforge/demo/js-playground/","title":"Module js-playground","text":""},{"location":"visionforge/demo/muon-monitor/","title":"Module muon-monitor","text":""},{"location":"visionforge/demo/playground/","title":"Module playground","text":""},{"location":"visionforge/demo/plotly-fx/","title":"Module plotly-fx","text":""},{"location":"visionforge/demo/sat-demo/","title":"Module sat-demo","text":""},{"location":"visionforge/demo/solid-showcase/","title":"Module solid-showcase","text":""},{"location":"visionforge/docs/appendix/","title":"Appendix","text":""},{"location":"visionforge/docs/appendix/#appendix","title":"Appendix","text":""},{"location":"visionforge/docs/appendix/#dataforge-name","title":"DataForge Name","text":""},{"location":"visionforge/docs/appendix/#dataforge-meta","title":"DataForge Meta","text":""},{"location":"visionforge/docs/appendix/#dataforge-context","title":"DataForge Context","text":""},{"location":"visionforge/docs/design/","title":"Design","text":""},{"location":"visionforge/docs/design/#library-design","title":"Library design","text":"<p>The central point of the library design is the <code>Vision</code> interface. The <code>Vision</code> stores an optional reference to its parent and is able to store a number of mutable or read-only properties. Each property is represented by its <code>Name</code>, and a <code>Meta</code> value-tree, both following DataForge library specification (discussed in the Appendix). The <code>Vision</code> objects are organized in a tree using <code>VisionGroup</code> as nodes. <code>VisionGroup</code> additionally to all <code>Vision</code> properties holds a <code>children</code> container that holds named references to its direct children <code>Vision</code>s. Thus, <code>Vision</code>s form a doubly linked tree (a parent stores references to all its children and children store a reference to the parent).</p> <p>An important concept using in the VisionForge is the property layering mechanism. It means that if the property with a given name is not found in the <code>Vision</code> it is requested from, it could be requested from the parent <code>Vision</code>, form the style declaration, the prototype for the vision or any other place defined by the component author. For example, let's take a <code>color</code> attribute used in 3D visualization. When one draws a group of objects, he usually wants to make the color of all objects in the group to be defined by a single handle in the group common ancestor. So when the parent color changes, all children color must follow suite, but we also want to change children color individually without changing the parent. In this case two property layers are defined:</p> <ul> <li>own properties layer</li> <li>parent properties layer</li> </ul> <p>When the user or a part of inner program mechanics requests a property, it searched in <code>Vision</code> own properties. If it is defined there, it is returned, if not, the search continues to the parent properties and up the parentage chain. So if the parent color is defined and children colors are blank, then the parent color will be used. If one of children redefines its own color, then this color is used for this specific color, and the parent color used for all other children. The change of parent property automatically propagated to all children.</p>"},{"location":"visionforge/docs/design/#styling","title":"Styling","text":"<p>The actual layering scheme is more complicated. All objects support styling. The styles are named <code>Meta</code> nodes that could be used to define groups of properties together and use in different <code>Vision</code>s. The styles are defined as named <code>Meta</code> nodes in a <code>VisionGroup</code> <code>@stylesheet</code> property (DataForge states that names starting with <code>@</code> are reserved for system properties, not visible by default to the user). The style or a list of styles could be applied to a <code>Vision</code> by setting the reserved <code>@style</code> property to the name of the style being used or by using <code>Vision::style</code> extension property. The style name is then resolved to the nearest ancestor that defines it. The key difference from the CSS styling in HTML is that the stylesheets could be added to any node, not only to the hierarchy root. It allows to decouple the whole subtrees together with styles from the main <code>Vision</code> graph, or create stand-alone branches. One must note, that the same style could be defined on different levels of the tree, only the nearest ancestor is resolved, meaning that one can override styles for a sub-tree.</p>"},{"location":"visionforge/docs/design/#intermediate-representation","title":"Intermediate representation","text":"<p>An important thing about VisionForge is that it does not strictly bound to a single format representation.</p>"},{"location":"visionforge/docs/design/#kotlin-dsl-for-creating-vision-graphs","title":"Kotlin DSL for creating vision-graphs","text":""},{"location":"visionforge/docs/features/","title":"Features","text":""},{"location":"visionforge/docs/features/#features","title":"Features","text":""},{"location":"visionforge/docs/features/#customization-and-plugins","title":"Customization and plugins","text":""},{"location":"visionforge/docs/features/#full-stack-development","title":"Full-stack development","text":""},{"location":"visionforge/docs/hierarchy/","title":"Hierarchy","text":""},{"location":"visionforge/docs/hierarchy/#vision","title":"Vision","text":"<ul> <li> <p>function <code>getProperty(name: Name, inherit: Boolean = false, includeStyles: Boolean = true, includeDefaults: Boolean = true)</code> - get property value with given layer flags.</p> </li> <li> <p>function <code>setProperty(name: Name, item: Any?)</code> - a convenient method to set property node or value. If <code>item</code> is null, then node is removed, not a value   Sets the <code>item</code> property to the element with the <code>name</code> identification.</p> </li> </ul>"},{"location":"visionforge/docs/hierarchy/#visionbase","title":"VisionBase","text":"<p>Basic vision implementation</p>"},{"location":"visionforge/docs/hierarchy/#visiongroup","title":"VisionGroup","text":"<p>A group of Visions.</p>"},{"location":"visionforge/docs/hierarchy/#mutablevisiongroup","title":"MutableVisionGroup","text":"<p>Mutable version of VisionGroup.</p> <p>low structure changes of this group. Unconsumed changes are discarded.</p>"},{"location":"visionforge/docs/hierarchy/#solid","title":"Solid","text":"<p>Interface for 3-dimensional Vision.</p>"},{"location":"visionforge/docs/hierarchy/#solidgroup","title":"SolidGroup","text":"<p>3D Visual Group with a container for templates visible inside this group. It has an interface <code>PrototypeHolder</code> which stands for being a container with prototype support.</p> <ul> <li> <p>function <code>getPrototype(name: Name)</code> - get a prototype redirecting the request to the parent if prototype is not found. If prototype is a ref, then it is unfolded automatically.</p> </li> <li> <p>function <code>prototypes(builder: VisionContainerBuilder&lt;Solid&gt;.() -&gt; Unit)</code> - create or edit prototype node as a group.</p> </li> </ul>"},{"location":"visionforge/docs/hierarchy/#solidreferencegroup","title":"SolidReferenceGroup","text":"<p>A class with <code>SolidReference</code> interface with reference <code>Solid</code>s for template objects reuse.</p>"},{"location":"visionforge/docs/hierarchy/#visiongroupbase","title":"VisionGroupBase","text":"<p>Abstract implementation of mutable group of <code>Vision</code>.</p>"},{"location":"visionforge/docs/hierarchy/#rootvisiongroup","title":"RootVisionGroup","text":"<p>Non-serializable root group used to propagate manager to its children.</p>"},{"location":"visionforge/docs/hierarchy/#mutablevisiongroup_1","title":"MutableVisionGroup","text":"<p>Just a mutable version of <code>VisionGroup</code></p>"},{"location":"visionforge/docs/inheritance/","title":"Inheritance","text":""},{"location":"visionforge/docs/inheritance/#inheritance","title":"Inheritance","text":"<p>Inheritance is an ability of an element to transfer a pack of properties to its <code>children</code> elements 'wrapped inside'.</p> <p>Properties, which can be inherited by objects, are <code>styles</code>, <code>prototypes</code> (if the object is a reference), <code>inherit</code> (it stands for the presence of <code>parent</code> objects), and <code>defaults</code>. </p> <p>All values of <code>styles</code> property are contained in class <code>StyleSheet</code>, where they all are defined at <code>Group</code>s level. The <code>prototypes</code> property tree is defined in <code>SolidGroup</code> class via <code>PrototypeHolder</code> interface, and <code>SolidReference</code> class helps to reuse a template object. </p> <p>The order of inheritance of properties is set in function <code>getProperty</code> in <code>VisionBase</code> class. The order is this: * own styles * prototypes * parent * parent's styles * defaults</p> <p>Let's take a closer look using a Muon Monitor Visualization. Running the demo, we will see this:</p> <p></p> <p>You can see a tree of elements on the left; 'World' is a <code>root</code>, 'bottom', 'middle', and 'top' are 'World's <code>children</code> and so on.</p> <p></p> <p>On the right, there is a list with changeable properties.</p> <p></p> <p>Properties, which can or cannot be inherited, are these: * <code>visible</code> \u2013 toggles the visibility of an element. To be exact, the invisibility of an element is inheritable.   If a <code>parent</code> element is invisible, other elements are invisible as well, and they cannot be changed to visible mode.    </p> <ul> <li><code>material</code> \u2013 a group of properties, which can be inherited and which can be changed in <code>children</code> elements.</li> <li><code>color</code> \u2013 color of an element.</li> <li><code>opacity</code> \u2013 a number from 0 to 1 which represents percents of opacity (0 for 0%, 1 for 100%).</li> <li><code>wireframe</code> \u2013 toggles the wireframe mode.</li> </ul> <p>Let's see how elements of the <code>material</code> group inherit changing <code>color</code> property; other properties of this group inherit in the same way.</p> <p>Let's change color of 'World' element:      It is a <code>parent</code>, so 'bottom', 'middle', and 'top' elements inherit this color.</p> <p>Now, let's change 'top's color:      It changes only, 'bottom' and 'middle' stays the same.</p> <p>'top' is a <code>parent</code> element as well: it has <code>children</code> \u2013 'SC72', 'SC73', ... ,'SC80'.   Let's change the color of 'SC76':      Again, only 'SC76' has changed among other 'siblings'.</p> <p>However, 'SC76' is a <code>parent</code> too. Let's change one of its <code>children</code> color (here we change 'SC76_5's color'):   </p> <p>As we can see, <code>color</code> is inheritable property, which can be changed in a custom way.</p> <p>If after all those changes we set at the 'World' element grey color, changes won't disappear:   </p> <ul> <li><code>rotation</code> \u2013 rotation of an element. Here, it is set by <code>x</code> value. It is inheritable and unable to be changed in <code>children</code> elements.</li> <li><code>position</code> \u2013 position of an element, cannot be inherited.</li> </ul>"},{"location":"visionforge/docs/solids/","title":"Solids","text":""},{"location":"visionforge/docs/solids/#solids","title":"Solids","text":"<p>The primary initial goal of creating the library was to provide a flexible API and rendering engine to draw solid geometric forms for so-called event display task in particle physics. Event display is used to provide visualization for particle hit events in both accelerator and non-accelerator experiments (see [add links here] for examples). The event display system must have a way to render basic 3D shapes like boxes, tubes and spheres and particle tracks. An additional requirement is to be able to change coloring and transparency of different elements as well as custom attributes specific to the problem.</p> <p>The <code>Solid</code> class inherits the <code>Vision</code> and has three additional nullable real vector properties: <code>position</code>, <code>rotation</code> and <code>scale</code>. Those properties are placed on the top level of the class instead of <code>properties</code> tree for performance optimization purposes. The <code>position</code> and <code>rotation</code> properties reflect the position offset in absolute units and rotation in radians relative to the parent and have defaults of <code>0.0</code>. Relativity means that if the parent <code>Vision</code> (<code>SolidGroup</code>) has <code>position = (1.0, 0.0, 1.0)</code> and a child has <code>position = (0.0, 2.0, 0.0)</code>, then the real offset of rendered object will be <code>(1.0, 2.0, 1.0)</code>. The same goes for the rotation. By default, the rotation uses intrinsic Cordan (Tait\u2013Bryan) angles with <code>XYZ</code> order, but order could be changed with an inherited property <code>rotation.order</code>. The <code>scale</code> property is not inherited and represents local <code>Solid</code> scaling factor with default value of <code>1.0</code>.</p> <p>The <code>SolidGroup</code> represents the specific kind of <code>VisionGroup</code> that has properties of a <code>Solid</code> and has one additional special property: the prototype container.</p>"},{"location":"visionforge/docs/solids/#solid-prototypes","title":"Solid prototypes","text":"<p>One of the important requirements for event display system is the ability to render a huge number of primitives (tens and hundreds of thousands). This is especially important for accelerator experiments with fine-grained calorimeter detectors ([ref here]). The most memory and CPU-consuming task to render such structures is computing the geometry o equal elements (like calorimeter cells). In order to optimize rendering and model representation for such cases, we introduced so-called prototypes. The idea is that multiple visions could have the same prototype and share the definition and actual rendered geometry. The prototypes are stored in a special container property called <code>prototypes</code> in a <code>SolidGroup</code> object. In order to access those prototypes there is a special <code>Solid</code> object called <code>SolidReference</code>. It inherits <code>Solid</code> (has properties container, position, rotation and scale), but does not define any geometry. Instead, it has a single <code>refName</code> property which stores a fully qualified DataForge <code>Name</code> (see Appendix) that designates the name of the prototype to be used. During rendering phase, the system searches for appropriate prototype in the nearest parent. If the prototype is not found, the search continues in the next parent in the chain. Like property resolution, the prototype resolution is fine-grained and local, meaning that a part of <code>Vision</code> graph could be self-contained together with prototypes.</p> <p>An important point is that prototypes are resolved in a parent vision container, and the parent vision container for prototypes is the vision group. It means that prototype itself could reference a prototype, or even in corner cases reference itself (such cases should be checked for infinite loops). The prototype relation example is shown in prototypes.uml. Here <code>Prototype Ref</code> vision references the <code>Prototype</code> vision by first seeking up to <code>VirionGroup</code>, the resolving the prototype with appropriate name. In theory, vision groups inside prototypes groups could contain the prototypes of their own, but such constructs should be used with care.</p>"},{"location":"visionforge/docs/solids/#solid-definitions","title":"Solid definitions","text":"<p>Solid models are defined as kotlin classes that also serve as builders for DSL and serialization models. For example, here is the definition for a <code>Box</code> class:</p> <pre><code>@Serializable\n@SerialName(\"solid.box\")\nclass Box(\n    val xSize: Float,\n    val ySize: Float,\n    val zSize: Float\n) : SolidBase(), GeometrySolid \n</code></pre> <p>In general, one does not define how specific solid is rendered, it is done in the rendering back-end. It means that in general, there should be a specific renderer defined for each type of solids defined in the model. Some solids have additional mechanism to avoid providing renderers for each primitive. Classes that inherit <code>GeometrySolid</code> interface provide a way to define geometry via polygons like this:</p> <pre><code>    override fun &lt;T : Any&gt; toGeometry(geometryBuilder: GeometryBuilder&lt;T&gt;) {\n        val dx = xSize / 2\n        val dy = ySize / 2\n        val dz = zSize / 2\n        val node1 = Point3D(-dx, -dy, -dz)\n        val node2 = Point3D(dx, -dy, -dz)\n        val node3 = Point3D(dx, dy, -dz)\n        val node4 = Point3D(-dx, dy, -dz)\n        val node5 = Point3D(-dx, -dy, dz)\n        val node6 = Point3D(dx, -dy, dz)\n        val node7 = Point3D(dx, dy, dz)\n        val node8 = Point3D(-dx, dy, dz)\n        geometryBuilder.face4(node1, node4, node3, node2)\n        geometryBuilder.face4(node1, node2, node6, node5)\n        geometryBuilder.face4(node2, node3, node7, node6)\n        geometryBuilder.face4(node4, node8, node7, node3)\n        geometryBuilder.face4(node1, node5, node8, node4)\n        geometryBuilder.face4(node8, node5, node6, node7)\n    }\n</code></pre> <p>The <code>GeometryBuilder</code> instance is provided by the specific rendering engine, so the polygons are generated for target engine without intermediate steps. If the renderer provides its own implementation for a solid renderer, it takes precedence over generic <code>GeometrySolid</code> definition.</p> <p>An important basic solid is the <code>Composite</code>. It is a primitive, that allows combine two (maybe more in future) primitives via composite solid geometry or CSG transformations (union, difference and subtraction). At this moment, the actual transformation is done on the renderer side.</p>"},{"location":"visionforge/docs/solids/#gdml-bindings","title":"GDML bindings","text":"<p>VisionForge supports extensible geometry primitive list, but we've started with primitives needed to render BM@N ([ref]) GDML ([ref]) geometry. GDML files are read with gdml.kt package designed specifically for this purpose. The package uses https://github.com/pdvrieze/xmlutil serialization plugin to parse GDML structure into the convenient object structure and has language definitions for all GDML primitives. The <code>visionforge-gdml</code> module contains a converter that transforms Gdml.kt structures into <code>Solid</code>.</p> <p>The GDML file definition contains several sections:</p> <ul> <li>defines - Dimensions and numbers for geometries.</li> <li>materials - Material definitions.</li> <li>solids - Primitive definitions and their composition.</li> <li>structure - Combinations of solids and groups used in geometry.</li> <li>setup - Metadata and geometry entry point.</li> </ul> <p>GDML materials are currently used only for Solid coloring. The data from material is stored in the <code>Vision</code> properties. Solids section and structures are transformed into top level group prototypes, which allows not only to create a compact representation, but also optimize rendering. The gdml structure is not always flexible. For example, it is not possible to add a solid directly into a group, but instead one needs to add a group with a single element. Problems like this could be automatically optimized by the convertor.</p> <p>Not all GDML solids are currently supported by the converter, they could be added later on-demand. Current support covers all solids used in BM@N geometry.</p>"},{"location":"visionforge/docs/solids/#threejs-renderer","title":"ThreeJs renderer","text":"<p>VisionForge is not tied to any single renderer. Right now the primary target is the Browser rendering with Three.js library. The Three.js supports different renderers including WebGL with hardware support and virtual reality.</p> <p>The bindings for three-js was implemented in kotlin-js based on a work by Lars Ivar Hatledal. The wrapper allows seamless integration with a lot of different library APIs including custom cameras and CSG.</p>"},{"location":"visionforge/docs/templates/ARTIFACT-TEMPLATE/","title":"ARTIFACT TEMPLATE","text":""},{"location":"visionforge/docs/templates/ARTIFACT-TEMPLATE/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>${group}:${name}:${version}</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"${group}:${name}:${version}\")\n}\n</code></pre></p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/","title":"README TEMPLATE","text":""},{"location":"visionforge/docs/templates/README-TEMPLATE/#dataforge-visualization-platform","title":"DataForge Visualization Platform","text":""},{"location":"visionforge/docs/templates/README-TEMPLATE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Requirements</li> <li>Features</li> <li>About DataForge</li> <li>Modules contained in this repository</li> <li>Visualization for External Systems</li> <li>Demonstrations</li> <li>Simple Example - Solid Showcase</li> <li>Full-Stack Application Example - Muon Monitor</li> <li>GDML Example</li> </ul>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#introduction","title":"Introduction","text":"<p>This repository contains a DataForge-based framework used for visualization in various scientific applications.</p> <p>The main framework's use case for now is 3D visualization for particle physics experiments. Other applications including 2D plots are planned for the future.</p> <p>The project is developed as a Kotlin multiplatform application, currently targeting browser JavaScript and JVM.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#requirements","title":"Requirements","text":"<p>JVM backend requires JDK 11 or later</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#features","title":"Features","text":"<p>The main framework's features for now include: - 3D visualization of complex experimental set-ups - Event display such as particle tracks, etc. - Scales up to few hundred thousands of elements - Camera move, rotate, zoom-in and zoom-out - Scene graph as an object tree with property editor - Settings export and import - Multiple platform support</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#about-dataforge","title":"About DataForge","text":"<p>DataForge is a software framework for automated scientific data processing. DataForge Visualization Platform uses some of the concepts and modules of DataForge, including: <code>Meta</code>, <code>Configuration</code>, <code>Context</code>, <code>Provider</code>, and some others.</p> <p>To learn more about DataForge, please consult the following URLs: * Kotlin multiplatform implementation of DataForge * DataForge documentation * Original implementation of DataForge</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#modules-contained-in-this-repository","title":"Modules contained in this repository","text":"<p>${modules}</p> <p>Class diagram:</p> <p></p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#prototypes","title":"Prototypes","text":"<p>One of the important features of the framework is support for 3D object prototypes (sometimes also referred to as templates). The idea is that prototype geometry can be rendered once and reused for multiple objects. This helps to significantly decrease memory usage.</p> <p>The <code>prototypes</code> property tree is defined in <code>SolidGroup</code> class via <code>PrototypeHolder</code> interface, and <code>SolidReference</code> class helps to reuse a template object.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#styles","title":"Styles","text":"<p><code>VisionGroup</code> has a <code>styleSheet</code> property that can optionally define styles at the Group's level. Styles are applied to child (descendant) objects using <code>Vision.styles: List&lt;String&gt;</code> property.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#visionforge-threejs","title":"visionforge-threejs","text":""},{"location":"visionforge/docs/templates/README-TEMPLATE/#visualization-for-external-systems","title":"Visualization for External Systems","text":"<p>The <code>visionforge</code> framework can be used to visualize geometry and events from external, non-Kotlin based systems, such as ROOT. This will require a plugin to convert data model of the external system to that of <code>visionforge</code>. Performing such integration is a work currently in progress.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#demonstrations","title":"Demonstrations","text":"<p>The <code>demo</code> module contains several example projects (demonstrations) of using the <code>visionforge</code> framework. They are briefly described in this section, for more details please consult the corresponding per-project README file.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#simple-example-solid-showcase","title":"Simple Example - Solid Showcase","text":"<p>Contains a simple demonstration with a grid including a few shapes that you can rotate, move camera, and so on. Some shapes will also periodically change their color and visibility.</p> <p>More details</p> <p>Example view:</p> <p></p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#full-stack-application-example-muon-monitor-visualization","title":"Full-Stack Application Example - Muon Monitor Visualization","text":"<p>A full-stack application example, showing the Muon Monitor experiment set-up.</p> <p>More details</p> <p>Example view:</p> <p></p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#gdml-example","title":"GDML Example","text":"<p>Visualization example for geometry defined as GDML file.</p> <p>More details</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#example-view","title":"Example view:","text":""},{"location":"visionforge/docs/templates/README-TEMPLATE/#stability-and-documentation","title":"Stability and documentation","text":"<p>VisionForge is a modular library. Different modules provide different features with different API stability guarantees. All core modules are released with the same version, but with different API change policy. The features are described in module definitions below. The module stability could have the following levels:</p> <ul> <li>PROTOTYPE. On this level there are no compatibility guarantees. All methods and classes form those modules could break any moment. You can still use it, but be sure to fix the specific version.</li> <li>EXPERIMENTAL. The general API is decided, but some changes could be made. Volatile API is marked   with <code>@DFExperimental</code> or other stability warning annotations.</li> <li>DEVELOPMENT. API breaking generally follows semantic versioning ideology. There could be changes in minor   versions, but not in patch versions. API is protected with binary-compatibility-validator tool.</li> <li>STABLE. The API stabilized. Breaking changes are allowed only in major releases.</li> </ul> <p>Additionally, one should note that the VisionForge Json format impacts the reproducibility of stored vision fragments. There should not be any breaks of the format between major releases. All problems should be reported.</p> <p>The documentation for the project is a work in progress. Please report any issues with missing, vague or wrong information. The contributions into documentation are quite welcome.</p>"},{"location":"visionforge/docs/templates/README-TEMPLATE/#thanks-and-references","title":"Thanks and references","text":"<p>The original three.js bindings were made by Lars Ivar Hatledal, but the project is discontinued right now.</p> <p>All other libraries are explicitly shown as dependencies. We would like to express specific thanks to JetBrains Kotlin-JS team for consulting us during the work.</p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/","title":"Tutorial","text":""},{"location":"visionforge/docs/tutorials/tutorial-solids/#the-main-goal-of-this-tutorial-is-to-show-the-main-capabilities-of-the-visualization-instrument","title":"The main goal of this tutorial is to show the main capabilities of the visualization instrument.","text":"<p>The simple visualization can be made with function <code>main</code>. (this part will be supplemented) <pre><code>import kotlinx.html.div\nimport space.kscience.dataforge.context.Context\nimport space.kscience.visionforge.html.ResourceLocation\nimport space.kscience.visionforge.solid.*\nimport java.nio.file.Paths\n\nfun main(){\n    val context = Context{\n        plugin(Solids)\n    }\n\n    context.makeVisionFile (\n        Paths.get(\"nameFile.html\"),\n        resourceLocation = ResourceLocation.EMBED\n    ){\n        div {\n           //first vision\n            vision {\n                solid {\n                    //solids which you want to visualize\n                }\n            }\n           //second vision\n           vision {\n              solid {\n                 //solids which you want to visualize\n              }\n           }\n        }\n    }\n}\n</code></pre></p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#solids-properties","title":"Solids properties","text":"<p>We will analyze which basic properties solids have using <code>box</code> solid.</p> <p>Basic properties: 1. <code>opacity</code> \u2014 It is set in <code>float</code>. It takes on values from 0 to 1, which represent percents of solid opacity. It's initial value is 1. 2. <code>color</code> \u2014 It can be specified as <code>Int</code>, <code>String</code>, or as three <code>Ubytes</code>, which represent color in <code>rgb</code>. Elementally, the solid will have <code>green</code> color. 3. <code>rotation</code> \u2014 it's the point, which sets rotations along axes. Initially, the value is <code>Point3D(0, 0, 0)</code>. Changing <code>x</code> coordinate of the point, you make pivot around <code>x axis</code>. The same for other coordinates: changing <code>y</code> \u2014 pivot around <code>y axis</code>, changing <code>z</code> \u2014 pivot around <code>z axis</code>. 4. position, which is given by values <code>x</code>, <code>y</code>, <code>z</code>. Initial values are <code>x = 0</code>, <code>y = 0</code>, <code>z = 0</code>. The coordinate system is Cartesian. It's elemental position is this \u2014 vertical <code>y</code> axis and horizontal <code>Oxz</code> plane.</p> <p>Let's see how properties are set in solids. The <code>small box</code> will have elemental values of properties. If you don't set properties, it will have the same <code>position</code>, <code>color</code>, <code>rotation</code>, and <code>opacity</code> values.</p> <p>You can see that <code>box</code> take four values. Later, we will discuss what they do in more detail. Now, it does not really matter. <pre><code>box(10, 10, 10, name = \"small box\"){\n   x = 0\n   y = 0\n   z = 0\n   opacity = 1 //100% opacity\n   color(\"red\") //as string\n   rotation = Point3D(0, 0, 0)\n}\n</code></pre> </p> <p>The <code>big box</code> will have properties with custom values.  <pre><code>box(40, 40, 40, name = \"big box\"){\n   x = 20\n   y = 10\n   z = 60\n   opacity = 0.5 //50% opacity\n   color(0u, 179u, 179u) //color in rgb\n   rotation = Point3D(60, 80, 0)\n}\n</code></pre>  If we compare these boxes, we will see all differences. </p> <p>Here is the function <code>main</code> with both boxes. <pre><code>fun main(){\n    val context = Context{\n        plugin(Solids)\n    }\n\n    context.makeVisionFile (\n        Paths.get(\"customFile.html\"),\n        resourceLocation = ResourceLocation.EMBED\n    ){\n        div {\n            vision {\n                solid {\n                   box(10, 10, 10, name = \"small box\"){\n                      x = 0\n                      y = 0\n                      z = 0\n                      opacity = 1 //100% opacity\n                      color(\"red\") //as string\n                      rotation = Point3D(0, 0, 0)\n                   }\n                   box(40, 40, 40, name = \"big box\"){\n                      x = 20\n                      y = 10\n                      z = 60\n                      opacity = 0.5 //50% opacity\n                      color(0u, 179u, 179u) //rgb\n                      rotation = Point3D(60, 80, 0)\n                   }\n                }\n            }\n        }\n    }\n}\n</code></pre> </p> <p>There is plenty of other properties, especially those, which you can create by yourself. Here we mention just a small part.</p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#basic-solids","title":"Basic Solids","text":"<p>Now, let's see which solids can be visualized:</p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#1-polyline","title":"1) PolyLine","text":"<p>It's scarcely a solid, but it can be visualized, so we mention it. <code>polyline</code> build lines, obviously. Let's take a look at it's work.</p> <p><code>polyline</code> requires two values \u2014 <code>points</code>, and <code>name</code>: * <code>points</code> is a <code>vararg</code> with <code>Point3D</code> type. It takes pairs of points, which you want to connect. * <code>name</code> is an identifier of any solid; but in this case, it is an identifier of <code>polyline</code>. It's type is <code>String</code>. This value can be required by any solid; you can set it, you can not to set it, but without you won't be able to control solid, since it won't be inherited.</p> <p>This is an example of polyline with other solid <code>box</code>: <pre><code>box(100, 100, 100, name = \"box\"){\n   x = -10\n   y = -10\n   z = -10\n   opacity = 0.4\n}\npolyline(Point3D(30, 20, 10), Point3D(30, -100, 30), Point3D(30, -100, 30), Point3D(50, -100, 30), name = \"polyline\"){\n   color(\"red\")\n}\n</code></pre></p> <p> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#2-box","title":"2) Box","text":"<p>First thing which has to be mentioned is that <code>box</code> takes four values: <code>box(x, y, z, name)</code> * <code>x</code> \u2014 x-axis length of the <code>box</code> * <code>y</code> \u2014 y-axis length of the <code>box</code> * <code>z</code> \u2014 z-axis length of the <code>box</code></p> <p>These values have <code>Float</code> type. </p> <p><code>x</code>, <code>y</code>, and <code>z</code> are necessary values, which cannot be ignored. You have to set them.</p> <ul> <li><code>name</code> \u2014 <code>box</code>'es identifier. You've already met it. </li> </ul> <p>Let's create just usual <code>box</code> with equal ribs.</p> <p><pre><code>   box(50, 50, 50, name = \"box\") {\n        color(\"pink\")\n   }\n</code></pre> </p> <p>Now, let's make <code>box</code> with bigger <code>y</code> value.    <pre><code>box(10, 25, 10, name = \"high box\") {\n     color(\"black\")\n}\n</code></pre> As you can see, only the rib of <code>y-axis</code> differs from other ribs.</p> <p></p> <p>For a final trial, let's create a <code>box</code> with a bigger <code>x</code> value.</p> <p><pre><code>box(65, 40, 40, name = \"wide box\") {\n     x = 0\n     y = 0\n     z = 0\n     color(\"black\")\n}\n</code></pre> Predictably, only the <code>x-axis</code> rib is bigger than other ribs. </p> <p></p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#3-sphere","title":"3) Sphere","text":"<p>It takes in two values: <code>radius</code>, and <code>name</code>.  We bring you to mind that <code>name</code> is a general value for all solids, so do not wonder, since all solids need their own identifier.</p> <p>As for <code>radius</code>, it has <code>Float</code> type, and, as you can guess, it sets the radius of the sphere which will be created.    <pre><code>sphere(50, name = \"sphere\") {\n     x = 0\n     y = 0\n     z = 0\n     opacity = 0.9\n     color(\"blue\")\n}\n</code></pre> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#4-hexagon","title":"4) Hexagon","text":"<p>It is solid which has six edges. It is set by eight values: <code>node1</code>,..., <code>node8</code>. They all have <code>Point3D</code> type, so they are just points, vertices.</p> <p>Six edges are these:  1) Edge with vertices <code>node1</code>, <code>node4</code>, <code>node3</code>, <code>node2</code> 2) Edge with vertices <code>node1</code>, <code>node2</code>, <code>node6</code>, <code>node5</code> 3) Edge with vertices <code>node2</code>, <code>node3</code>, <code>node7</code>, <code>node6</code> 4) Edge with vertices <code>node4</code>, <code>node8</code>, <code>node7</code>, <code>node3</code> 5) Edge with vertices <code>node1</code>, <code>node5</code>, <code>node8</code>, <code>node4</code> 6) Edge with vertices <code>node8</code>, <code>node5</code>, <code>node6</code>, <code>node7</code></p> <p></p> <p>As the hexagon takes in specific points, we understand that this solid cannot be moved, it is fixed in space, and it can't make pivots.</p> <p>Let's make classic parallelepiped. <pre><code>   hexagon(\n        Point3D(25, 30, 25),\n        Point3D(35, 30, 25),\n        Point3D(35, 30, 15),\n        Point3D(25, 30, 15),\n        Point3D(30, 18, 20),\n        Point3D(40, 18, 20),\n        Point3D(40, 18, 10),\n        Point3D(30, 18, 10),\n        name = \"classic hexagon\"){\n        color(\"green\")\n   }\n</code></pre> </p> <p>Now, let's make a custom hexagon.</p> <p><code>kotlin hexagon(     Point3D(5, 30, 5),     Point3D(24, 30, 8),     Point3D(20, 30, -10),     Point3D(5, 30, -7),     Point3D(8, 16, 0),     Point3D(12, 16, 0),     Point3D(10, 16, -5),     Point3D(6.5, 12, -3),     name = \"custom_hexagon\" ) {     color(\"brown\") }</code> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#3-cone","title":"3) Cone","text":"<p>It takes in six values: <code>bottomRadius</code>, <code>height</code>, <code>upperRadius</code>, <code>startAngle</code>, <code>angle</code>, and <code>name</code>. </p> <p>Obviously, <code>bottomRadius</code> is responsible for the radius of a bottom base, and <code>height</code> sets the height of a cone along the <code>z-axis</code>.</p> <p>As it takes such values as <code>upperRadius</code>, <code>startAngle</code>, <code>angle</code>, <code>cone</code> can build not only usual cones, but also cone segments. Initially, <code>upperRadius</code> will have <code>0.0</code> value, <code>startAngle</code> \u2014 <code>0f</code>, <code>angle</code> \u2014 <code>PI2</code>, so if you don't set them, you'll get just a simple cone. </p> <p>Setting <code>upperRadius</code>, you make a frustum cone, since it sets a radius of the upper base of a cone. Set <code>startAngle</code>, and <code>angle</code> let to cut off segments by planes perpendicular to the base. <code>startAngle</code> \u2014 an angle, starting with which segment will be left, <code>angle</code> \u2014 an angle of cone, which will be set from <code>startAngle</code>. </p> <p>Let's build a classic cone: <pre><code>   cone(60, 80, name = \"cone\") {\n         color(\"beige\")\n   }\n   ```\n   ![](../images/cone-1.png)\n   ![](../images/cone-2.png)\n\nFirst of all, we have to try to build a frustum cone:\n```kotlin\ncone(60, 80, name = \"cone\") {\n   color(0u, 40u, 0u)\n}\n</code></pre> </p> <p>Now, we need to make a try to build a cone segment:</p> <p><pre><code>cone(60, 80, angle = PI, name = \"cone\") {\n   color(0u, 0u, 200u)\n}\n</code></pre> </p> <p>Finally, the segment of frustum cone is left for a try: <pre><code>cone(60, 100, 20, PI*3/4, angle = PI/3, name = \"cone\") {\n   color(190u, 0u, 0u)\n}\n</code></pre> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#4-cone-surface","title":"4) Cone Surface","text":"<p>This solid is set by seven values:<code>bottomOuterRadius</code>, <code>bottomInnerRadius</code>, <code>height</code>, <code>topOuterRadius</code>, <code>topInnerRadius</code>, <code>startAngle</code>, and <code>angle</code>.</p> <p>In addition to <code>height</code>, <code>startAngle</code>, and <code>angle</code>, which work as they work in <code>cone</code>, there are some new values. <code>bottomOuterRadius</code>, and <code>bottomInnerRadius</code> set properties of the bottom circle, <code>topOuterRadius</code>, <code>topInnerRadius</code> \u2014 of the upper circle. They have no initial value, so that means they have to be set.</p> <p>Generally, <code>cone</code>, and <code>coneSurface</code> buildings work in the same way, it's possible to make <code>coneSurface</code>'s fragments as in <code>cone</code></p> <p>Let's build usual cone surface with almost all properties set: <pre><code>   coneSurface(60, 50, 30, 10, 100, name = \"cone surface\") {\n        color(\"red\")\n        rotation = Point3D(2, 50, -9)\n   }\n   ```\n![](../images/cone-surface-1.png)\n![](../images/cone-surface-2.png)\n\nNow, let's create a cone surface and set all it's properties:\n\n```kotlin\nconeSurface(30, 25, 10, 10, 8,0f, pi*3/4, name = \"cone surface\") {\n   color(\"fuchsia\")\n   rotation = Point3D(2, 50, -9)\n}\n</code></pre> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#5-cylinder","title":"5) Cylinder","text":"<p>This solid is set by <code>radius</code>, and <code>height</code>. As you can see by accepting values, there's no option of building fragments of cylinders.</p> <p>Here's a demonstration of a cylinder:</p> <p><pre><code>cylinder(40, 100, \"cylinder\"){\n   rotation = Point3D(40, 0, 0)\n   color(\"indigo\")\n}\n</code></pre> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#6-tube","title":"6) Tube","text":"<p><code>tube</code> takes in <code>radius</code>, <code>height</code>, <code>innerRadius</code>, <code>startAngle</code>, <code>angle</code>, and <code>name</code>. All values are familiar from <code>cone</code>, and <code>coneSurface</code> solids.</p> <p>Here is an example of classic tube: <pre><code>tube(50, 40, 20, name = \"usual tube\"){\n   opacity = 0.4\n}                    \n</code></pre> </p> <p>This is an example of tube fragment:</p> <p><pre><code>tube(50, 40, 20, 0f, PI, name = \"fragmented tube\"){    \n   color(\"white\")\n}\n</code></pre> </p>"},{"location":"visionforge/docs/tutorials/tutorial-solids/#7-extruded","title":"7) Extruded","text":"<p><code>extruded</code> is set by two values: <code>shape</code>, and <code>layer</code>.  * <code>shape</code> is a value of <code>List&lt;Point2D&gt;</code> type. It's just a list of all points of the solid. <code>shape</code> has to consist of not less than two points! * <code>layer</code> is <code>MutableList</code> types variable. (here is a sentence with a description of the work of this function). The amount of <code>layer</code>-s has to be more than one</p>"},{"location":"visionforge/ui/","title":"Module ui","text":""},{"location":"visionforge/ui/bootstrap/","title":"Module bootstrap","text":""},{"location":"visionforge/ui/react/","title":"Module react","text":""},{"location":"visionforge/ui/ring/","title":"Module ring","text":""},{"location":"visionforge/visionforge-core/","title":"Module visionforge-core","text":""},{"location":"visionforge/visionforge-core/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-core/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-core:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-core:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-core:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-fx/","title":"Module visionforge-fx","text":""},{"location":"visionforge/visionforge-fx/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-fx/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-fx:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-fx:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-fx:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-gdml/","title":"Module visionforge-gdml","text":""},{"location":"visionforge/visionforge-gdml/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-gdml/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-gdml:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-gdml:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-gdml:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-jupyter/","title":"Module jupyter","text":"<p>Common visionforge jupyter module</p>"},{"location":"visionforge/visionforge-markdown/","title":"Module visionforge-markdown","text":""},{"location":"visionforge/visionforge-markdown/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-markdown/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-markdown:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-markdown:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-markdown:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-plotly/","title":"Module visionforge-plotly","text":""},{"location":"visionforge/visionforge-plotly/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-plotly/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-plotly:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-plotly:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-plotly:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-server/","title":"Module visionforge-server","text":""},{"location":"visionforge/visionforge-server/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-server/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-server:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-server:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-server:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-solid/","title":"Module visionforge-solid","text":""},{"location":"visionforge/visionforge-solid/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-solid/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-solid:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-solid:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-solid:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-tables/","title":"Module visionforge-tables","text":""},{"location":"visionforge/visionforge-tables/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-tables/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-tables:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-tables:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-tables:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-threejs/","title":"Module visionforge-threejs","text":""},{"location":"visionforge/visionforge-threejs/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-threejs/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-threejs:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-threejs:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-threejs:0.2.0\")\n}\n</code></pre></p>"},{"location":"visionforge/visionforge-threejs/visionforge-threejs-server/","title":"Module visionforge-threejs-server","text":""},{"location":"visionforge/visionforge-threejs/visionforge-threejs-server/#usage","title":"Usage","text":""},{"location":"visionforge/visionforge-threejs/visionforge-threejs-server/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:visionforge-threejs-server:0.2.0</code>.</p> <p>Gradle Groovy: <pre><code>repositories {\n    maven { url 'https://repo.kotlin.link' }\n    mavenCentral()\n}\n\ndependencies {\n    implementation 'space.kscience:visionforge-threejs-server:0.2.0'\n}\n</code></pre> Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:visionforge-threejs-server:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/","title":"Controls.kt","text":""},{"location":"controls-kt/#controlskt","title":"Controls.kt","text":"<p>Controls.kt (former DataForge-control) is a data acquisition framework (work in progress). It is based on DataForge, a software framework for automated data processing. This repository contains a prototype of API and simple implementation of a slow control system, including a demo.</p> <p>Controls.kt uses some concepts and modules of DataForge, such as <code>Meta</code> (tree-like value structure).</p> <p>To learn more about DataForge, please consult the following URLs: * Kotlin multiplatform implementation of DataForge * DataForge documentation * Original implementation of DataForge</p> <p>DataForge-control is a Kotlin-multiplatform application. Asynchronous operations are implemented with kotlinx.coroutines library.</p>"},{"location":"controls-kt/#materials-and-publications","title":"Materials and publications","text":"<ul> <li>Video - A general overview seminar</li> <li>Video - A seminar about the system mechanics</li> <li>Article - A Novel Solution for Controlling Hardware Components of Accelerators and Beamlines</li> </ul>"},{"location":"controls-kt/#features","title":"Features","text":"<p>Among other things, you can: - Describe devices and their properties. - Collect data from devices and execute arbitrary actions supported by a device. - Property values can be cached in the system and requested from devices as needed, asynchronously. - Connect devices to event bus via bidirectional message flows.</p> <p>Example view of a demo:</p> <p></p>"},{"location":"controls-kt/#documentation","title":"Documentation","text":"<ul> <li>Creating a device</li> </ul>"},{"location":"controls-kt/#modules","title":"Modules","text":""},{"location":"controls-kt/#controls-core","title":"controls-core","text":"<p>Core interfaces for building a device server</p> <p>Maturity: EXPERIMENTAL</p> <p>Features: - device : Device API with subscription (asynchronous and pseudo-synchronous properties) - deviceMessage : Specification for messages used to communicate between Controls-kt devices. - deviceHub : Grouping of devices into local tree-like hubs. - deviceSpec : Mechanics and type-safe builders for devices. Including separation of device specification and device state. - deviceManager : DataForge DI integration for devices. Includes device builders. - ports : Working with asynchronous data sending and receiving raw byte arrays</p>"},{"location":"controls-kt/#controls-magix","title":"controls-magix","text":"<p>Magix service for binding controls devices (both as RPC client and server)</p> <p>Maturity: EXPERIMENTAL</p> <p>Features: - controlsMagix : Connect a <code>DeviceManage</code> with one or many devices to the Magix endpoint - DeviceClient : A remote connector to Controls-kt device via Magix</p>"},{"location":"controls-kt/#controls-modbus","title":"controls-modbus","text":"<p>A plugin for Controls-kt device server on top of modbus-rtu/modbus-tcp protocols</p> <p>Maturity: EXPERIMENTAL</p> <p>Features: - modbusRegistryMap : Type-safe modbus registry map. Allows to define both single-register and multi-register entries (using DataForge IO).  Automatically checks consistency. - modbusProcessImage : Binding of slave (server) modbus device to Controls-kt device - modbusDevice : A device with additional methods to work with modbus registers.</p>"},{"location":"controls-kt/#controls-opcua","title":"controls-opcua","text":"<p>A client and server connectors for OPC-UA via Eclipse Milo</p> <p>Maturity: EXPERIMENTAL</p> <p>Features: - opcuaClient : Connect a Controls-kt as a client to OPC UA server - opcuaServer : Create an OPC UA server on top of Controls-kt device (or device hub)</p>"},{"location":"controls-kt/#controls-pi","title":"controls-pi","text":"<p>Utils to work with controls-kt on Raspberry pi</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#controls-ports-ktor","title":"controls-ports-ktor","text":"<p>Implementation of byte ports on top os ktor-io asynchronous API</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#controls-serial","title":"controls-serial","text":"<p>Implementation of direct serial port communication with JSerialComm</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#controls-server","title":"controls-server","text":"<p>A combined Magix event loop server with web server for visualization.</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#controls-storage","title":"controls-storage","text":"<p>An API for stand-alone Controls-kt device or a hub.</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#demo","title":"demo","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magix","title":"magix","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#controls-storagecontrols-xodus","title":"controls-storage/controls-xodus","text":"<p>An implementation of controls-storage on top of JetBrains Xodus.</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#demoall-things","title":"demo/all-things","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#democar","title":"demo/car","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#demoecho","title":"demo/echo","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#demomagix-demo","title":"demo/magix-demo","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#demomany-devices","title":"demo/many-devices","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#demomks-pdr900","title":"demo/mks-pdr900","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#demomotors","title":"demo/motors","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-api","title":"magix/magix-api","text":"<p>A kotlin API for magix standard and some zero-dependency magix services</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-java-endpoint","title":"magix/magix-java-endpoint","text":"<p>Java API to work with magix endpoints without Kotlin</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-mqtt","title":"magix/magix-mqtt","text":"<p>MQTT client magix endpoint</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#magixmagix-rabbit","title":"magix/magix-rabbit","text":"<p>RabbitMQ client magix endpoint</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#magixmagix-rsocket","title":"magix/magix-rsocket","text":"<p>Magix endpoint (client) based on RSocket</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-server","title":"magix/magix-server","text":"<p>A magix event loop implementation in Kotlin. Includes HTTP/SSE and RSocket routes.</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-storage","title":"magix/magix-storage","text":"<p>Magix history database API</p> <p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#magixmagix-zmq","title":"magix/magix-zmq","text":"<p>ZMQ client endpoint for Magix</p> <p>Maturity: EXPERIMENTAL</p>"},{"location":"controls-kt/#magixmagix-storagemagix-storage-xodus","title":"magix/magix-storage/magix-storage-xodus","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"controls-kt/#demo-module","title":"<code>demo</code> module","text":"<p>The demo includes a simple mock device with a few properties changing as <code>sin</code> and <code>cos</code> of the current time. The device is configurable via a simple TornadoFX-based control panel. You can run a demo by executing <code>application/run</code> Gradle task.</p> <p>The graphs are displayed using plotly.kt library.</p>"},{"location":"controls-kt/controls-core/","title":"Module controls-core","text":"<p>Core interfaces for building a device server</p>"},{"location":"controls-kt/controls-core/#features","title":"Features","text":"<ul> <li>device : Device API with subscription (asynchronous and pseudo-synchronous properties)</li> <li>deviceMessage : Specification for messages used to communicate between Controls-kt devices.</li> <li>deviceHub : Grouping of devices into local tree-like hubs.</li> <li>deviceSpec : Mechanics and type-safe builders for devices. Including separation of device specification and device state.</li> <li>deviceManager : DataForge DI integration for devices. Includes device builders.</li> <li>ports : Working with asynchronous data sending and receiving raw byte arrays</li> </ul>"},{"location":"controls-kt/controls-core/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-core/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-core:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-core:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-magix/","title":"Module controls-magix","text":"<p>Magix service for binding controls devices (both as RPC client and server)</p>"},{"location":"controls-kt/controls-magix/#features","title":"Features","text":"<ul> <li>controlsMagix : Connect a <code>DeviceManage</code> with one or many devices to the Magix endpoint</li> <li>DeviceClient : A remote connector to Controls-kt device via Magix</li> </ul>"},{"location":"controls-kt/controls-magix/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-magix/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-magix:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-magix:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-modbus/","title":"Module controls-modbus","text":"<p>A plugin for Controls-kt device server on top of modbus-rtu/modbus-tcp protocols</p>"},{"location":"controls-kt/controls-modbus/#features","title":"Features","text":"<ul> <li>modbusRegistryMap : Type-safe modbus registry map. Allows to define both single-register and multi-register entries (using DataForge IO).  Automatically checks consistency.</li> <li>modbusProcessImage : Binding of slave (server) modbus device to Controls-kt device</li> <li>modbusDevice : A device with additional methods to work with modbus registers.</li> </ul>"},{"location":"controls-kt/controls-modbus/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-modbus/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-modbus:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-modbus:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-opcua/","title":"Module controls-opcua","text":"<p>A client and server connectors for OPC-UA via Eclipse Milo</p>"},{"location":"controls-kt/controls-opcua/#features","title":"Features","text":"<ul> <li>opcuaClient : Connect a Controls-kt as a client to OPC UA server</li> <li>opcuaServer : Create an OPC UA server on top of Controls-kt device (or device hub)</li> </ul>"},{"location":"controls-kt/controls-opcua/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-opcua/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-opcua:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-opcua:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-pi/","title":"Module controls-pi","text":"<p>Utils to work with controls-kt on Raspberry pi</p>"},{"location":"controls-kt/controls-pi/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-pi/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-pi:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-pi:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-ports-ktor/","title":"Module controls-ports-ktor","text":"<p>Implementation of byte ports on top os ktor-io asynchronous API</p>"},{"location":"controls-kt/controls-ports-ktor/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-ports-ktor/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-ports-ktor:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-ports-ktor:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-serial/","title":"Module controls-serial","text":"<p>Implementation of direct serial port communication with JSerialComm</p>"},{"location":"controls-kt/controls-serial/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-serial/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-serial:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-serial:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-server/","title":"Module controls-server","text":"<p>A combined Magix event loop server with web server for visualization.</p>"},{"location":"controls-kt/controls-server/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-server/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-server:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-server:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-storage/","title":"Module controls-storage","text":"<p>An API for stand-alone Controls-kt device or a hub.</p>"},{"location":"controls-kt/controls-storage/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-storage/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-storage:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-storage:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/controls-storage/controls-xodus/","title":"Module controls-xodus","text":"<p>An implementation of controls-storage on top of JetBrains Xodus.</p>"},{"location":"controls-kt/controls-storage/controls-xodus/#usage","title":"Usage","text":""},{"location":"controls-kt/controls-storage/controls-xodus/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:controls-xodus:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:controls-xodus:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/demo/","title":"Module demo","text":""},{"location":"controls-kt/demo/all-things/","title":"Module all-things","text":""},{"location":"controls-kt/demo/car/","title":"Module car","text":""},{"location":"controls-kt/demo/echo/","title":"Module echo","text":""},{"location":"controls-kt/demo/magix-demo/","title":"Module magix-demo","text":""},{"location":"controls-kt/demo/many-devices/","title":"Module many-devices","text":""},{"location":"controls-kt/demo/mks-pdr900/","title":"Module mks-pdr900","text":""},{"location":"controls-kt/demo/motors/","title":"Module motors","text":""},{"location":"controls-kt/magix/magix-api/","title":"Module magix-api","text":"<p>A kotlin API for magix standard and some zero-dependency magix services</p>"},{"location":"controls-kt/magix/magix-api/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-api/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-api:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-api:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-java-endpoint/","title":"Module magix-java-endpoint","text":"<p>Java API to work with magix endpoints without Kotlin</p>"},{"location":"controls-kt/magix/magix-java-endpoint/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-java-endpoint/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-java-endpoint:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-java-endpoint:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-mqtt/","title":"Module magix-mqtt","text":"<p>MQTT client magix endpoint</p>"},{"location":"controls-kt/magix/magix-mqtt/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-mqtt/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-mqtt:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-mqtt:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-rabbit/","title":"Module magix-rabbit","text":"<p>RabbitMQ client magix endpoint</p>"},{"location":"controls-kt/magix/magix-rabbit/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-rabbit/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-rabbit:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-rabbit:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-rsocket/","title":"Module magix-rsocket","text":"<p>Magix endpoint (client) based on RSocket</p>"},{"location":"controls-kt/magix/magix-rsocket/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-rsocket/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-rsocket:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-rsocket:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-server/","title":"Module magix-server","text":"<p>A magix event loop implementation in Kotlin. Includes HTTP/SSE and RSocket routes.</p>"},{"location":"controls-kt/magix/magix-server/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-server/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-server:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-server:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-storage/","title":"Module magix-storage","text":"<p>Magix history database API</p>"},{"location":"controls-kt/magix/magix-storage/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-storage/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-storage:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-storage:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-storage/magix-storage-xodus/","title":"Module magix-storage-xodus","text":""},{"location":"controls-kt/magix/magix-storage/magix-storage-xodus/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-storage/magix-storage-xodus/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-storage-xodus:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-storage-xodus:0.2.0\")\n}\n</code></pre></p>"},{"location":"controls-kt/magix/magix-zmq/","title":"Module magix-zmq","text":"<p>ZMQ client endpoint for Magix</p>"},{"location":"controls-kt/magix/magix-zmq/#usage","title":"Usage","text":""},{"location":"controls-kt/magix/magix-zmq/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:magix-zmq:0.2.0</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:magix-zmq:0.2.0\")\n}\n</code></pre></p>"},{"location":"tables-kt/","title":"Tables.kt","text":""},{"location":"tables-kt/#tableskt","title":"Tables.kt","text":"<p>Tables.kt is a lightweight Kotlin-Multiplatform library to work with tables of any origin. It is not intended as an alternative to DataFrame library. On the contrary, you can use it together with the provided module. The aim of this library to provide an API for a various tables and row lists.</p> <p>Another aim is to provide integration between different types of tables. For example load database table with Exposed and convert it to a DataFrame.</p> <p>The performance could vary depending on the type of the table. For example row-based access to column-based table could be slow and vise-versa. Though in principle, the implementations could be tweaked to be very fast.</p> <p>The library is intended as multiplatform. It supports JVM, JS-IR and Native targets.</p>"},{"location":"tables-kt/#installation","title":"Installation","text":""},{"location":"tables-kt/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:tables-kt:0.2.1</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:tables-kt:0.2.1\")\n}\n</code></pre></p>"},{"location":"tables-kt/#features","title":"Features","text":""},{"location":"tables-kt/#modules","title":"Modules","text":""},{"location":"tables-kt/#tables-kt-csv","title":"tables-kt-csv","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"tables-kt/#tables-kt-dataframe","title":"tables-kt-dataframe","text":"<p>Maturity: PROTOTYPE</p>"},{"location":"tables-kt/#tables-kt-exposed","title":"tables-kt-exposed","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"tables-kt/#tables-kt-jupyter","title":"tables-kt-jupyter","text":"<p>Maturity: EXPERIMENTAL</p>"},{"location":"tables-kt/tables-kt-csv/","title":"Module tables-kt-csv","text":""},{"location":"tables-kt/tables-kt-csv/#usage","title":"Usage","text":""},{"location":"tables-kt/tables-kt-csv/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:tables-kt-csv:0.2.1</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:tables-kt-csv:0.2.1\")\n}\n</code></pre></p>"},{"location":"tables-kt/tables-kt-dataframe/","title":"Module tables-kt-dataframe","text":""},{"location":"tables-kt/tables-kt-dataframe/#usage","title":"Usage","text":""},{"location":"tables-kt/tables-kt-dataframe/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:tables-kt-dataframe:0.2.1</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:tables-kt-dataframe:0.2.1\")\n}\n</code></pre></p>"},{"location":"tables-kt/tables-kt-exposed/","title":"Module tables-kt-exposed","text":""},{"location":"tables-kt/tables-kt-exposed/#usage","title":"Usage","text":""},{"location":"tables-kt/tables-kt-exposed/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:tables-kt-exposed:0.2.1</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:tables-kt-exposed:0.2.1\")\n}\n</code></pre></p>"},{"location":"tables-kt/tables-kt-jupyter/","title":"Module tables-kt-jupyter","text":""},{"location":"tables-kt/tables-kt-jupyter/#usage","title":"Usage","text":""},{"location":"tables-kt/tables-kt-jupyter/#artifact","title":"Artifact:","text":"<p>The Maven coordinates of this project are <code>space.kscience:tables-kt-jupyter:0.2.1</code>.</p> <p>Gradle Kotlin DSL: <pre><code>repositories {\n    maven(\"https://repo.kotlin.link\")\n    //uncomment to access development builds\n    //maven(\"https://maven.pkg.jetbrains.space/spc/p/sci/dev\")\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"space.kscience:tables-kt-jupyter:0.2.1\")\n}\n</code></pre></p>"},{"location":"snark/","title":"snark","text":"<p>Scientific Notation And Representation in Kotlin</p>"},{"location":"kotlindl/","title":"KotlinDL: High-level Deep Learning API in Kotlin","text":"<p>KotlinDL is a high-level Deep Learning API written in Kotlin and inspired by Keras.  Under the hood, it uses TensorFlow Java API and ONNX Runtime API for Java. KotlinDL offers simple APIs for training deep learning models from scratch,  importing existing Keras and ONNX models for inference, and leveraging transfer learning for tailoring existing pre-trained models to your tasks. </p> <p>This project aims to make Deep Learning easier for JVM and Android developers and simplify deploying deep learning models in production environments.</p> <p>Here's an example of what a classic convolutional neural network LeNet would look like in KotlinDL:</p> <pre><code>private const val EPOCHS = 3\nprivate const val TRAINING_BATCH_SIZE = 1000\nprivate const val NUM_CHANNELS = 1L\nprivate const val IMAGE_SIZE = 28L\nprivate const val SEED = 12L\nprivate const val TEST_BATCH_SIZE = 1000\n\nprivate val lenet5Classic = Sequential.of(\n    Input(\n        IMAGE_SIZE,\n        IMAGE_SIZE,\n        NUM_CHANNELS\n    ),\n    Conv2D(\n        filters = 6,\n        kernelSize = intArrayOf(5, 5),\n        strides = intArrayOf(1, 1, 1, 1),\n        activation = Activations.Tanh,\n        kernelInitializer = GlorotNormal(SEED),\n        biasInitializer = Zeros(),\n        padding = ConvPadding.SAME\n    ),\n    AvgPool2D(\n        poolSize = intArrayOf(1, 2, 2, 1),\n        strides = intArrayOf(1, 2, 2, 1),\n        padding = ConvPadding.VALID\n    ),\n    Conv2D(\n        filters = 16,\n        kernelSize = intArrayOf(5, 5),\n        strides = intArrayOf(1, 1, 1, 1),\n        activation = Activations.Tanh,\n        kernelInitializer = GlorotNormal(SEED),\n        biasInitializer = Zeros(),\n        padding = ConvPadding.SAME\n    ),\n    AvgPool2D(\n        poolSize = intArrayOf(1, 2, 2, 1),\n        strides = intArrayOf(1, 2, 2, 1),\n        padding = ConvPadding.VALID\n    ),\n    Flatten(), // 3136\n    Dense(\n        outputSize = 120,\n        activation = Activations.Tanh,\n        kernelInitializer = GlorotNormal(SEED),\n        biasInitializer = Constant(0.1f)\n    ),\n    Dense(\n        outputSize = 84,\n        activation = Activations.Tanh,\n        kernelInitializer = GlorotNormal(SEED),\n        biasInitializer = Constant(0.1f)\n    ),\n    Dense(\n        outputSize = 10,\n        activation = Activations.Linear,\n        kernelInitializer = GlorotNormal(SEED),\n        biasInitializer = Constant(0.1f)\n    )\n)\n\n\nfun main() {\n    val (train, test) = mnist()\n\n    lenet5Classic.use {\n        it.compile(\n            optimizer = Adam(clipGradient = ClipGradientByValue(0.1f)),\n            loss = Losses.SOFT_MAX_CROSS_ENTROPY_WITH_LOGITS,\n            metric = Metrics.ACCURACY\n        )\n\n        it.logSummary()\n\n        it.fit(dataset = train, epochs = EPOCHS, batchSize = TRAINING_BATCH_SIZE)\n\n        val accuracy = it.evaluate(dataset = test, batchSize = TEST_BATCH_SIZE).metrics[Metrics.ACCURACY]\n\n        println(\"Accuracy: $accuracy\")\n    }\n}\n</code></pre>"},{"location":"kotlindl/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Library Structure</li> <li>How to configure KotlinDL in your project</li> <li>Working with KotlinDL in Android projects</li> <li>Working with KotlinDL in Jupyter Notebook</li> <li>KotlinDL, ONNX Runtime, Android, and JDK versions</li> <li>Documentation</li> <li>Examples and tutorials</li> <li>Running KotlinDL on GPU</li> <li>Logging</li> <li>Fat Jar issue</li> <li>Limitations</li> <li>Contributing</li> <li>Reporting issues/Support</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"kotlindl/#library-structure","title":"Library Structure","text":"<p>KotlinDL consists of several modules: * <code>kotlin-deeplearning-api</code> api interfaces and classes * <code>kotlin-deeplearning-impl</code> implementation classes and utilities * <code>kotlin-deeplearning-onnx</code> inference with ONNX Runtime * <code>kotlin-deeplearning-tensorflow</code> learning and inference with TensorFlow * <code>kotlin-deeplearning-visualization</code> visualization utilities * <code>kotlin-deeplearning-dataset</code> dataset classes</p> <p>Modules <code>kotlin-deeplearning-tensorflow</code> and <code>kotlin-deeplearning-dataset</code> are only available for desktop JVM, while other artifacts could also be used on Android.</p>"},{"location":"kotlindl/#how-to-configure-kotlindl-in-your-project","title":"How to configure KotlinDL in your project","text":"<p>To use KotlinDL in your project, ensure that <code>mavenCentral</code> is added to the repositories list: <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre> Then add the necessary dependencies to your <code>build.gradle</code> file. </p> <p>To start with creating simple neural networks or downloading pre-trained models, just add the following dependency: <pre><code>// build.gradle\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlin-deeplearning-tensorflow:[KOTLIN-DL-VERSION]'\n}\n</code></pre> <pre><code>// build.gradle.kts\ndependencies {\n    implementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-tensorflow:[KOTLIN-DL-VERSION]\")\n}\n</code></pre></p> <p>Use <code>kotlin-deeplearning-onnx</code> module for inference with ONNX Runtime: <pre><code>// build.gradle\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]'\n}\n</code></pre> <pre><code>// build.gradle.kts\ndependencies {\n  implementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]\")\n}\n</code></pre></p> <p>To use the full power of KotlinDL in your project for JVM, add the following dependencies to your <code>build.gradle</code> file: <pre><code>// build.gradle\ndependencies {\n    implementation 'org.jetbrains.kotlinx:kotlin-deeplearning-tensorflow:[KOTLIN-DL-VERSION]'\n    implementation 'org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]'\n    implementation 'org.jetbrains.kotlinx:kotlin-deeplearning-visualization:[KOTLIN-DL-VERSION]'\n}\n</code></pre> <pre><code>// build.gradle.kts\ndependencies {\n  implementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-tensorflow:[KOTLIN-DL-VERSION]\")\n  implementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]\")\n  implementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-visualization:[KOTLIN-DL-VERSION]\")\n}\n</code></pre></p> <p>The latest stable KotlinDL version is <code>0.5.2</code>, latest unstable version is <code>0.6.0-alpha-1</code>.</p> <p>For more details, as well as for <code>pom.xml</code> and <code>build.gradle.kts</code> examples, please refer to the Quick Start Guide.</p>"},{"location":"kotlindl/#working-with-kotlindl-in-jupyter-notebook","title":"Working with KotlinDL in Jupyter Notebook","text":"<p>You can work with KotlinDL interactively in Jupyter Notebook with the Kotlin kernel. To do so, add the required dependencies in your notebook: </p> <p><pre><code>@file:DependsOn(\"org.jetbrains.kotlinx:kotlin-deeplearning-tensorflow:[KOTLIN-DL-VERSION]\")\n</code></pre> For more details on installing Jupyter Notebook and adding the Kotlin kernel, check out the Quick Start Guide.</p>"},{"location":"kotlindl/#working-with-kotlindl-in-android-projects","title":"Working with KotlinDL in Android projects","text":"<p>KotlinDL supports an inference of ONNX models on the Android platform. To use KotlinDL in your Android project, add the following dependency to your build.gradle file: <pre><code>// build.gradle\nimplementation 'org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]'\n</code></pre> <pre><code>// build.gradle.kts\nimplementation (\"org.jetbrains.kotlinx:kotlin-deeplearning-onnx:[KOTLIN-DL-VERSION]\")\n</code></pre> For more details, please refer to the Quick Start Guide.</p>"},{"location":"kotlindl/#kotlindl-onnx-runtime-android-and-jdk-versions","title":"KotlinDL, ONNX Runtime, Android, and JDK versions","text":"<p>This table shows the mapping between KotlinDL, TensorFlow, ONNX Runtime, Compile SDK for Android and minimum supported Java versions.</p> KotlinDL Version Minimum Java Version ONNX Runtime Version TensorFlow Version Android: Compile SDK Version 0.1.* 8 1.15 0.2.0 8 1.15 0.3.0 8 1.8.1 1.15 0.4.0 8 1.11.0 1.15 0.5.0-0.5.1 11 1.12.1 1.15 31 0.5.2 11 1.14.0 1.15 31 0.6.* 11 1.16.0 1.15 31"},{"location":"kotlindl/#documentation","title":"Documentation","text":"<ul> <li>Presentations and videos:</li> <li>Deep Learning with KotlinDL (Zinoviev Alexey at Huawei Developer Group HDG UK 2021, slides)</li> <li>Introduction to Deep Learning with KotlinDL (Zinoviev Alexey at Kotlin Budapest User Group 2021, slides)</li> <li>Change log for KotlinDL</li> <li>Full KotlinDL API reference</li> </ul>"},{"location":"kotlindl/#examples-and-tutorials","title":"Examples and tutorials","text":"<p>You do not need prior experience with Deep Learning to use KotlinDL.</p> <p>We are working on including extensive documentation to help you get started.  At this point, please feel free to check out the following tutorials we have prepared: - Quick Start Guide  - Creating your first neural network - Importing a Keras model  - Transfer learning - Transfer learning with Functional API - Running inference with ONNX models on JVM - Running inference with ONNX models on Android</p> <p>For more inspiration, take a look at the code examples in this repository and Sample Android App.</p>"},{"location":"kotlindl/#running-kotlindl-on-gpu","title":"Running KotlinDL on GPU","text":"<p>To enable the training and inference on a GPU, please read this TensorFlow GPU Support page and install the CUDA framework to allow calculations on a GPU device.</p> <p>Note that only NVIDIA devices are supported.</p> <p>You will also need to add the following dependencies in your project if you wish to leverage a GPU:  <pre><code>// build.gradle\nimplementation 'org.tensorflow:libtensorflow:1.15.0'\nimplementation 'org.tensorflow:libtensorflow_jni_gpu:1.15.0'\n</code></pre> <pre><code>// build.gradle.kts\nimplementation (\"org.tensorflow:libtensorflow:1.15.0\")\nimplementation (\"org.tensorflow:libtensorflow_jni_gpu:1.15.0\")\n</code></pre></p> <p>On Windows, the following distributions are required: - CUDA cuda_10.0.130_411.31_win10 - cudnn-7.6.3 - C++ redistributable parts </p> <p>For inference of ONNX models on a CUDA device, you will also need to add the following dependencies to your project: <pre><code>// build.gradle\napi 'com.microsoft.onnxruntime:onnxruntime_gpu:1.16.0'\n</code></pre> <pre><code>// build.gradle.kts\napi(\"com.microsoft.onnxruntime:onnxruntime_gpu:1.16.0\")\n</code></pre></p> <p>To find more info about ONNXRuntime and CUDA version compatibility, please refer to the ONNXRuntime CUDA Execution Provider page.</p>"},{"location":"kotlindl/#logging","title":"Logging","text":"<p>By default, the API module uses the kotlin-logging library to organize the logging process separately from the specific logger implementation.</p> <p>You could use any widely known JVM logging library with a Simple Logging Facade for Java (SLF4J) implementation such as Logback or Log4j/Log4j2.</p> <p>You will also need to add the following dependencies and configuration file <code>log4j2.xml</code> to the <code>src/resource</code> folder in your project if you wish to use log4j2:</p> <p><pre><code>// build.gradle\nimplementation 'org.apache.logging.log4j:log4j-api:2.17.2'\nimplementation 'org.apache.logging.log4j:log4j-core:2.17.2'\nimplementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.17.2'\n</code></pre> <pre><code>// build.gradle.kts\nimplementation(\"org.apache.logging.log4j:log4j-api:2.17.2\")\nimplementation(\"org.apache.logging.log4j:log4j-core:2.17.2\")\nimplementation(\"org.apache.logging.log4j:log4j-slf4j-impl:2.17.2\")\n</code></pre></p> <pre><code>&lt;Configuration status=\"WARN\"&gt;\n    &lt;Appenders&gt;\n        &lt;Console name=\"STDOUT\" target=\"SYSTEM_OUT\"&gt;\n            &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\"/&gt;\n        &lt;/Console&gt;\n    &lt;/Appenders&gt;\n\n    &lt;Loggers&gt;\n        &lt;Root level=\"debug\"&gt;\n            &lt;AppenderRef ref=\"STDOUT\" level=\"DEBUG\"/&gt;\n        &lt;/Root&gt;\n        &lt;Logger name=\"io.jhdf\" level=\"off\" additivity=\"true\"&gt;\n            &lt;appender-ref ref=\"STDOUT\" /&gt;\n        &lt;/Logger&gt;\n    &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre> <p>If you wish to use Logback, include the following dependency and configuration file <code>logback.xml</code> to <code>src/resource</code> folder in your project</p> <p><pre><code>// build.gradle\nimplementation 'ch.qos.logback:logback-classic:1.4.5'\n</code></pre> <pre><code>// build.gradle.kts\nimplementation(\"ch.qos.logback:logback-classic:1.4.5\")\n</code></pre></p> <p><pre><code>&lt;configuration&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\"/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> These configuration files can be found in the <code>examples</code> module.</p>"},{"location":"kotlindl/#fat-jar-issue","title":"Fat Jar issue","text":"<p>There is a known Stack Overflow question  and TensorFlow issue with Fat Jar creation and execution on Amazon EC2 instances.</p> <pre><code>java.lang.UnsatisfiedLinkError: /tmp/tensorflow_native_libraries-1562914806051-0/libtensorflow_jni.so: libtensorflow_framework.so.1: cannot open shared object file: No such file or directory\n</code></pre> <p>Despite the fact that the bug describing this problem was closed in the release of TensorFlow 1.14,  it was not fully fixed and required an additional line in the build script.</p> <p>One simple solution is to add a TensorFlow version specification to the Jar's Manifest.  Below is an example of a Gradle build task for Fat Jar creation.</p> <pre><code>// build.gradle\n\ntask fatJar(type: Jar) {\n    manifest {\n        attributes 'Implementation-Version': '1.15'\n    }\n    classifier = 'all'\n    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }\n    with jar\n}\n</code></pre> <pre><code>// build.gradle.kts\n\nplugins {\n    kotlin(\"jvm\") version \"1.5.31\"\n    id(\"com.github.johnrengelman.shadow\") version \"7.0.0\"\n}\n\ntasks{\n    shadowJar {\n        manifest {\n            attributes(Pair(\"Main-Class\", \"MainKt\"))\n            attributes(Pair(\"Implementation-Version\", \"1.15\"))\n        }\n    }\n}\n</code></pre>"},{"location":"kotlindl/#limitations","title":"Limitations","text":"<p>Currently, only a limited set of deep learning architectures are supported. Here's the list of available layers:</p> <ul> <li>Core layers:</li> <li><code>Input</code>, <code>Dense</code>, <code>Flatten</code>, <code>Reshape</code>, <code>Dropout</code>, <code>BatchNorm</code>.</li> <li>Convolutional layers:</li> <li><code>Conv1D</code>, <code>Conv2D</code>, <code>Conv3D</code>;</li> <li><code>Conv1DTranspose</code>, <code>Conv2DTranspose</code>, <code>Conv3DTranspose</code>;</li> <li><code>DepthwiseConv2D</code>;</li> <li><code>SeparableConv2D</code>.</li> <li>Pooling layers:</li> <li><code>MaxPool1D</code>, <code>MaxPool2D</code>, <code>MaxPooling3D</code>;</li> <li><code>AvgPool1D</code>, <code>AvgPool2D</code>, <code>AvgPool3D</code>;</li> <li><code>GlobalMaxPool1D</code>, <code>GlobalMaxPool2D</code>, <code>GlobalMaxPool3D</code>;</li> <li><code>GlobalAvgPool1D</code>, <code>GlobalAvgPool2D</code>, <code>GlobalAvgPool3D</code>.</li> <li>Merge layers:</li> <li><code>Add</code>, <code>Subtract</code>, <code>Multiply</code>;</li> <li><code>Average</code>, <code>Maximum</code>, <code>Minimum</code>;</li> <li><code>Dot</code>;</li> <li><code>Concatenate</code>.</li> <li>Activation layers:</li> <li><code>ELU</code>, <code>LeakyReLU</code>, <code>PReLU</code>, <code>ReLU</code>, <code>Softmax</code>, <code>ThresholdedReLU</code>;</li> <li><code>ActivationLayer</code>.</li> <li>Cropping layers:</li> <li><code>Cropping1D</code>, <code>Cropping2D</code>, <code>Cropping3D</code>.</li> <li>Upsampling layers:</li> <li><code>UpSampling1D</code>, <code>UpSampling2D</code>, <code>UpSampling3D</code>.</li> <li>Zero padding layers:</li> <li><code>ZeroPadding1D</code>, <code>ZeroPadding2D</code>, <code>ZeroPadding3D</code>.</li> <li>Other layers:</li> <li><code>Permute</code>, <code>RepeatVector</code>.</li> </ul> <p>TensorFlow 1.15 Java API is currently used for layer implementation, but this project will be switching to TensorFlow 2.+ in the nearest future.  This, however, does not affect the high-level API. Inference with TensorFlow models is currently supported only on desktops. </p>"},{"location":"kotlindl/#contributing","title":"Contributing","text":"<p>Read the Contributing Guidelines.</p>"},{"location":"kotlindl/#reporting-issuessupport","title":"Reporting issues/Support","text":"<p>Please use GitHub issues for filing feature requests and bug reports.  You are also welcome to join the #kotlindl channel in Kotlin Slack.</p>"},{"location":"kotlindl/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and the corresponding community are governed by the JetBrains Open Source and Community Code of Conduct. Please make sure you read it. </p>"},{"location":"kotlindl/#license","title":"License","text":"<p>KotlinDL is licensed under the Apache 2.0 License.</p>"},{"location":"kotlin-spark/","title":"Kotlin for Apache\u00ae Spark\u2122","text":"<p>Your next API to work with  Apache Spark. </p> <p>This project adds a missing layer of compatibility between Kotlin and Apache Spark. It allows Kotlin developers to use familiar language features such as data classes, and lambda expressions as simple expressions in curly braces or method references. </p> <p>We have opened a Spark Project Improvement Proposal: Kotlin support for Apache Spark to work with the community towards getting Kotlin support as a first-class citizen in Apache Spark. We encourage you to voice your opinions and participate in the discussion.</p>"},{"location":"kotlin-spark/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Supported versions of Apache Spark</li> <li>Releases</li> <li>How to configure Kotlin for Apache Spark in your project</li> <li>Kotlin for Apache Spark features<ul> <li>Creating a SparkSession in Kotlin</li> <li>Creating a Dataset in Kotlin</li> <li>Null safety</li> <li>withSpark function</li> <li>withCached function</li> <li>toList and toArray</li> <li>Column infix/operator functions</li> <li>Overload Resolution Ambiguity</li> <li>Tuples</li> <li>Streaming</li> <li>User Defined Functions</li> </ul> </li> <li>Examples</li> <li>Reporting issues/Support</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"kotlin-spark/#supported-versions-of-apache-spark","title":"Supported versions of Apache Spark","text":"Apache Spark Scala Kotlin for Apache Spark 3.3.2 2.13 kotlin-spark-api_3.3.2_2.13:VERSION 2.12 kotlin-spark-api_3.3.2_2.12:VERSION 3.3.1 2.13 kotlin-spark-api_3.3.1_2.13:VERSION 2.12 kotlin-spark-api_3.3.1_2.12:VERSION 3.3.0 2.13 kotlin-spark-api_3.3.0_2.13:VERSION 2.12 kotlin-spark-api_3.3.0_2.12:VERSION 3.2.3 2.13 kotlin-spark-api_3.2.3_2.13:VERSION 2.12 kotlin-spark-api_3.2.3_2.12:VERSION 3.2.2 2.13 kotlin-spark-api_3.2.2_2.13:VERSION 2.12 kotlin-spark-api_3.2.2_2.12:VERSION 3.2.1 2.13 kotlin-spark-api_3.2.1_2.13:VERSION 2.12 kotlin-spark-api_3.2.1_2.12:VERSION 3.2.0 2.13 kotlin-spark-api_3.2.0_2.13:VERSION 2.12 kotlin-spark-api_3.2.0_2.12:VERSION 3.1.3 2.12 kotlin-spark-api_3.1.3_2.12:VERSION 3.1.2 2.12 kotlin-spark-api_3.1.2_2.12:VERSION 3.1.1 2.12 kotlin-spark-api_3.1.1_2.12:VERSION 3.1.0 2.12 kotlin-spark-api_3.1.0_2.12:VERSION 3.0.3 2.12 kotlin-spark-api_3.0.3_2.12:VERSION 3.0.2 2.12 kotlin-spark-api_3.0.2_2.12:VERSION 3.0.1 2.12 kotlin-spark-api_3.0.1_2.12:VERSION 3.0.0 2.12 kotlin-spark-api_3.0.0_2.12:VERSION"},{"location":"kotlin-spark/#deprecated-versions","title":"Deprecated versions","text":"Apache Spark Scala Kotlin for Apache Spark 2.4.1+ 2.12 kotlin-spark-api-2.4_2.12:1.0.2 2.4.1+ 2.11 kotlin-spark-api-2.4_2.11:1.0.2 ## Releases <p>The list of Kotlin for Apache Spark releases is available here. The Kotlin for Spark artifacts adhere to the following convention: <code>[name]_[Apache Spark version]_[Scala core version]:[Kotlin for Apache Spark API version]</code> </p> <p>The only exception to this is <code>scala-tuples-in-kotlin_[Scala core version]:[Kotlin for Apache Spark API version]</code>, which is  independent of Spark.</p> <p></p>"},{"location":"kotlin-spark/#how-to-configure-kotlin-for-apache-spark-in-your-project","title":"How to configure Kotlin for Apache Spark in your project","text":"<p>You can add Kotlin for Apache Spark as a dependency to your project: <code>Maven</code>, <code>Gradle</code>, <code>SBT</code>, and <code>leinengen</code> are supported.</p> <p>Here's an example <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.jetbrains.kotlinx.spark&lt;/groupId&gt;\n  &lt;artifactId&gt;kotlin-spark-api_3.3.2_2.13&lt;/artifactId&gt;\n  &lt;version&gt;${kotlin-spark-api.version}&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;\n    &lt;artifactId&gt;spark-sql_2.13&lt;/artifactId&gt;\n    &lt;version&gt;${spark.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Note that you must match the version of the Kotlin for Apache Spark API to the Spark- and Scala version of your project. You can find a complete example with <code>pom.xml</code> and <code>build.gradle</code> in the Quick Start Guide.</p> <p>If you want to try a development version. You can use the versions published to GH Packages. They typically have the same version as the release version, but with a <code>-SNAPSHOT</code> suffix. See the GitHub Docs for more information.</p> <p>Once you have configured the dependency, you only need to add the following import to your Kotlin file:  <pre><code>import org.jetbrains.kotlinx.spark.api.*\n</code></pre></p>"},{"location":"kotlin-spark/#jupyter","title":"Jupyter","text":"<p>The Kotlin Spark API also supports Kotlin Jupyter notebooks. To it, simply add</p> <p><pre><code>%use spark\n</code></pre> to the top of your notebook. This will get the latest version of the API, together with the latest version of Spark. To define a certain version of Spark or the API itself, simply add it like this: <pre><code>%use spark(spark=3.3.2, scala=2.13, v=1.2.4)\n</code></pre></p> <p>Inside the notebook a Spark session will be initiated automatically. This can be accessed via the <code>spark</code> value. <code>sc: JavaSparkContext</code> can also be accessed directly. The API operates pretty similarly.</p> <p>There is also support for HTML rendering of Datasets and simple (Java)RDDs. Check out the example as well.</p> <p>To use Spark Streaming abilities, instead use <pre><code>%use spark-streaming\n</code></pre> This does not start a Spark session right away, meaning you can call <code>withSparkStreaming(batchDuration) {}</code>  in whichever cell you want. Check out the example.</p> <p>NOTE: You need <code>kotlin-jupyter-kernel</code> to be at least version 0.11.0.83 for the Kotlin Spark API to work. Also, if the  <code>%use spark</code> magic does not output \"Spark session has been started...\", and <code>%use spark-streaming</code> doesn't work at all,  add <code>%useLatestDescriptors</code> above it.</p> <p>For more information, check the wiki.</p>"},{"location":"kotlin-spark/#kotlin-for-apache-spark-features","title":"Kotlin for Apache Spark features","text":""},{"location":"kotlin-spark/#creating-a-sparksession-in-kotlin","title":"Creating a SparkSession in Kotlin","text":"<pre><code>val spark = SparkSession\n        .builder()\n        .master(\"local[2]\")\n        .appName(\"Simple Application\").orCreate\n</code></pre> <p>This is not needed when running the Kotlin Spark API from a Jupyter notebook.</p>"},{"location":"kotlin-spark/#creating-a-dataset-in-kotlin","title":"Creating a Dataset in Kotlin","text":"<p><pre><code>spark.dsOf(\"a\" to 1, \"b\" to 2)\n</code></pre> The example above produces <code>Dataset&lt;Pair&lt;String, Int&gt;&gt;</code>. While Kotlin Pairs and Triples are supported, Scala Tuples are  recommended for better support.</p>"},{"location":"kotlin-spark/#null-safety","title":"Null safety","text":"<p>There are several aliases in API, like <code>leftJoin</code>, <code>rightJoin</code> etc. These are null-safe by design.  For example, <code>leftJoin</code> is aware of nullability and returns <code>Dataset&lt;Pair&lt;LEFT, RIGHT?&gt;&gt;</code>. Note that we are forcing <code>RIGHT</code> to be nullable for you as a developer to be able to handle this situation.  <code>NullPointerException</code>s are hard to debug in Spark, and we're doing our best to make them as rare as possible.</p> <p>In Spark, you might also come across Scala-native <code>Option&lt;*&gt;</code> or Java-compatible <code>Optional&lt;*&gt;</code> classes. We provide <code>getOrNull()</code> and <code>getOrElse()</code> functions for these to use Kotlin's null safety for good.</p> <p>Similarly, you can also create <code>Option&lt;*&gt;</code>s and <code>Optional&lt;*&gt;</code>s like <code>T?.toOptional()</code> if a Spark function requires it.</p>"},{"location":"kotlin-spark/#withspark-function","title":"withSpark function","text":"<p>We provide you with useful function <code>withSpark</code>, which accepts everything that may be needed to run Spark \u2014 properties, name, master location and so on. It also accepts a block of code to execute inside Spark context.</p> <p>After work block ends, <code>spark.stop()</code> is called automatically.</p> <p>Do not use this when running the Kotlin Spark API from a Jupyter notebook.</p> <pre><code>withSpark {\n    dsOf(1, 2)\n        .map { it X it } // creates Tuple2&lt;Int, Int&gt;\n        .show()\n}\n</code></pre> <p><code>dsOf</code> is just one more way to create <code>Dataset</code> (<code>Dataset&lt;Int&gt;</code>) from varargs.</p>"},{"location":"kotlin-spark/#withcached-function","title":"withCached function","text":"<p>It can easily happen that we need to fork our computation to several paths. To compute things only once we should call <code>cache</code> method. However, it becomes difficult to control when we're using cached <code>Dataset</code> and when not. It is also easy to forget to unpersist cached data, which can break things unexpectedly or take up more memory than intended.</p> <p>To solve these problems we've added <code>withCached</code> function</p> <pre><code>withSpark {\n    dsOf(1, 2, 3, 4, 5)\n        .map { tupleOf(it, it + 2) }\n        .withCached {\n            showDS()\n\n            filter { it._1 % 2 == 0 }.showDS()\n        }\n        .map { tupleOf(it._1, it._2, (it._1 + it._2) * 2) }\n        .show()\n}\n</code></pre> <p>Here we're showing cached <code>Dataset</code> for debugging purposes then filtering it.  The <code>filter</code> method returns filtered <code>Dataset</code> and then the cached <code>Dataset</code> is being unpersisted, so we have more memory t o call the <code>map</code> method and collect the resulting <code>Dataset</code>.</p>"},{"location":"kotlin-spark/#tolist-and-toarray-methods","title":"toList and toArray methods","text":"<p>For more idiomatic Kotlin code we've added <code>toList</code> and <code>toArray</code> methods in this API. You can still use the <code>collect</code> method as in Scala API, however the result should be casted to <code>Array</code>.   This is because <code>collect</code> returns a Scala array, which is not the same as Java/Kotlin one.</p>"},{"location":"kotlin-spark/#column-infixoperator-functions","title":"Column infix/operator functions","text":"<p>Similar to the Scala API for <code>Columns</code>, many of the operator functions could be ported over. For example: <pre><code>dataset.select( col(\"colA\") + 5 )\ndataset.select( col(\"colA\") / col(\"colB\") )\n\ndataset.where( col(\"colA\") `===` 6 )\n// or alternatively\ndataset.where( col(\"colA\") eq 6)\n</code></pre></p> <p>To read more, check the wiki.</p>"},{"location":"kotlin-spark/#overload-resolution-ambiguity","title":"Overload resolution ambiguity","text":"<p>We had to implement the functions <code>reduceGroups</code> and <code>reduce</code> for Kotlin separately as <code>reduceGroupsK</code> and <code>reduceK</code> respectively, because otherwise it caused resolution ambiguity between Kotlin, Scala and Java APIs, which was quite hard to solve.</p> <p>We have a special example of work with this function in the Groups example.</p>"},{"location":"kotlin-spark/#tuples","title":"Tuples","text":"<p>Inspired by ScalaTuplesInKotlin, the API introduces a lot of helper- extension functions to make working with Scala Tuples a breeze in your Kotlin Spark projects. While working with data classes is encouraged, for pair-like Datasets / RDDs / DStreams Scala Tuples are recommended, both for the useful helper functions, as well as Spark performance. To enable these features simply add <pre><code>import org.jetbrains.kotlinx.spark.api.tuples.*\n</code></pre> to the start of your file.</p> <p>Tuple creation can be done in the following manners: <pre><code>val a: Tuple2&lt;Int, Long&gt; = tupleOf(1, 2L)\nval b: Tuple3&lt;String, Double, Int&gt; = t(\"test\", 1.0, 2)\nval c: Tuple3&lt;Float, String, Int&gt; = 5f X \"aaa\" X 1\n</code></pre> To read more about tuples and all the added functions, refer to the wiki.</p>"},{"location":"kotlin-spark/#streaming","title":"Streaming","text":"<p>A popular Spark extension is Spark Streaming.  Of course the Kotlin Spark API also introduces a more Kotlin-esque approach to write your streaming programs. There are examples for use with a checkpoint, Kafka and SQL in the examples module.</p> <p>We shall also provide a quick example below: <pre><code>// Automatically provides ssc: JavaStreamingContext which starts and awaits termination or timeout\nwithSparkStreaming(batchDuration = Durations.seconds(1), timeout = 10_000) { // this: KSparkStreamingSession\n\n    // create input stream for, for instance, Netcat: `$ nc -lk 9999`\n    val lines: JavaReceiverInputDStream&lt;String&gt; = ssc.socketTextStream(\"localhost\", 9999)\n\n    // split input stream on space\n    val words: JavaDStream&lt;String&gt; = lines.flatMap { it.split(\" \").iterator() }\n\n    // perform action on each formed RDD in the stream\n    words.foreachRDD { rdd: JavaRDD&lt;String&gt;, _: Time -&gt;\n\n          // to convert the JavaRDD to a Dataset, we need a spark session using the RDD context\n          withSpark(rdd) { // this: KSparkSession\n            val dataframe: Dataset&lt;TestRow&gt; = rdd.map { TestRow(word = it) }.toDS()\n            dataframe\n                .groupByKey { it.word }\n                .count()\n                .show()\n            // +-----+--------+\n            // |  key|count(1)|\n            // +-----+--------+\n            // |hello|       1|\n            // |   is|       1|\n            // |    a|       1|\n            // | this|       1|\n            // | test|       3|\n            // +-----+--------+\n        }\n    }\n}\n</code></pre></p> <p>For more information, check the wiki.</p>"},{"location":"kotlin-spark/#user-defined-functions","title":"User Defined Functions","text":"<p>Spark has a way to call functions from SQL using so-called UDFs. Using the Scala/Java API from Kotlin is not that obvious, so we decided to add special UDF support for Kotlin. This support grew into a typesafe, name-safe, and feature-rich solution for which we will give an example: <pre><code>// example of creation/naming, and registering of a simple UDF\nval plusOne by udf { x: Int -&gt; x + 1 }\nplusOne.register()\nspark.sql(\"SELECT plusOne(5)\").show()\n// +----------+\n// |plusOne(5)|\n// +----------+\n// |         6|\n// +----------+\n\n// directly registering\nudf.register(\"plusTwo\") { x: Double -&gt; x + 2.0 }\nspark.sql(\"SELECT plusTwo(2.0d)\").show()\n// +------------+\n// |plusTwo(2.0)|\n// +------------+\n// |         4.0|\n// +------------+\n\n// dataset select\nval result: Dataset&lt;Int&gt; = myDs.select(\n  plusOne(col(MyType::age))\n)\n</code></pre></p> <p>We support:   - a notation close to Spark's   - smart naming (with reflection)   - creation from function references   - typed column operations   - UDAF support and functional creation   - (Unique!) simple vararg UDF support</p> <p>For more, check the extensive examples. Also, check out the wiki.</p>"},{"location":"kotlin-spark/#examples","title":"Examples","text":"<p>For more, check out examples module. To get up and running quickly, check out this tutorial. </p>"},{"location":"kotlin-spark/#reporting-issues-support","title":"Reporting issues / support","text":"<p>Please use GitHub issues for filing feature requests and bug reports. You are also welcome to join kotlin-spark channel in the Kotlin Slack.</p>"},{"location":"kotlin-spark/#contribution-guide","title":"Contribution guide","text":"<p>Contributions are more than welcome! Pull requests can be created for the main branch and will be considered as soon as possible. Be sure to add the necessary tests for any new feature you add. The main branch always aims to target the latest available Apache Spark version. Note that we use Java Comment Preprocessor to build the library for all different supported versions of Apache Spark and Scala.  The current values of these versions can be edited in <code>gradle.properties</code> and should always be the latest versions for commits. For testing, all versions need a pass for the request to be accepted. We use GitHub Actions to test and deploy the library for all versions, but locally you can also use the <code>gradlew_all_versions</code> file.</p> <p>Of the main branch, development versions of the library are published to  GitHub Packages. This way, new features can be tested quickly without having to wait for a full release. </p> <p>For full releases, the release branch is updated.</p>"},{"location":"kotlin-spark/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and the corresponding community is governed by the JetBrains Open Source and Community Code of Conduct. Please make sure you read it. </p>"},{"location":"kotlin-spark/#license","title":"License","text":"<p>Kotlin for Apache Spark is licensed under the Apache 2.0 License.</p>"},{"location":"kotlin-jupyter/docs/","title":"Kotlin Kernel for IPython/Jupyter","text":""},{"location":"kotlin-jupyter/docs/#kotlin-kernel-for-ipythonjupyter","title":"Kotlin Kernel for IPython/Jupyter","text":"<p>Kotlin (1.9.0) kernel for Jupyter.</p> <p>The kernel is a powerful engine designed to enhance your Kotlin REPL experience. It offers support for executing code cells, providing basic code completion, and analyzing errors. With the Kotlin kernel, you gain access to a range of features, including an API for handling outputs, retrieving information from previously executed code snippets, executing generic Kotlin code effortlessly, seamless integration with libraries, and more.</p> <p></p> <p>Beta version. Tested with Jupyter Notebook, Jupyter Lab, and Jupyter Console on Windows, Ubuntu Linux, and macOS. The minimal supported versions of clients are given in the table below:</p> Client Version Jupyter Lab 1.2.6 Jupyter Notebook 6.0.3 Jupyter Console 6.1.0 <p>To start using the Kotlin kernel for Jupyter, take a look at the introductory guide.</p> <p>Example notebooks can be found in the samples folder.</p> <p>Try samples online: </p>"},{"location":"kotlin-jupyter/docs/#contents","title":"Contents","text":"<ul> <li>Installation<ul> <li>Kotlin Notebook plugin</li> <li>Conda</li> <li>Pip</li> <li>From sources</li> <li>Troubleshooting</li> </ul> </li> <li>Updating<ul> <li>Kotlin Notebook</li> <li>Datalore</li> <li>Conda</li> <li>Pip</li> </ul> </li> <li>Usage<ul> <li>Kotlin Notebook</li> <li>Other clients</li> <li>Creating Kernels</li> </ul> </li> <li>Supported functionality<ul> <li>REPL commands</li> <li>Dependencies resolving</li> <li>Default repositories</li> <li>Line Magics</li> <li>Supported Libraries<ul> <li>List of supported libraries:</li> </ul> </li> <li>Rich output</li> <li>Rendering<ul> <li>Renderers</li> <li>DisplayResult and Renderable</li> <li>Text rendering</li> <li>Throwables rendering</li> <li>Common rendering semantics</li> </ul> </li> <li>Autocompletion</li> <li>Error analysis</li> </ul> </li> <li>Debugging</li> <li>Adding new libraries</li> <li>Documentation</li> <li>Contributing</li> </ul>"},{"location":"kotlin-jupyter/docs/#installation","title":"Installation","text":"<p>There are several ways to use the kernel:</p>"},{"location":"kotlin-jupyter/docs/#kotlin-notebook-plugin","title":"Kotlin Notebook plugin","text":"<p>Simply download and use the latest version of the Kotlin Notebook plugin from the Marketplace. The Kotlin kernel is embedded in it.</p> <p>Check out the blog post for a quick introduction to Kotlin Notebook.</p>"},{"location":"kotlin-jupyter/docs/#conda","title":"Conda","text":"<p>If you have <code>conda</code> installed, run the following command to install the stable package version:</p> <p><code>conda install -c jetbrains kotlin-jupyter-kernel</code> (package home)</p> <p>To install the conda package from the dev channel:</p> <p><code>conda install -c jetbrains-dev kotlin-jupyter-kernel</code> (package home)</p> <p>Uninstall: <code>conda remove kotlin-jupyter-kernel</code></p>"},{"location":"kotlin-jupyter/docs/#pip","title":"Pip","text":"<p>You can also install this package using <code>pip</code>:</p> <p>Stable: <code>pip install kotlin-jupyter-kernel</code> (package home)</p> <p>Dev: <code>pip install -i https://test.pypi.org/simple/ kotlin-jupyter-kernel</code> (package home)</p> <p>Uninstall: <code>pip uninstall kotlin-jupyter-kernel</code></p>"},{"location":"kotlin-jupyter/docs/#from-sources","title":"From sources","text":"<p>To install the kernel from sources, clone the repository and run the following command in the root folder:</p> <p><code>./gradlew install</code></p> <p>Default installation path is <code>~/.ipython/kernels/kotlin/</code>. To install to some other location use option <code>-PinstallPath=</code>, but note that Jupyter looks for the kernel specs files only in predefined places. For more detailed info see Jupyter docs.</p> <p>Uninstall: <code>./gradlew uninstall</code></p>"},{"location":"kotlin-jupyter/docs/#troubleshooting","title":"Troubleshooting","text":"<p>There could be a problem with kernel spec detection because of different python environments and installation modes. If you are using pip or conda to install the package, try running post-install fixup script: <pre><code>python -m kotlin_kernel fix-kernelspec-location\n</code></pre></p> <p>This script replaces kernel specs to the \"user\" path where they are always detected. Don't forget to re-run this script on the kernel update.</p>"},{"location":"kotlin-jupyter/docs/#updating","title":"Updating","text":"<p>To update the Kotlin kernel, follow the instructions below based on your installation method:</p>"},{"location":"kotlin-jupyter/docs/#kotlin-notebook","title":"Kotlin Notebook","text":"<p>If you are using the Kotlin Notebook plugin, update it to the latest version within the IDE or manually download and install the latest plugin version from the Marketplace.</p>"},{"location":"kotlin-jupyter/docs/#datalore","title":"Datalore","text":"<p>To update the kernel in Datalore, simply add an <code>environment.yml</code> to the Notebook files containing: <pre><code>datalore-env-format-version: \"0.2\"\ndatalore-package-manager: \"pip\"\ndatalore-base-env: \"default\"\ndependencies:\n- pip:\n  - kotlin-jupyter-kernel=={VERSION}\n</code></pre> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>. Stop and restart the machine afterwards.</p>"},{"location":"kotlin-jupyter/docs/#conda_1","title":"Conda","text":"<p>If you have <code>conda</code> installed, just run the following command to update the stable package version:</p> <p><code>conda update -c jetbrains kotlin-jupyter-kernel</code></p> <p>To update the conda package from the dev channel:</p> <p><code>conda update -c jetbrains-dev kotlin-jupyter-kernel</code></p> <p>If you want to change to a specific version of the kernel, take the <code>install</code> command from above and add <code>={VERSION}</code> to <code>kotlin-jupyter-kernel</code> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>.</p> <p>For example, for the stable version:</p> <p><code>conda install -c jetbrains kotlin-jupyter-kernel={VERSION}</code></p>"},{"location":"kotlin-jupyter/docs/#pip_1","title":"Pip","text":"<p>To update the kernel using Pip, simply run:</p> <p>Stable: <code>pip install kotlin-jupyter-kernel --upgrade</code></p> <p>Dev: <code>pip install -i https://test.pypi.org/simple/ kotlin-jupyter-kernel --upgrade</code></p> <p>If you want to change to a specific version of the kernel, take the <code>install</code> command from above and add <code>=={VERSION}</code> to <code>kotlin-jupyter-kernel</code> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>.</p> <p>For example, for the stable version:</p> <p><code>pip install kotlin-jupyter-kernel=={VERSION} --ignore-installed</code></p>"},{"location":"kotlin-jupyter/docs/#usage","title":"Usage","text":""},{"location":"kotlin-jupyter/docs/#kotlin-notebook_1","title":"Kotlin Notebook","text":"<p>Within IDEA with installed Kotlin Notebook plugin, just open a notebook, and you're good to go.</p>"},{"location":"kotlin-jupyter/docs/#other-clients","title":"Other clients","text":"<p>Run one of the following commands in console:</p> <ul> <li><code>jupyter console --kernel=kotlin</code></li> <li><code>jupyter notebook</code></li> <li><code>jupyter lab</code></li> </ul> <p>To start using <code>kotlin</code> kernel inside Jupyter Notebook or JupyterLab create a new notebook with <code>kotlin</code> kernel.</p> <p>The default kernel will use the JDK pointed to by the environment variable <code>KOTLIN_JUPYTER_JAVA_HOME</code>, or <code>JAVA_HOME</code> if the first is not set.</p> <p>JVM arguments will be set from the environment variable <code>KOTLIN_JUPYTER_JAVA_OPTS</code> or <code>JAVA_OPTS</code> if the first is not set. Additionally, arguments from <code>KOTLIN_JUPYTER_JAVA_OPTS_EXTRA</code> will be added. Arguments are parsed using <code>shlex.split</code>.</p>"},{"location":"kotlin-jupyter/docs/#creating-kernels","title":"Creating Kernels","text":"<p>To create a kernel for a specific JDK, JVM arguments, and environment variables, you can use the <code>add-kernel</code> script: <pre><code>python -m kotlin_kernel add-kernel [--name name] [--jdk jdk_home_dir] [--set-jvm-args] [--jvm-arg arg]* [--env KEY VALUE]* [--force]\n</code></pre> The command uses <code>argparse</code>, so <code>--help</code>, <code>@argfile</code> (you will need to escape the <code>@</code> in powershell), and <code>--opt=value</code> are all supported.  <code>--jvm-arg=arg</code> in particular is needed when passing JVM arguments that start with <code>-</code>.</p> <p>If <code>jdk</code> not specified, <code>name</code> is required.  If <code>name</code> is not specified but <code>jdk</code> is the name will be <code>JDK $vendor $version</code> detected from the JDK.  Regardless, the actual name of the kernel will be <code>Kotlin ($name)</code>, and the directory will be <code>kotlin_$name</code> with the spaces in <code>name</code> replaced by underscores (so make sure it's compatible with your file system).</p> <p>JVM arguments are joined with a <code>' '</code>, so multiple JVM arguments in the same argument are supported. The arguments will be added to existing ones (see above section) unless <code>--set-jvm-args</code> is present, in which case they will be set to <code>KOTLIN_JUPYTER_JAVA_OPTS</code>.  Note that both adding and setting work fine alongside <code>KOTLIN_JUPYTER_JAVA_OPTS_EXTRA</code>.</p> <p>While jupyter kernel environment variable substitutions are supported in <code>env</code>, note that if the used environment variable doesn't exist, nothing will be replaced.</p> <p>An example: <pre><code>python -m kotlin_kernel add-kernel --name \"JDK 15 Big 2 GPU\" --jdk ~/.jdks/openjdk-15.0.2 --jvm-arg=-Xmx8G --env CUDA_VISIBLE_DEVICES 0,1\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/#supported-functionality","title":"Supported functionality","text":""},{"location":"kotlin-jupyter/docs/#repl-commands","title":"REPL commands","text":"<p>The following REPL commands are supported:  - <code>:help</code> - display help  - <code>:classpath</code> - show current classpath  - <code>:vars</code> - get visible variables values</p>"},{"location":"kotlin-jupyter/docs/#dependencies-resolving","title":"Dependencies resolving","text":"<p>It is possible to add dynamic dependencies to the notebook using the following annotations: - <code>@file:DependsOn(&lt;coordinates&gt;)</code> - adds artifacts to classpath. Supports absolute and relative paths to class   directories or jars, ivy and maven artifacts represented by the colon separated string - <code>@file:Repository(&lt;absolute-path&gt;)</code> - adds a directory for relative path resolution or ivy/maven repository.   To specify Maven local, use <code>@file:Repository(\"*mavenLocal\")</code>.</p> <p>Alternative way to do the same is using Gradle-like syntax:</p> <pre><code>USE {\n    repositories {\n        maven {\n            url = \"https://my.secret.repo/maven/\"\n            credentials {\n                username = USER\n                password = TOKEN\n            }\n        }\n    }\n\n    dependencies {\n        val ktorVersion = \"2.0.3\"\n\n        implementation(\"my.secret:artifact:1.0-beta\")\n        implementation(\"io.ktor:ktor-client-core:$ktorVersion\")\n        implementation(\"io.ktor:ktor-client-apache:$ktorVersion\")\n    }\n}\n</code></pre> <p>The same syntax can be used in integrations creating.</p> <p>Note that dependencies in remote repositories are resolved via Maven resolver. Caches are stored in <code>~/.m2/repository</code> folder by default. Sometimes, due to network issues or running several artifacts resolutions in parallel, caches may get corrupted. If you have some troubles with artifacts resolution, please remove caches, restart kernel and try again.</p>"},{"location":"kotlin-jupyter/docs/#default-repositories","title":"Default repositories","text":"<p>The following maven repositories are included by default: - Maven Central - JitPack</p>"},{"location":"kotlin-jupyter/docs/#line-magics","title":"Line Magics","text":"<p>The following line magics are supported:  - <code>%use</code> - injects code for supported libraries: artifact resolution, default imports, initialization code, type renderers. Usage example: <code>%use klaxon(5.5), lets-plot</code>  - <code>%trackClasspath</code> - logs any changes of current classpath. Useful for debugging artifact resolution failures. Usage example: <code>%trackClasspath [on|off]</code>  - <code>%trackExecution</code> - logs pieces of code that are going to be executed. Useful for debugging of libraries support. Usage example: <code>%trackExecution [all|generated|off]</code>  - <code>%useLatestDescriptors</code> - use latest versions of library descriptors available. By default, bundled descriptors are used. Note that default behavior is preferred: latest descriptors versions might be not supported by current version of kernel. So if you care about stability of the notebook, avoid using this line magic. Usage example: <code>%useLatestDescriptors [on|off]</code>  - <code>%output</code> - output capturing settings. Usage example: <code>%output --max-cell-size=1000 --no-stdout --max-time=100 --max-buffer=400</code>  - <code>%logLevel</code> - set logging level. Usage example: <code>%logLevel [off|error|warn|info|debug]</code></p> <p>See detailed info about line magics here.</p>"},{"location":"kotlin-jupyter/docs/#supported-libraries","title":"Supported Libraries","text":"<p>When a library is included with <code>%use</code> keyword, the following functionality is added to the notebook: - repositories to search for library artifacts - artifact dependencies - default imports - library initialization code - renderers for special types, e.g. charts and data frames</p> <p>This behavior is defined by <code>json</code> library descriptor. Descriptors for all supported libraries can be found in libraries repository. A library descriptor may provide a set of properties with default values that can be overridden when library is included. The major use case for library properties is to specify a particular version of library. If descriptor has only one property, it can be defined without naming: <pre><code>%use krangl(0.10)\n</code></pre> If library descriptor defines more than one property, property names should be used: <pre><code>%use spark(scala=2.11.10, spark=2.4.2)\n</code></pre> Several libraries can be included in single <code>%use</code> statement, separated by <code>,</code>: <pre><code>%use lets-plot, krangl, mysql(8.0.15)\n</code></pre> You can also specify the source of library descriptor. By default, it's taken from the libraries repository. If you want to try descriptor from another revision, use the following syntax: <pre><code>// Specify some git tag from this repository\n%use lets-plot@0.8.2.5\n// Specify commit sha, with more verbose syntax\n%use lets-plot@ref[24a040fe22335648885b106e2f4ddd63b4d49469]\n// Specify git ref along with library arguments\n%use krangl@dev(0.10)\n</code></pre> Note that using descriptor from specific revision is better than using <code>%useLatestDescriptors</code>.</p> <p>Other options are resolving library descriptor from a local file or from remote URL: <pre><code>// Load library from file\n%use mylib@file[/home/user/lib.json]\n// Load library from file: kernel will guess it's a file actually\n%use @/home/user/libs/lib.json\n// Or use another approach: specify a directory and file name without \n// extension (it should be JSON in such case) before it\n%use lib@/home/user/libs\n// Load library descriptor from a remote URL\n%use herlib@url[https://site.com/lib.json]\n// If your URL responds with 200(OK), you may skip `url[]` part:\n%use @https://site.com/lib.json\n// You may omit library name for file and URL resolution:\n%use @file[lib.json]\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/#list-of-supported-libraries","title":"List of supported libraries:","text":"<ul> <li>2p-kt - Kotlin Multi-Platform ecosystem for symbolic AI</li> <li>biokotlin - BioKotlin aims to be a high-performance bioinformatics library that brings the power and speed of compiled programming languages to scripting and big data environments.</li> <li>combinatoricskt - A combinatorics library for Kotlin</li> <li>coroutines - Asynchronous programming and reactive streams support</li> <li>dataframe - Kotlin framework for structured data processing</li> <li>datetime - Kotlin date/time library</li> <li>deeplearning4j - Deep learning library for the JVM</li> <li>deeplearning4j-cuda - Deep learning library for the JVM (CUDA support)</li> <li>default - Default imports: dataframe and Kandy libraries</li> <li>exposed - Kotlin SQL framework</li> <li>fuel - HTTP networking library</li> <li>gradle-enterprise-api-kotlin - A library to use the Gradle Enterprise API in Kotlin scripts or projects</li> <li>gral - Java library for displaying plots</li> <li>jdsp - Java library for signal processing</li> <li>kalasim - Discrete event simulator</li> <li>kaliningraph - Graph library with a DSL for constructing graphs and visualizing the behavior of graph algorithms</li> <li>kandy - Kotlin plotting DSL for Lets-Plot</li> <li>kandy-echarts - Kotlin plotting DSL for Apache ECharts</li> <li>khttp - HTTP networking library</li> <li>klaxon - JSON parser for Kotlin</li> <li>kmath - Experimental Kotlin algebra-based mathematical library</li> <li>kotlin-dl - KotlinDL library which provides Keras-like API for deep learning</li> <li>kotlin-statistics - Idiomatic statistical operators for Kotlin</li> <li>krangl - Kotlin DSL for data wrangling</li> <li>kraphviz - Graphviz wrapper for JVM</li> <li>kravis - Kotlin grammar for data visualization</li> <li>kt-math - Kotlin multi-platform port of java.math.*</li> <li>lets-plot - Kotlin API for Lets-Plot: multiplatform plotting library based on Grammar of Graphics</li> <li>lets-plot-gt - Lets-Plot visualisation for GeoTools toolkit</li> <li>lib-ext - Extended functionality for Jupyter kernel</li> <li>londogard-nlp-toolkit - A Natural Language Processing (NLP) toolkit for Kotlin on the JVM</li> <li>multik - Multidimensional array library for Kotlin</li> <li>mysql - MySql JDBC Connector</li> <li>openai - OpenAI API for Jupyter Notebooks</li> <li>plotly - [beta] Plotly.kt jupyter integration for static plots.</li> <li>plotly-server - [beta] Plotly.kt jupyter integration for dynamic plots.</li> <li>rdkit - Open-Source Cheminformatics Software</li> <li>reflection - Imports for Kotlin Reflection</li> <li>roboquant - Algorithmic trading platform written in Kotlin</li> <li>serialization - Kotlin multi-format reflection-less serialization</li> <li>smile - Statistical Machine Intelligence and Learning Engine</li> <li>spark - Kotlin API for Apache Spark: unified analytics engine for large-scale data processing</li> <li>spark-streaming - Kotlin API for Apache Spark Streaming: scalable, high-throughput, fault-tolerant stream processing of live data streams</li> <li>webtau - WebTau end-to-end testing across layers</li> </ul>"},{"location":"kotlin-jupyter/docs/#rich-output","title":"Rich output","text":"<p>By default, the return values from REPL statements are displayed in the text form. To use richer representations, e.g. to display graphics or html, it is possible to send MIME-encoded result to the client using the <code>MIME</code> helper function: <pre><code>fun MIME(vararg mimeToData: Pair&lt;String, String&gt;): MimeTypedResult \n</code></pre> E.g.: <pre><code>MIME(\"text/html\" to \"&lt;p&gt;Some &lt;em&gt;HTML&lt;/em&gt;&lt;/p&gt;\", \"text/plain\" to \"No HTML for text clients\")\n</code></pre> HTML outputs can also be rendered with <code>HTML</code> helper function: <pre><code>fun HTML(text: String): MimeTypedResult\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/#rendering","title":"Rendering","text":"<p>Rendering is a procedure of transforming of the value to the form that is appropriate for displaying in Jupyter client. Kernel supports several features that allow you to render values.</p>"},{"location":"kotlin-jupyter/docs/#renderers","title":"Renderers","text":"<p>Renderers can transform a value into another value. Library can define one or several renderers. Rendering with renderers is controlled via <code>RenderersProcessor</code>. You can access it via <code>notebook</code>. Renderers are applied until at least one renderer can be applied.</p>"},{"location":"kotlin-jupyter/docs/#displayresult-and-renderable","title":"DisplayResult and Renderable","text":"<p>If object implements <code>DisplayResult</code> or <code>Renderable</code>, it will be rendered to output <code>JsonObject</code> via its own corresponding method.</p>"},{"location":"kotlin-jupyter/docs/#text-rendering","title":"Text rendering","text":"<p>Text renderers render objects to strings. Library can define one or several text renderers. Rendering with text renderers is controlled via <code>TextRenderersProcessor</code>. You can access it via <code>notebook</code>. Text renderers are applied until at least one renderer returns non-null string for a passed argument. This kind of renderers can be easily composed with each other. I.e. text renderer for iterables can render its elements with text renderers processor recursively.</p>"},{"location":"kotlin-jupyter/docs/#throwables-rendering","title":"Throwables rendering","text":"<p>Throwable renderers do the same thing as renderers do, but only for results of the cells that were not successfully executed, and some exception was generated.</p>"},{"location":"kotlin-jupyter/docs/#common-rendering-semantics","title":"Common rendering semantics","text":"<p>Successfully evaluated value is firstly transformed with RenderersProcessor. Resulting value is checked. If it's Renderable or DisplayResult, it is transformed into output JSON using <code>toJson()</code> method. If it's Unit, the cell won't have result at all. Otherwise, value is passed to <code>TextRenderersProcessor</code>. It tries to render the value to string using defined text renderers having in mind their priority. If all the renderers returned null, value is transformed to string using <code>toString()</code>. Resulting string is wrapped to <code>text/plain</code> MIME JSON.</p> <p>If the cell execution finished unsuccessfully and exception was generated, then the first applicable throwable renderer will be chosen for this exception, and exception will be passed to this renderer's <code>render()</code> method. Returned value will be displayed. If no applicable throwable renderer was found, exception message and stacktrace will be printed to stderr.</p>"},{"location":"kotlin-jupyter/docs/#autocompletion","title":"Autocompletion","text":"<p>Press <code>TAB</code> to get the list of suggested items for completion. In Jupyter Notebook, you don't need to press <code>TAB</code>, completion is requested automatically. Completion works for all globally defined symbols and for local symbols which were loaded into notebook during cells evaluation.</p>"},{"location":"kotlin-jupyter/docs/#error-analysis","title":"Error analysis","text":"<p>If you use Jupyter Notebook as Jupyter client, you will also see that compilation errors and warnings are underlined in red and in yellow correspondingly. This is achieved by kernel-level extension of Jupyter notebook which sends error-analysis requests to kernel and renders their results. If you hover the cursor over underlined text, you will get an error message which can help you to fix the error.</p>"},{"location":"kotlin-jupyter/docs/#debugging","title":"Debugging","text":"<ol> <li>Run <code>./gradlew installDebug</code>. Debugger port is selected automatically.    Default port is 1044, consequent ports will be used if it's in use. If you want an exact port, specify <code>-PdebugPort=&lt;port&gt;</code> Gradle option.</li> <li>Run <code>jupyter notebook</code>, open the desired notebook.</li> <li>Attach a remote debugger to JVM with corresponding port (debug port number will be printed in terminal on kernel startup).</li> </ol>"},{"location":"kotlin-jupyter/docs/#adding-new-libraries","title":"Adding new libraries","text":"<p>Read this article if you want to support new <code>JVM</code> library in the kernel.</p>"},{"location":"kotlin-jupyter/docs/#documentation","title":"Documentation","text":"<p>There is a site with rendered KDoc comments from the codebase. If you are a library author you may be interested in <code>api</code> module (see adding new libraries). There is also a <code>lib</code> module which contains entities available from the Notebook cells and <code>shared-compiler</code> module which may be used for Jupyter REPL integration into standalone application or IDEA plugin.</p>"},{"location":"kotlin-jupyter/docs/#contributing","title":"Contributing","text":"<p>We welcome contributions to further enhance our project! If you come across any issues or have feature requests, please don't hesitate to file an issue.</p> <p>For issues specifically related to the Kotlin Notebook plugin, kindly utilize another tracker.</p> <p>Pull requests are highly appreciated! When submitting a pull request, please ensure that it corresponds to an existing issue. If you are planning a substantial change, we recommend discussing it with a project maintainer. You can reach out to me through email, Kotlin Slack, or Telegram. We look forward to your contributions!</p>"},{"location":"kotlin-jupyter/docs/README-STUB/","title":"README STUB","text":""},{"location":"kotlin-jupyter/docs/README-STUB/#kotlin-kernel-for-ipythonjupyter","title":"Kotlin Kernel for IPython/Jupyter","text":"<p>Kotlin ([[kotlin_version]]) kernel for Jupyter.</p> <p>The kernel is a powerful engine designed to enhance your Kotlin REPL experience. It offers support for executing code cells, providing basic code completion, and analyzing errors. With the Kotlin kernel, you gain access to a range of features, including an API for handling outputs, retrieving information from previously executed code snippets, executing generic Kotlin code effortlessly, seamless integration with libraries, and more.</p> <p></p> <p>Beta version. Tested with Jupyter Notebook, Jupyter Lab, and Jupyter Console on Windows, Ubuntu Linux, and macOS. The minimal supported versions of clients are given in the table below:</p> Client Version Jupyter Lab 1.2.6 Jupyter Notebook 6.0.3 Jupyter Console 6.1.0 <p>To start using the Kotlin kernel for Jupyter, take a look at the introductory guide.</p> <p>Example notebooks can be found in the samples folder.</p> <p>Try samples online: </p>"},{"location":"kotlin-jupyter/docs/README-STUB/#contents","title":"Contents","text":"<ul> <li>Installation<ul> <li>Kotlin Notebook plugin</li> <li>Conda</li> <li>Pip</li> <li>From sources</li> <li>Troubleshooting</li> </ul> </li> <li>Updating<ul> <li>Kotlin Notebook</li> <li>Datalore</li> <li>Conda</li> <li>Pip</li> </ul> </li> <li>Usage<ul> <li>Kotlin Notebook</li> <li>Other clients</li> <li>Creating Kernels</li> </ul> </li> <li>Supported functionality<ul> <li>REPL commands</li> <li>Dependencies resolving</li> <li>Default repositories</li> <li>Line Magics</li> <li>Supported Libraries<ul> <li>List of supported libraries:</li> </ul> </li> <li>Rich output</li> <li>Rendering<ul> <li>Renderers</li> <li>DisplayResult and Renderable</li> <li>Text rendering</li> <li>Throwables rendering</li> <li>Common rendering semantics</li> </ul> </li> <li>Autocompletion</li> <li>Error analysis</li> </ul> </li> <li>Debugging</li> <li>Adding new libraries</li> <li>Documentation</li> <li>Contributing</li> </ul>"},{"location":"kotlin-jupyter/docs/README-STUB/#installation","title":"Installation","text":"<p>There are several ways to use the kernel:</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#kotlin-notebook-plugin","title":"Kotlin Notebook plugin","text":"<p>Simply download and use the latest version of the Kotlin Notebook plugin from the Marketplace. The Kotlin kernel is embedded in it.</p> <p>Check out the blog post for a quick introduction to Kotlin Notebook.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#conda","title":"Conda","text":"<p>If you have <code>conda</code> installed, run the following command to install the stable package version:</p> <p><code>conda install -c jetbrains kotlin-jupyter-kernel</code> (package home)</p> <p>To install the conda package from the dev channel:</p> <p><code>conda install -c jetbrains-dev kotlin-jupyter-kernel</code> (package home)</p> <p>Uninstall: <code>conda remove kotlin-jupyter-kernel</code></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#pip","title":"Pip","text":"<p>You can also install this package using <code>pip</code>:</p> <p>Stable: <code>pip install kotlin-jupyter-kernel</code> (package home)</p> <p>Dev: <code>pip install -i https://test.pypi.org/simple/ kotlin-jupyter-kernel</code> (package home)</p> <p>Uninstall: <code>pip uninstall kotlin-jupyter-kernel</code></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#from-sources","title":"From sources","text":"<p>To install the kernel from sources, clone the repository and run the following command in the root folder:</p> <p><code>./gradlew install</code></p> <p>Default installation path is <code>~/.ipython/kernels/kotlin/</code>. To install to some other location use option <code>-PinstallPath=</code>, but note that Jupyter looks for the kernel specs files only in predefined places. For more detailed info see Jupyter docs.</p> <p>Uninstall: <code>./gradlew uninstall</code></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#troubleshooting","title":"Troubleshooting","text":"<p>There could be a problem with kernel spec detection because of different python environments and installation modes. If you are using pip or conda to install the package, try running post-install fixup script: <pre><code>python -m kotlin_kernel fix-kernelspec-location\n</code></pre></p> <p>This script replaces kernel specs to the \"user\" path where they are always detected. Don't forget to re-run this script on the kernel update.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#updating","title":"Updating","text":"<p>To update the Kotlin kernel, follow the instructions below based on your installation method:</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#kotlin-notebook","title":"Kotlin Notebook","text":"<p>If you are using the Kotlin Notebook plugin, update it to the latest version within the IDE or manually download and install the latest plugin version from the Marketplace.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#datalore","title":"Datalore","text":"<p>To update the kernel in Datalore, simply add an <code>environment.yml</code> to the Notebook files containing: <pre><code>datalore-env-format-version: \"0.2\"\ndatalore-package-manager: \"pip\"\ndatalore-base-env: \"default\"\ndependencies:\n- pip:\n  - kotlin-jupyter-kernel=={VERSION}\n</code></pre> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>. Stop and restart the machine afterwards.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#conda_1","title":"Conda","text":"<p>If you have <code>conda</code> installed, just run the following command to update the stable package version:</p> <p><code>conda update -c jetbrains kotlin-jupyter-kernel</code></p> <p>To update the conda package from the dev channel:</p> <p><code>conda update -c jetbrains-dev kotlin-jupyter-kernel</code></p> <p>If you want to change to a specific version of the kernel, take the <code>install</code> command from above and add <code>={VERSION}</code> to <code>kotlin-jupyter-kernel</code> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>.</p> <p>For example, for the stable version:</p> <p><code>conda install -c jetbrains kotlin-jupyter-kernel={VERSION}</code></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#pip_1","title":"Pip","text":"<p>To update the kernel using Pip, simply run:</p> <p>Stable: <code>pip install kotlin-jupyter-kernel --upgrade</code></p> <p>Dev: <code>pip install -i https://test.pypi.org/simple/ kotlin-jupyter-kernel --upgrade</code></p> <p>If you want to change to a specific version of the kernel, take the <code>install</code> command from above and add <code>=={VERSION}</code> to <code>kotlin-jupyter-kernel</code> where <code>{VERSION}</code> should be replaced by the latest PyPi version of the Kotlin Jupyter kernel, such as <code>0.11.0.198</code>.</p> <p>For example, for the stable version:</p> <p><code>pip install kotlin-jupyter-kernel=={VERSION} --ignore-installed</code></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#usage","title":"Usage","text":""},{"location":"kotlin-jupyter/docs/README-STUB/#kotlin-notebook_1","title":"Kotlin Notebook","text":"<p>Within IDEA with installed Kotlin Notebook plugin, just open a notebook, and you're good to go.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#other-clients","title":"Other clients","text":"<p>Run one of the following commands in console:</p> <ul> <li><code>jupyter console --kernel=kotlin</code></li> <li><code>jupyter notebook</code></li> <li><code>jupyter lab</code></li> </ul> <p>To start using <code>kotlin</code> kernel inside Jupyter Notebook or JupyterLab create a new notebook with <code>kotlin</code> kernel.</p> <p>The default kernel will use the JDK pointed to by the environment variable <code>KOTLIN_JUPYTER_JAVA_HOME</code>, or <code>JAVA_HOME</code> if the first is not set.</p> <p>JVM arguments will be set from the environment variable <code>KOTLIN_JUPYTER_JAVA_OPTS</code> or <code>JAVA_OPTS</code> if the first is not set. Additionally, arguments from <code>KOTLIN_JUPYTER_JAVA_OPTS_EXTRA</code> will be added. Arguments are parsed using <code>shlex.split</code>.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#creating-kernels","title":"Creating Kernels","text":"<p>To create a kernel for a specific JDK, JVM arguments, and environment variables, you can use the <code>add-kernel</code> script: <pre><code>python -m kotlin_kernel add-kernel [--name name] [--jdk jdk_home_dir] [--set-jvm-args] [--jvm-arg arg]* [--env KEY VALUE]* [--force]\n</code></pre> The command uses <code>argparse</code>, so <code>--help</code>, <code>@argfile</code> (you will need to escape the <code>@</code> in powershell), and <code>--opt=value</code> are all supported.  <code>--jvm-arg=arg</code> in particular is needed when passing JVM arguments that start with <code>-</code>.</p> <p>If <code>jdk</code> not specified, <code>name</code> is required.  If <code>name</code> is not specified but <code>jdk</code> is the name will be <code>JDK $vendor $version</code> detected from the JDK.  Regardless, the actual name of the kernel will be <code>Kotlin ($name)</code>, and the directory will be <code>kotlin_$name</code> with the spaces in <code>name</code> replaced by underscores (so make sure it's compatible with your file system).</p> <p>JVM arguments are joined with a <code>' '</code>, so multiple JVM arguments in the same argument are supported. The arguments will be added to existing ones (see above section) unless <code>--set-jvm-args</code> is present, in which case they will be set to <code>KOTLIN_JUPYTER_JAVA_OPTS</code>.  Note that both adding and setting work fine alongside <code>KOTLIN_JUPYTER_JAVA_OPTS_EXTRA</code>.</p> <p>While jupyter kernel environment variable substitutions are supported in <code>env</code>, note that if the used environment variable doesn't exist, nothing will be replaced.</p> <p>An example: <pre><code>python -m kotlin_kernel add-kernel --name \"JDK 15 Big 2 GPU\" --jdk ~/.jdks/openjdk-15.0.2 --jvm-arg=-Xmx8G --env CUDA_VISIBLE_DEVICES 0,1\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#supported-functionality","title":"Supported functionality","text":""},{"location":"kotlin-jupyter/docs/README-STUB/#repl-commands","title":"REPL commands","text":"<p>The following REPL commands are supported: [[supported_commands]]</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#dependencies-resolving","title":"Dependencies resolving","text":"<p>It is possible to add dynamic dependencies to the notebook using the following annotations: - <code>@file:DependsOn(&lt;coordinates&gt;)</code> - adds artifacts to classpath. Supports absolute and relative paths to class   directories or jars, ivy and maven artifacts represented by the colon separated string - <code>@file:Repository(&lt;absolute-path&gt;)</code> - adds a directory for relative path resolution or ivy/maven repository.   To specify Maven local, use <code>@file:Repository(\"*mavenLocal\")</code>.</p> <p>Alternative way to do the same is using Gradle-like syntax:</p> <pre><code>USE {\n    repositories {\n        maven {\n            url = \"https://my.secret.repo/maven/\"\n            credentials {\n                username = USER\n                password = TOKEN\n            }\n        }\n    }\n\n    dependencies {\n        val ktorVersion = \"2.0.3\"\n\n        implementation(\"my.secret:artifact:1.0-beta\")\n        implementation(\"io.ktor:ktor-client-core:$ktorVersion\")\n        implementation(\"io.ktor:ktor-client-apache:$ktorVersion\")\n    }\n}\n</code></pre> <p>The same syntax can be used in integrations creating.</p> <p>Note that dependencies in remote repositories are resolved via Maven resolver. Caches are stored in <code>~/.m2/repository</code> folder by default. Sometimes, due to network issues or running several artifacts resolutions in parallel, caches may get corrupted. If you have some troubles with artifacts resolution, please remove caches, restart kernel and try again.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#default-repositories","title":"Default repositories","text":"<p>The following maven repositories are included by default: - Maven Central - JitPack</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#line-magics","title":"Line Magics","text":"<p>The following line magics are supported: [[magics]]</p> <p>See detailed info about line magics here.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#supported-libraries","title":"Supported Libraries","text":"<p>When a library is included with <code>%use</code> keyword, the following functionality is added to the notebook: - repositories to search for library artifacts - artifact dependencies - default imports - library initialization code - renderers for special types, e.g. charts and data frames</p> <p>This behavior is defined by <code>json</code> library descriptor. Descriptors for all supported libraries can be found in libraries repository. A library descriptor may provide a set of properties with default values that can be overridden when library is included. The major use case for library properties is to specify a particular version of library. If descriptor has only one property, it can be defined without naming: <pre><code>%use krangl(0.10)\n</code></pre> If library descriptor defines more than one property, property names should be used: <pre><code>%use spark(scala=2.11.10, spark=2.4.2)\n</code></pre> Several libraries can be included in single <code>%use</code> statement, separated by <code>,</code>: <pre><code>%use lets-plot, krangl, mysql(8.0.15)\n</code></pre> You can also specify the source of library descriptor. By default, it's taken from the libraries repository. If you want to try descriptor from another revision, use the following syntax: <pre><code>// Specify some git tag from this repository\n%use lets-plot@0.8.2.5\n// Specify commit sha, with more verbose syntax\n%use lets-plot@ref[24a040fe22335648885b106e2f4ddd63b4d49469]\n// Specify git ref along with library arguments\n%use krangl@dev(0.10)\n</code></pre> Note that using descriptor from specific revision is better than using <code>%useLatestDescriptors</code>.</p> <p>Other options are resolving library descriptor from a local file or from remote URL: <pre><code>// Load library from file\n%use mylib@file[/home/user/lib.json]\n// Load library from file: kernel will guess it's a file actually\n%use @/home/user/libs/lib.json\n// Or use another approach: specify a directory and file name without \n// extension (it should be JSON in such case) before it\n%use lib@/home/user/libs\n// Load library descriptor from a remote URL\n%use herlib@url[https://site.com/lib.json]\n// If your URL responds with 200(OK), you may skip `url[]` part:\n%use @https://site.com/lib.json\n// You may omit library name for file and URL resolution:\n%use @file[lib.json]\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#list-of-supported-libraries","title":"List of supported libraries:","text":"<p>[[supported_libraries]]</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#rich-output","title":"Rich output","text":"<p>By default, the return values from REPL statements are displayed in the text form. To use richer representations, e.g. to display graphics or html, it is possible to send MIME-encoded result to the client using the <code>MIME</code> helper function: <pre><code>fun MIME(vararg mimeToData: Pair&lt;String, String&gt;): MimeTypedResult \n</code></pre> E.g.: <pre><code>MIME(\"text/html\" to \"&lt;p&gt;Some &lt;em&gt;HTML&lt;/em&gt;&lt;/p&gt;\", \"text/plain\" to \"No HTML for text clients\")\n</code></pre> HTML outputs can also be rendered with <code>HTML</code> helper function: <pre><code>fun HTML(text: String): MimeTypedResult\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/README-STUB/#rendering","title":"Rendering","text":"<p>Rendering is a procedure of transforming of the value to the form that is appropriate for displaying in Jupyter client. Kernel supports several features that allow you to render values.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#renderers","title":"Renderers","text":"<p>Renderers can transform a value into another value. Library can define one or several renderers. Rendering with renderers is controlled via <code>RenderersProcessor</code>. You can access it via <code>notebook</code>. Renderers are applied until at least one renderer can be applied.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#displayresult-and-renderable","title":"DisplayResult and Renderable","text":"<p>If object implements <code>DisplayResult</code> or <code>Renderable</code>, it will be rendered to output <code>JsonObject</code> via its own corresponding method.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#text-rendering","title":"Text rendering","text":"<p>Text renderers render objects to strings. Library can define one or several text renderers. Rendering with text renderers is controlled via <code>TextRenderersProcessor</code>. You can access it via <code>notebook</code>. Text renderers are applied until at least one renderer returns non-null string for a passed argument. This kind of renderers can be easily composed with each other. I.e. text renderer for iterables can render its elements with text renderers processor recursively.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#throwables-rendering","title":"Throwables rendering","text":"<p>Throwable renderers do the same thing as renderers do, but only for results of the cells that were not successfully executed, and some exception was generated.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#common-rendering-semantics","title":"Common rendering semantics","text":"<p>Successfully evaluated value is firstly transformed with RenderersProcessor. Resulting value is checked. If it's Renderable or DisplayResult, it is transformed into output JSON using <code>toJson()</code> method. If it's Unit, the cell won't have result at all. Otherwise, value is passed to <code>TextRenderersProcessor</code>. It tries to render the value to string using defined text renderers having in mind their priority. If all the renderers returned null, value is transformed to string using <code>toString()</code>. Resulting string is wrapped to <code>text/plain</code> MIME JSON.</p> <p>If the cell execution finished unsuccessfully and exception was generated, then the first applicable throwable renderer will be chosen for this exception, and exception will be passed to this renderer's <code>render()</code> method. Returned value will be displayed. If no applicable throwable renderer was found, exception message and stacktrace will be printed to stderr.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#autocompletion","title":"Autocompletion","text":"<p>Press <code>TAB</code> to get the list of suggested items for completion. In Jupyter Notebook, you don't need to press <code>TAB</code>, completion is requested automatically. Completion works for all globally defined symbols and for local symbols which were loaded into notebook during cells evaluation.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#error-analysis","title":"Error analysis","text":"<p>If you use Jupyter Notebook as Jupyter client, you will also see that compilation errors and warnings are underlined in red and in yellow correspondingly. This is achieved by kernel-level extension of Jupyter notebook which sends error-analysis requests to kernel and renders their results. If you hover the cursor over underlined text, you will get an error message which can help you to fix the error.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#debugging","title":"Debugging","text":"<ol> <li>Run <code>./gradlew installDebug</code>. Debugger port is selected automatically.    Default port is 1044, consequent ports will be used if it's in use. If you want an exact port, specify <code>-PdebugPort=&lt;port&gt;</code> Gradle option.</li> <li>Run <code>jupyter notebook</code>, open the desired notebook.</li> <li>Attach a remote debugger to JVM with corresponding port (debug port number will be printed in terminal on kernel startup).</li> </ol>"},{"location":"kotlin-jupyter/docs/README-STUB/#adding-new-libraries","title":"Adding new libraries","text":"<p>Read this article if you want to support new <code>JVM</code> library in the kernel.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#documentation","title":"Documentation","text":"<p>There is a site with rendered KDoc comments from the codebase. If you are a library author you may be interested in <code>api</code> module (see adding new libraries). There is also a <code>lib</code> module which contains entities available from the Notebook cells and <code>shared-compiler</code> module which may be used for Jupyter REPL integration into standalone application or IDEA plugin.</p>"},{"location":"kotlin-jupyter/docs/README-STUB/#contributing","title":"Contributing","text":"<p>We welcome contributions to further enhance our project! If you come across any issues or have feature requests, please don't hesitate to file an issue.</p> <p>For issues specifically related to the Kotlin Notebook plugin, kindly utilize another tracker.</p> <p>Pull requests are highly appreciated! When submitting a pull request, please ensure that it corresponds to an existing issue. If you are planning a substantial change, we recommend discussing it with a project maintainer. You can reach out to me through email, Kotlin Slack, or Telegram. We look forward to your contributions!</p>"},{"location":"kotlin-jupyter/docs/compatibility/","title":"Compatibility table","text":"<p>Kotlin kernel is built on top of other libraries. Most importantly, on top of Kotlin scripting and on top of KSP which requires specific version of Kotlin. In the table below you can see the published versions of Kotlin kernel and versions of the most important libraries which were used in this build.</p> Kernel version Maven artifacts version Kotlin scripting Used Kotlin compiler Kotlin dependencies for Gradle plugin Kotlin language level KSP 0.11.0.204 0.11.0-204 1.8.0-RC 1.8.0-RC 1.8.0-RC 1.8 1.8.0-RC-1.0.8 0.11.0.206 0.11.0-206 1.8.0-RC 1.8.0-RC 1.8.0-RC 1.8 1.8.0-RC-1.0.8 0.11.0.207 0.11.0-207 1.8.0-RC 1.8.0-RC 1.8.0-RC 1.8 1.8.0-RC-1.0.8 0.11.0.208 0.11.0-208 1.8.0-RC 1.8.0-RC 1.8.0-RC 1.8 1.8.0-RC-1.0.8 0.11.0.209 0.11.0-209 1.8.0-RC 1.8.0-RC 1.8.0-RC 1.8 1.8.0-RC-1.0.8 0.11.0.210 0.11.0-210 1.8.0-RC2 1.8.0-RC2 1.8.0-RC2 1.8 1.8.0-RC2-1.0.8 0.11.0.212 0.11.0-212 1.8.0-RC2 1.8.0-RC2 1.8.0-RC2 1.8 1.8.0-RC2-1.0.8 0.11.0.213 0.11.0-213 1.8.0-RC2 1.8.0-RC2 1.8.0-RC2 1.8 1.8.0-RC2-1.0.8 0.11.0.214 0.11.0-214 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.227 0.11.0-227 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.228 0.11.0-228 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.229 0.11.0-229 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.230 0.11.0-230 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.232 0.11.0-232 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.233 0.11.0-233 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.234 0.11.0-234 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.235 0.11.0-235 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.236 0.11.0-236 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.238 0.11.0-238 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.239 0.11.0-239 1.8.0 1.8.0 1.8.0 1.8 1.8.0-1.0.8 0.11.0.240 0.11.0-240 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.248 0.11.0-248 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.302 0.11.0-302 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.311 0.11.0-311 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.312 0.11.0-312 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.314 0.11.0-314 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.315 0.11.0-315 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.316 0.11.0-316 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.317 0.11.0-317 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.318 0.11.0-318 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.319 0.11.0-319 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.320 0.11.0-320 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.321 0.11.0-321 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.322 0.11.0-322 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9 0.11.0.323 0.11.0-323 1.8.20-Beta 1.8.20-Beta 1.8.20-Beta 1.8 1.8.20-Beta-1.0.9"},{"location":"kotlin-jupyter/docs/libraries/","title":"Adding new libraries","text":"<ul> <li>Overview</li> <li>Supported integration features<ul> <li>Dependencies<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Repositories<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Initial imports<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks after library loading (called once)<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks before each cell execution<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks after each cell execution<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks on cell execution interruption<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks right before kernel shutdown<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Callbacks on color scheme change<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Results renderers<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Results text renderers<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Throwables renderers<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Variables handling<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Annotated classes handling<ul> <li>JupyterIntegration API</li> </ul> </li> <li>File annotations handling<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Code preprocessing<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Library static resources loading<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Variables reporting</li> <li>Internal variables markers<ul> <li>JupyterIntegration API</li> </ul> </li> <li>Typename rules for transitively loaded integration classes<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Minimal kernel version supported by the library<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Library options<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Link to the library site<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> <li>Library description<ul> <li>Descriptor API</li> <li>JupyterIntegration API</li> </ul> </li> </ul> </li> <li>Creating library descriptor</li> <li>Integration using Kotlin API<ul> <li>Adding library integration using KSP plugin</li> <li>Adding library integration avoiding use of annotation processor</li> <li>Integration testing for the integration logic</li> <li>Integration using other build systems</li> </ul> </li> </ul>"},{"location":"kotlin-jupyter/docs/libraries/#overview","title":"Overview","text":"<p>Generally, there are two ways of adding new library: 1. Creating JSON library descriptor. It's easy-to-go solution that doesn't even    require you to make any changes to the library itself. You create a JSON file and get the ability to define most    frequently used features such as renderers and initial imports. This descriptor is loaded into notebook    with help of <code>%use</code> line magic. Exact syntax depends on where the descriptor is located. 2. Integration using Kotlin API. Here, you define an integration class    in your library code (or you can create a separate project for integration if it's a library you don't maintain).    You can then use all available integration features in this case. Integration is loaded automatically when    the JAR containing <code>META-INF/kotlin-jupyter-libraries/libraries.json</code> file with the integration class name in it    is added to the current notebook classpath. It can be done with <code>@file:DependsOn</code> annotation or with help of    descriptor (see above) that defines the corresponding dependency. Additionally, it is possible to write tests    for this kind of integrations.</p> <p>Library integrations regardless of the way they are defined may define dependencies and some callbacks (code executions). Dependencies may contain Kotlin API based integrations, and code executions may contain <code>%use</code> statements which means that library integrations may load other libraries, and so on. Don't hesitate to rely on this feature.</p> <p>Summing up, if you want to use a feature from the table below, you can do one of the following:</p> <ol> <li>If the feature is supported in descriptor API, you can create a JSON file containing this feature description as it is described below.    This JSON file is then loaded into notebook via <code>%use</code> line magic.</li> <li>If the feature is supported in descriptor API, you can load corresponding JSON string directly using    <code>loadLibraryDescriptor</code> method inside notebook cell.</li> <li>You can add the feature directly from the notebook cell using <code>USE {}</code> method and taking corresponding    methods from \"JupyterIntegration API\" column, i.e.     <pre><code>USE {\n    import(\"my.awesome.Clazz\")\n}\n</code></pre></li> <li>You can add the feature directly from the notebook cell if you have an instance of <code>LibraryDefinition</code> (that    could be created i.e. using <code>libraryDefinition {}</code> method), using following syntax:     <pre><code>USE(libraryDefinition)\n</code></pre></li> <li>Inside a Kotlin JVM library, you can create a class implementing <code>LibraryDefinition</code> / <code>LibraryDefinitionProducer</code> in one of the following ways:<ul> <li>Just create a direct implementor of <code>LibraryDefinition</code>. Override properties defined in \"LibraryDefinition API\" column</li> <li>Extend <code>LibraryDefinitionImpl</code>. Set its properties defined in \"LibraryDefinition API\" column</li> <li>Implement <code>JupyterIntegration</code>. Override <code>Builder.onLoaded</code> method and use methods from <code>JupyterIntegration API</code> column   This class is to be loaded into notebook via <code>%use</code> command along with the whole library artifact. To let the notebook know about this class,   you should adjust the build correspondingly. If you don't adjust the build, class will not be loaded, but you can   still load this class from the notebook using <code>loadLibraryDefinitions()</code> or <code>loadLibraryProducers()</code> methods.</li> </ul> </li> </ol>"},{"location":"kotlin-jupyter/docs/libraries/#supported-integration-features","title":"Supported integration features","text":"<p>All supported integration features are given in the following table. You can also learn the API using this interactive guide.</p> Feature Descriptor API LibraryDefinition API JupyterIntegration API Dependencies <code>dependencies</code> <code>dependencies</code> <code>dependencies()</code> Repositories <code>repositories</code> <code>repositories</code> <code>repositories()</code><code>addRepository()</code><code>repository()</code> Initial imports <code>imports</code> <code>imports</code> <code>import()</code><code>importPackage()</code> Callbacks after library loading (called once) <code>init</code> <code>init</code> <code>onLoaded{}</code> Callbacks before each cell execution <code>initCell</code> <code>initCell</code> <code>beforeCellExecution{}</code> Callbacks after each cell execution - <code>afterCellExecution</code> <code>afterCellExecution{}</code> Callbacks on cell execution interruption - <code>interruptionCallbacks</code> <code>onInterrupt{}</code> Callbacks right before kernel shutdown <code>shutdown</code> <code>shutdown</code> <code>onShutdown{}</code> Callbacks on color scheme change - <code>colorSchemeChangedCallbacks</code> <code>onColorSchemeChange{}</code> Results renderers <code>renderers</code> <code>renderers</code> <code>addRenderer()</code><code>render&lt;T&gt;{}</code><code>renderWithHost&lt;T&gt;{}</code> Results text renderers - <code>textRenderers</code> <code>addTextRenderer()</code> Throwables renderers - <code>throwableRenderers</code> <code>addThrowableRenderer()</code><code>renderThrowable&lt;T&gt;{}</code> Variables handling - <code>converters</code> <code>addTypeConverter()</code><code>onVariable{}</code><code>updateVariable{}</code><code>onVariableByRuntimeType{}</code><code>updateVariableByRuntimeType{}</code> Annotated classes handling - <code>classAnnotations</code> <code>addClassAnnotationHandler()</code><code>onClassAnnotation&lt;T&gt;{}</code> File annotations handling - <code>fileAnnotations</code> <code>addFileAnnotationHanlder()</code><code>onFileAnnotation&lt;T&gt;{}</code> Code preprocessing - <code>codePreprocessors</code> <code>addCodePreprocessor()</code><code>preprocessCodeWithLibraries{}</code><code>preprocessCode{}</code> Library static resources loading <code>resources</code> <code>resources</code> <code>resource()</code> Internal variables markers - <code>internalVariablesMarkers</code> <code>markVariableInternal()</code> Typename rules for transitively loaded integration classes <code>integrationTypeNameRules</code> <code>integrationTypeNameRules</code> <code>addIntegrationTypeNameRule()</code><code>acceptIntegrationTypeNameIf{}</code><code>discardIntegrationTypeNameIf{}</code> Minimal kernel version supported by the library <code>minKernelVersion</code> <code>minKernelVersion</code> <code>setMinimalKernelVersion()</code> Library options <code>properties</code> <code>options</code> <code>addOption()</code><code>addOptions()</code> Link to the library site, used to generate README <code>link</code> <code>website</code> <code>setWebsite()</code> Library description, used to generate README <code>description</code> <code>description</code> <code>setDescription()</code>"},{"location":"kotlin-jupyter/docs/libraries/#dependencies","title":"Dependencies","text":"<p>It doesn't matter what API you're using for adding dependencies, they are just Kotlin strings in the end.</p> <p>These are strings describing notebook dependencies: - Coordinates of Maven dependencies in form of <code>&lt;group&gt;:&lt;artifact&gt;:&lt;version&gt;</code> - Absolute paths to the local JAR files - Absolute paths to the local directories containing classes</p> <p>Mind the following: - <code>compile</code> and <code>runtime</code> scopes of dependencies are resolved transitively, but they all are added to   both compile and runtime classpath. That's why you may see undesired variants offered in completion - In Kotlin Notebook, sources of the dependencies are being resolved and included into response metadata.   In other clients, they do not. To control this behavior, use <code>SessionOptions.resolveSources</code> - MPP libraries are usually not resolved by Maven resolver. You should either use <code>jvm</code> variants of these   artifacts or enable experimental multiplatform resolution with <code>SessionOptions.resolveMpp</code> - To show current notebook classpath, use <code>:classpath</code> command</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api","title":"Descriptor API","text":"<pre><code>{\n  \"dependencies\": [\n    \"&lt;dependency1&gt;\",\n    \"&lt;dependency2&gt;\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api","title":"JupyterIntegration API","text":"<pre><code>USE {\n    dependencies(\"&lt;dependency1&gt;\", \"&lt;dependency2&gt;\")\n    // or\n    dependencies {\n        implememntation(\"&lt;dependency1&gt;\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#repositories","title":"Repositories","text":"<p>Repositories are strings describing where the dependencies come from: - Maven repositories (URLs + possible credentials) - Local directories, relatively to which local dependencies are resolved</p> <p>Maven repositories might have credentials.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_1","title":"Descriptor API","text":"<pre><code>{\n  \"repositories\": [\n    \"&lt;repo1-url&gt;\",\n    {\n      \"path\": \"&lt;repo2-url&gt;\",\n      \"username\": \"auth-username\",\n      \"password\": \"auth-token\"\n    }\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_1","title":"JupyterIntegration API","text":"<pre><code>USE {\n    repositories(\"&lt;repo1&gt;\", \"&lt;repo2&gt;\")\n    // or\n    repositories {\n        maven {\n            url = \"&lt;repo1-url&gt;\"\n            credentials {\n                username = \"auth-username\"\n                password = \"auth-token\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#initial-imports","title":"Initial imports","text":"<p>Imports are just import declarations that are used by all the following cells. They could be star-ended and usual</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_2","title":"Descriptor API","text":"<pre><code>{\n  \"imports\": [\n    \"my.package.*\",\n    \"my.package.Clazz\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_2","title":"JupyterIntegration API","text":"<pre><code>USE {\n    imports(\"my.package.*\", \"my.package.Clazz\")\n    // or\n    import&lt;Clazz&gt;()\n    importPackage&lt;Clazz&gt;()\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-after-library-loading-called-once","title":"Callbacks after library loading (called once)","text":"<p>Code that is executed - and in case of descriptor API also compiled - right after library loading In descriptor API codes are executed separately and not merged into one snippet</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_3","title":"Descriptor API","text":"<pre><code>{\n  \"init\": [\n    \"val x = 3\",\n    \"%use dataframe\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_3","title":"JupyterIntegration API","text":"<pre><code>USE {\n    onLoaded {\n        println(\"Integration loaded\")\n        // Variable x will be visible inside the notebook\n        scheduleExecution(\"val x = 3\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-before-each-cell-execution","title":"Callbacks before each cell execution","text":"<p>Code that is executed - and in case of descriptor API also compiled - right before each user-initiated cell execution In descriptor API codes are executed separately and not merged into one snippet</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_4","title":"Descriptor API","text":"<pre><code>{\n  \"initCell\": [\n    \"val y = x + 1\",\n    \"println(\\\"abc\\\")\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_4","title":"JupyterIntegration API","text":"<pre><code>USE {\n    beforeCellExecution {\n        println(\"Before cell execution\")\n        // Variable x will be visible inside the notebook\n        scheduleExecution(\"val x = 3\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-after-each-cell-execution","title":"Callbacks after each cell execution","text":"<p>Code that is executed right after each user-initiated cell execution.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_5","title":"JupyterIntegration API","text":"<pre><code>USE {\n    afterCellExecution { snippetInstance, resultField -&gt;\n        println(\"After cell execution: ${resultField.name} = ${resultField.value}\")\n        // Variable x will be visible inside the notebook\n        scheduleExecution(\"val x = 3\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-on-cell-execution-interruption","title":"Callbacks on cell execution interruption","text":"<p>Code that is executed when cell execution was interrupted by user.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_6","title":"JupyterIntegration API","text":"<pre><code>USE {\n    onInterrupt {\n        println(\"Execution was interrupted...\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-right-before-kernel-shutdown","title":"Callbacks right before kernel shutdown","text":"<p>Code that is executed when user initiated a kernel shutdown.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_5","title":"Descriptor API","text":"<pre><code>{\n  \"shutdown\": [\n    \"val y = x + 1\",\n    \"println(\\\"abc\\\")\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_7","title":"JupyterIntegration API","text":"<pre><code>USE {\n    onShutdown {\n        println(\"Bye!\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#callbacks-on-color-scheme-change","title":"Callbacks on color scheme change","text":"<p>Code that is executed when the user changes color scheme in the IDE with the notebook opened and session started. It doesn't work this way in the clients different from Kotlin Notebook, but it's safe to use in any client.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_8","title":"JupyterIntegration API","text":"<pre><code>var isDark = notebook.currentColorScheme == ColorScheme.DARK\nUSE {\n    println(\"Dark? - $isDark\")\n\n    onColorSchemeChange { colorScheme -&gt;\n        isDark = colorScheme == ColorScheme.DARK\n        println(\"Color scheme is changed\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#results-renderers","title":"Results renderers","text":"<p>See information about rendering</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_6","title":"Descriptor API","text":"<pre><code>{\n  \"renderers\": {\n    \"org.jetbrains.letsPlot.intern.Plot\": \"HTML(frontendContext.getHtml($it as org.jetbrains.letsPlot.intern.Plot))\"\n  }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_9","title":"JupyterIntegration API","text":"<pre><code>USE {\n    render&lt;Plot&gt; {\n        HTML(frontendContext.getHtml(it))\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#results-text-renderers","title":"Results text renderers","text":"<p>See information about rendering</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_10","title":"JupyterIntegration API","text":"<pre><code>USE {\n    addTextRenderer { processor, table -&gt;\n        (table as? Table)?.let { frontendContext.getPlainText(it) }\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#throwables-renderers","title":"Throwables renderers","text":"<p>See information about rendering</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_11","title":"JupyterIntegration API","text":"<pre><code>USE {\n    renderThrowable&lt;NullPointerException&gt; { npe -&gt;\n        \"Isn't Kotlin null-safe?\"\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#variables-handling","title":"Variables handling","text":"<p>Variables handlers are run for each applicable property of executed snippets. They also give access to <code>KotlinKernelHost</code>, so it's possible to execute code there. See corresponding methods documentation for more information.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_12","title":"JupyterIntegration API","text":"<pre><code>USE {\n    updateVariable&lt;MyType&gt; { value, kProperty -&gt;\n        // MyWrapper class should be previously defined in the notebook\n        execute(\"MyWrapper(${kProperty.name})\").name\n    }\n\n    onVariable&lt;MyType2&gt; { value, kProperty -&gt;\n        println(\"Variable ${kProperty.name}=$value executed!\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#annotated-classes-handling","title":"Annotated classes handling","text":"<p>If you have an annotation with runtime retention, you can mark a cell's class with this annotation, and marked classes could be processed then. Annotations arguments are not available in this type of callback, but this API should become more consistent in the future versions of kernel.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_13","title":"JupyterIntegration API","text":"<pre><code>// Should have runtime retention\nannotation class MyAnnotation\n\nUSE {\n    onClassAnnotation&lt;MyAnnotation&gt; { classifiersList -&gt; println(\"Annotated classes: $classifiersList\") }\n}\n\n@MyAnnotation\nclass MyClass\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#file-annotations-handling","title":"File annotations handling","text":"<p>You can add file-level annotations to the code snippets. Examples of such annotations are <code>@file:DependsOn()</code> and <code>@file:Repository()</code> that are used by kernel to add dependencies to the notebook. In the callback you have access to the annotation object and can access assigned annotation properties.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_14","title":"JupyterIntegration API","text":"<pre><code>// Might have any retention, but files should be valid target\nannotation class MyAnnotation\n\nUSE {\n    onFileAnnotation&lt;MyAnnotation&gt; {\n        val myAnno = it.first() as MyAnnotation\n        println(\"My annotation object: $myAnno\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#code-preprocessing","title":"Code preprocessing","text":"<p>Code written by user could be amended in any way before execution. One of such transformations is magics preprocessing that are cut off of the code and specifically processed. It's possible to write your own preprocessor: it gets the code and should return amended code. Preprocessors are applied one after another depending on their priority and order.</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_15","title":"JupyterIntegration API","text":"<pre><code>USE {\n    preprocessCode { code -&gt; generateRunBlocking(code) }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#library-static-resources-loading","title":"Library static resources loading","text":"<p>Static resources such as JS and CSS files could be used by the library producing any HTML. Generally, some specific wrappers should be written to load resources correctly. You can do it yourself or let kernel infrastructure doing it for you. Resource bundles builder DSL is defined and documented here</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_16","title":"JupyterIntegration API","text":"<pre><code>USE {\n    resources {\n        js(\"plotly\") {\n            //...\n        }\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#variables-reporting","title":"Variables reporting","text":"<p>You can see what variables have been defined in the notebook - either in plain text or in HTML form </p>"},{"location":"kotlin-jupyter/docs/libraries/#internal-variables-markers","title":"Internal variables markers","text":"<p>To ignore some variables in the variable report, mark these variables as internal</p>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_17","title":"JupyterIntegration API","text":"<pre><code>USE {\n    markVariableInternal { prop -&gt;\n        prop.name.startsWith(\"_\")\n    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#typename-rules-for-transitively-loaded-integration-classes","title":"Typename rules for transitively loaded integration classes","text":"<p>As it was mentioned before, libraries can load other libraries transitively: either by executing <code>%use ...</code> as a part of the initialization code or by including a dependency that contains an integration. By default, all integration classes found in the dependencies, are loaded. But you can turn off loading of some integrations by using typename rules for skipping them. At the same time, library can load its integration class forcefully specifying \"accepting\" typename rule, so that even if typename is disabled by the loader library, corresponding class will be loaded.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_7","title":"Descriptor API","text":"<pre><code>{\n  \"integrationTypeNameRules\": [\n    \"-:org.jetbrains.kotlinx.dataframe.**\",\n    //\"+:org.jetbrains.kotlinx.dataframe.**\",\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_18","title":"JupyterIntegration API","text":"<pre><code>USE {\n    discardIntegrationTypeNameIf {\n        it.startsWith(\"org.jetbrains.kotlinx.dataframe.\")\n    }\n    //    acceptIntegrationTypeNameIf {\n    //        it.startsWith(\"org.jetbrains.kotlinx.dataframe.\")\n    //    }\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#minimal-kernel-version-supported-by-the-library","title":"Minimal kernel version supported by the library","text":"<p>You can define minimal kernel version that is supported by the library integration. In <code>JupyterIntegration</code> API it's also possible to check <code>notebook.kernelVersion</code> in a way you want.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_8","title":"Descriptor API","text":"<pre><code>{\n  \"minKernelVersion\": \"0.11.0.1\"\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_19","title":"JupyterIntegration API","text":"<pre><code>USE {\n    setMinimalKernelVersion(\"0.11.0.1\")\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#library-options","title":"Library options","text":"<p>Library options serve several goals:  - extract some frequently updatable parts of the library descriptors (such as library versions)  - assist Renovate GitHub app to update libraries versions  - pass some values transitively in library loading so that libraries might know through what other libraries they were  loaded</p> <p>Important! Give more unique names for the options of your library because these options could override some other options, and it may lead to unexpected quirks</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_9","title":"Descriptor API","text":"<p>Options ending with <code>-renovate-hint</code> are ignored in descriptors and shouldn't be visible</p> <pre><code>{\n  \"properties\": [\n    { \"name\": \"api\", \"value\": \"4.4.1\" },\n    { \"name\": \"api-renovate-hint\", \"value\": \"update: package=org.jetbrains.lets-plot:lets-plot-kotlin-kernel\" }\n  ],\n  \"dependencies\": [\n    \"org.company:library:$api\"\n  ]\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_20","title":"JupyterIntegration API","text":"<pre><code>USE {\n    // Options in JupyterIntegration API could be only used when this library loads some other integration transitively,\n    // and integration class' constructor has two arguments, second of which is of type `Map&lt;String, String&gt;`.\n    // All previously loaded options are put into the map and passed as an argument.\n    addOption(\"api\", \"4.4.1\")\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#link-to-the-library-site","title":"Link to the library site","text":"<p>Library integration might have a link to the library's site. They are embedded into the README and to the <code>:help</code> command, but only for descriptors.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_10","title":"Descriptor API","text":"<pre><code>{\n  \"link\": \"https://github.com/Kotlin/kandy\"\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_21","title":"JupyterIntegration API","text":"<pre><code>USE {\n    // doesn't mean much, just for API completeness. Might be used in the future\n    setWebsite(\"https://github.com/Kotlin/kandy\")\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#library-description","title":"Library description","text":"<p>Library integration might have a description. They are embedded into the README and to the <code>:help</code> command, but only for descriptors.</p>"},{"location":"kotlin-jupyter/docs/libraries/#descriptor-api_11","title":"Descriptor API","text":"<pre><code>{\n  \"description\": \"Kotlin plotting DSL for Lets-Plot\"\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#jupyterintegration-api_22","title":"JupyterIntegration API","text":"<pre><code>USE {\n    // doesn't mean much, just for API completeness. Might be used in the future\n    setDescription(\"Kotlin plotting DSL for Lets-Plot\")\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#creating-library-descriptor","title":"Creating library descriptor","text":"<p>To support new <code>JVM</code> library and make it available via <code>%use</code> magic command you need to create a library descriptor for it.</p> <p>Check libraries repository to see examples of library descriptors.</p> <p>Library descriptor is a <code>&lt;libName&gt;.json</code> file with the following fields: - <code>properties</code>: a dictionary of properties that are used within library descriptor - <code>description</code>: a short library description which is used for generating libraries list in README - <code>link</code>: a link to library homepage. This link will be displayed in <code>:help</code> command - <code>minKernelVersion</code>: a minimal version of Kotlin kernel which may be used with this descriptor - <code>repositories</code>: a list of maven or ivy repositories to search for dependencies - <code>dependencies</code>: a list of library dependencies - <code>imports</code>: a list of default imports for library - <code>init</code>: a list of code snippets to be executed when library is included - <code>initCell</code>: a list of code snippets to be executed before execution of any cell - <code>shutdown</code>: a list of code snippets to be executed on kernel shutdown. Any cleanup code goes here - <code>renderers</code>: a mapping from fully qualified names of types to be rendered to the Kotlin expression returning output value.   Source object is referenced as <code>$it</code> - <code>resources</code>: a list of JS/CSS resources. See this descriptor for example - <code>integrationTypeNameRules</code>: a list of rules for integration classes which are about to be loaded transitively. Each rule has the form <code>[+|-]:&lt;pattern&gt;</code> where <code>+</code> or <code>-</code> denotes if this pattern is accepted or declined. Pattern may consist of any characters. Special combinations are allowed: <code>?</code> (any single character or no character), <code>*</code> (any character sequence excluding dot), <code>**</code> (any character sequence).</p> <p>*All fields are optional</p> <p>For the most relevant specification see <code>org.jetbrains.kotlinx.jupyter.libraries.LibraryDescriptor</code> class.</p> <p>Name of the file should have the <code>&lt;name&gt;.json</code> format where <code>&lt;name&gt;</code> is an argument for '%use' command</p> <p>Library properties can be used in any parts of library descriptor as <code>$property</code></p> <p>To register new library descriptor: 1. For private usage - create it anywhere on your computer and reference it using file syntax. 2. Alternative way for private usage - create descriptor in <code>.jupyter_kotlin/libraries</code> folder and reference    it using \"default\" syntax 3. For sharing with community - commit it to libraries repository and create pull request.</p> <p>If you are maintaining some library and want to update your library descriptor, create pull request with your update. After your request is accepted, new version of your library will be available to all Kotlin Jupyter users immediately on next kernel startup (no kernel update is needed) - but only if they use <code>%useLatestDescriptors</code> magic. If not, kernel update is needed.</p>"},{"location":"kotlin-jupyter/docs/libraries/#integration-using-kotlin-api","title":"Integration using Kotlin API","text":"<p>You may also add a Kotlin kernel integration to your library using a Gradle plugin.</p> <p>In the following code snippets <code>&lt;jupyterApiVersion&gt;</code> is one of the published versions from the link above. It is encouraged to use the latest stable version.</p> <p>First, add the plugin dependency into your buildscript.</p> <p>For <code>build.gradle</code>: <pre><code>plugins {\n    id \"org.jetbrains.kotlin.jupyter.api\" version \"&lt;jupyterApiVersion&gt;\"\n}\n</code></pre></p> <p>For <code>build.gradle.kts</code>: <pre><code>plugins {\n    kotlin(\"jupyter.api\") version \"&lt;jupyterApiVersion&gt;\"\n}\n</code></pre></p> <p>This plugin adds following dependencies to your project:</p> Artifact Gradle option to exclude/include Enabled by default Dependency scope Method for adding dependency manually <code>kotlin-jupyter-api</code> <code>kotlin.jupyter.add.api</code> yes <code>compileOnly</code> <code>addApiDependency(version: String?)</code> <code>kotlin-jupyter-api-annotations</code> <code>kotlin.jupyter.add.scanner</code> no <code>compileOnly</code> <code>addScannerDependency(version: String?)</code> <code>kotlin-jupyter-test-kit</code> <code>kotlin.jupyter.add.testkit</code> yes <code>testImplementation</code> <code>addTestKitDependency(version: String?)</code> <p>You may turn on / turn off the dependency with its default version (version of the plugin) by setting corresponding Gradle option to <code>true</code> or <code>false</code>. If the corresponding option is set to <code>false</code> (by default or in your setup), you still can add it manually using the method from the table inside <code>kotlinJupyter</code> extension like that:</p> <pre><code>kotlinJupyter {\n    addApiDependency() // Use default version\n    addApiDependency(\"0.10.0.1\") // Use custom artifact version\n}\n</code></pre>"},{"location":"kotlin-jupyter/docs/libraries/#adding-library-integration-using-ksp-plugin","title":"Adding library integration using KSP plugin","text":"<p>If you are OK with using KSP, you can use annotations to mark integration classes.</p> <p>First, enable <code>kotlin-jupyter-api-annotations</code> dependency by adding following line to your <code>gradle.properties</code>:</p> <pre><code>kotlin.jupyter.add.scanner = true\n</code></pre> <p>Then, implement <code>org.jetbrains.kotlinx.jupyter.api.libraries.LibraryDefinitionProducer</code> or <code>org.jetbrains.kotlinx.jupyter.api.libraries.LibraryDefinition</code> and mark implementation with <code>JupyterLibrary</code> annotation:</p> <pre><code>package org.my.lib\nimport org.jetbrains.kotlinx.jupyter.api.annotations.JupyterLibrary\nimport org.jetbrains.kotlinx.jupyter.api.*\nimport org.jetbrains.kotlinx.jupyter.api.libraries.*\n\n@JupyterLibrary\ninternal class Integration : JupyterIntegration() {\n\n    override fun Builder.onLoaded() {\n        render&lt;MyClass&gt; { HTML(it.toHTML()) }\n        import(\"org.my.lib.*\")\n        import(\"org.my.lib.io.*\")\n    }\n}\n</code></pre> <p>For more complicated example see integration of dataframe library.</p> <p>For a further information see docs for: - <code>org.jetbrains.kotlinx.jupyter.api.libraries.JupyterIntegration</code> - <code>org.jetbrains.kotlinx.jupyter.api.libraries.LibraryDefinitionProducer</code> - <code>org.jetbrains.kotlinx.jupyter.api.libraries.LibraryDefinition</code></p>"},{"location":"kotlin-jupyter/docs/libraries/#adding-library-integration-avoiding-use-of-annotation-processor","title":"Adding library integration avoiding use of annotation processor","text":"<p>You may want not to use KSP plugin for implementations detection. Then you may refer your implementations right in your buildscript. Note that no checking for existence will be performed in this case.</p> <p>The following example shows how to refer aforementioned <code>Integration</code> class in your buildscript. Obviously, in this case you shouldn't mark it with <code>JupyterLibrary</code> annotation.</p> <p>For <code>build.gradle</code>: <pre><code>processJupyterApiResources {\n    libraryProducers = [\"org.my.lib.Integration\"]\n}\n</code></pre></p> <p>For <code>build.gradle.kts</code>: <pre><code>tasks.processJupyterApiResources {\n    libraryProducers = listOf(\"org.my.lib.Integration\")\n}\n</code></pre></p>"},{"location":"kotlin-jupyter/docs/libraries/#integration-testing-for-the-integration-logic","title":"Integration testing for the integration logic","text":"<p>You may want to automatically check if your library integrates correctly into kernel. To achieve this, inherit your test class from <code>org.jetbrains.kotlinx.jupyter.testkit.JupyterReplTestCase</code> and use its methods to execute cells. Your library integration descriptors should be already on classpath and will be loaded automatically by the test logic, you don't need to use <code>%use</code> magic or <code>DependsOn</code> annotation to switch on your library. But you may use magics and annotations for other purposes, as usual.</p> <p>The artifact containing test templates is included automatically into <code>testImplementation</code> configuration if you use the Gradle plugin. You may turn this behavior off by setting <code>kotlin.jupyter.add.testkit</code> Gradle property to <code>false</code>. If you want to include this artifact into your build manually, you'll find the instructions here.</p> <p>For the examples of integration testing see <code>org.jetbrains.kotlinx.jupyter.testkit.test.JupyterReplTestingTest</code> in this repository or related tests in DataFrame.</p>"},{"location":"kotlin-jupyter/docs/libraries/#integration-using-other-build-systems","title":"Integration using other build systems","text":"<p>If you don't use Gradle as a build system, there is an alternative way.</p> <p>First, add <code>org.jetbrains.kotlinx:kotlin-jupyter-api:&lt;jupyterApiVersion&gt;</code> as a compile dependency. See configuration instructions for different build systems here</p> <p>Then add one or more integration classes. They may be derived from <code>LibraryDefinitionProducer</code> or from <code>LibraryDefinition</code> as described above. Note that you don't need <code>@JupyterLibrary</code> annotation in this scenario.</p> <p>Finally, add file <code>META-INF/kotlin-jupyter-libraries/libraries.json</code> to the JAR resources. This file should contain FQNs of all integration classes in the JSON form: <pre><code>{\n  \"definitions\":[],\n  \"producers\": [\n    { \"fqn\" : \"org.jetbrains.kotlinx.jupyter.example.GettingStartedIntegration\" }\n  ]\n}\n</code></pre> Classes derived from <code>LibraryDefinition</code> should be added to the <code>definitions</code> array. Classes derived from <code>LibraryDefinitionProducer</code> should be added to the <code>producers</code> array.</p>"},{"location":"kotlin-jupyter/docs/magics/","title":"Line magics","text":"<p>The following line magics are supported:  - <code>%use &lt;lib1&gt;, &lt;lib2&gt; ...</code> - injects code for supported libraries: artifact resolution, default imports, initialization code, type renderers  - <code>%trackClasspath</code> - logs any changes of current classpath. Useful for debugging artifact resolution failures  - <code>%trackExecution</code> - logs pieces of code that are going to be executed. Useful for debugging of libraries support  - <code>%useLatestDescriptors</code> - use latest versions of library descriptors available. By default, bundled descriptors are used. Note that default behavior is preferred: latest descriptors versions might be not supported by current version of kernel. So if you care about stability of the notebook, avoid using this line magic  - <code>%output [--max-cell-size=N] [--max-buffer=N] [--max-buffer-newline=N] [--max-time=N] [--no-stdout] [--reset-to-defaults]</code> -   output capturing settings.      - <code>max-cell-size</code> specifies the characters count which may be printed to stdout. Default is 100000.      - <code>max-buffer</code> - max characters count stored in internal buffer before being sent to client. Default is 10000.      - <code>max-buffer-newline</code> - same as above, but trigger happens only if newline character was encountered. Default is 100.      - <code>max-time</code> - max time in milliseconds before the buffer is sent to client. Default is 100.      - <code>no-stdout</code> - don't capture output. Default is false.      - <code>reset-to-defaults</code> - reset all output settings that were set with magics to defaults</p>"},{"location":"multik/","title":"multik","text":""},{"location":"multik/#multik","title":"Multik","text":"<p>Multidimensional array library for Kotlin.</p>"},{"location":"multik/#modules","title":"Modules","text":"<ul> <li><code>multik-core</code> \u2014 contains ndarrays, methods called on them and [math], [stat] and [linalg] interfaces.</li> <li><code>multik-default</code> \u2014 implementation including <code>multik-kotlin</code> and <code>multik-openblas</code> for performance.</li> <li><code>multik-kotlin</code> \u2014 implementation of [math], [stat] and [linalg] interfaces on JVM.</li> <li><code>multik-openblas</code> \u2014 implementation of [math], [stat] and [linalg] interfaces in native code using OpenBLAS.</li> </ul>"},{"location":"multik/#using-in-your-projects","title":"Using in your projects","text":""},{"location":"multik/#gradle","title":"Gradle","text":"<p>In your Gradle build script: 1. Add the Maven Central Repository. 2. Add the <code>org.jetbrains.kotlinx:multik-core:$multik_version</code> api dependency. 3. Add an implementation dependency: <code>org.jetbrains.kotlinx:multik-default:$multik_version</code>, <code>org.jetbrains.kotlinx:multik-kotlin:$multik_version</code> or <code>org.jetbrains.kotlinx:multik-openblas:$multik_version</code>.</p> <p><code>build.gradle</code>: <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation \"org.jetbrains.kotlinx:multik-core:0.2.2\"\n    implementation \"org.jetbrains.kotlinx:multik-default:0.2.2\"\n}\n</code></pre></p> <p><code>build.gradle.kts</code>: <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"org.jetbrains.kotlinx:multik-core:0.2.2\")\n    implementation(\"org.jetbrains.kotlinx:multik-default:0.2.2\")\n}\n</code></pre></p> <p>For a multiplatform project, set the dependency in a common block:</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlinx:multik-core:0.2.2\")\n            }\n        }\n    }\n}\n</code></pre> <p>or in a platform-specific block:</p> <pre><code>kotlin {\n    sourceSets {\n        val jvmName by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlinx:multik-core-jvm:0.2.2\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"multik/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>Install Kotlin kernel for Jupyter or just visit to Datalore.</p> <p>Import stable <code>multik</code> version into notebook: <pre><code>%use multik\n</code></pre></p>"},{"location":"multik/#support-platforms","title":"Support platforms","text":"Platforms <code>multik-core</code> <code>multik-kotlin</code> <code>multik-openblas</code> <code>multik-default</code> JS linuxX64 mingwX64 macosX64 macosArm64 iosArm64 iosX64 iosSimulatorArm64 JVM linuxX64 - mingwX64 - macosX64 - macosArm64 - androidArm64 -  androidArm32 - androidX86 - androidX64 -  <p>For Kotlin/JS, we use the new IR. We also use the new memory model in Kotlin/Native. Keep this in mind when using Multik in your multiplatform projects.</p> <p>Note: * on ubuntu 18.04 and older <code>multik-openblas</code> doesn't work due to older versions of glibc. * <code>multik-openblas</code> for desktop targets (linuxX64, mingwX64, macosX64, macosArm64) is experimental and unstable. We will improve stability and perfomance as Kotlin/Native evolves. * JVM target <code>multik-openblas</code> for Android only supports arm64-v8a processors.</p>"},{"location":"multik/#quickstart","title":"Quickstart","text":"<p>Visit Multik documentation for a detailed feature overview.</p>"},{"location":"multik/#creating-arrays","title":"Creating arrays","text":"<pre><code>val a = mk.ndarray(mk[1, 2, 3])\n/* [1, 2, 3] */\n\nval b = mk.ndarray(mk[mk[1.5, 2.1, 3.0], mk[4.0, 5.0, 6.0]])\n/*\n[[1.5, 2.1, 3.0],\n[4.0, 5.0, 6.0]]\n*/\n\nval c = mk.ndarray(mk[mk[mk[1.5f, 2f, 3f], mk[4f, 5f, 6f]], mk[mk[3f, 2f, 1f], mk[4f, 5f, 6f]]])\n/*\n[[[1.5, 2.0, 3.0],\n[4.0, 5.0, 6.0]],\n\n[[3.0, 2.0, 1.0],\n[4.0, 5.0, 6.0]]]\n*/\n\n\nmk.zeros&lt;Double&gt;(3, 4) // create an array of zeros\n/*\n[[0.0, 0.0, 0.0, 0.0],\n[0.0, 0.0, 0.0, 0.0],\n[0.0, 0.0, 0.0, 0.0]]\n*/\nmk.ndarray&lt;Float, D2&gt;(setOf(30f, 2f, 13f, 12f), intArrayOf(2, 2)) // create an array from a collection\n/*\n[[30.0, 2.0],\n[13.0, 12.0]]\n*/\nval d = mk.ndarray(doubleArrayOf(1.0, 1.3, 3.0, 4.0, 9.5, 5.0), 2, 3) // create an array of shape(2, 3) from a primitive array\n/*\n[[1.0, 1.3, 3.0],\n[4.0, 9.5, 5.0]]\n*/\nmk.d3array(2, 2, 3) { it * it } // create an array of 3 dimension\n/*\n[[[0, 1, 4],\n[9, 16, 25]],\n\n[[36, 49, 64],\n[81, 100, 121]]]\n*/\n\nmk.d2arrayIndices(3, 3) { i, j -&gt; ComplexFloat(i, j) }\n/*\n[[0.0+(0.0)i, 0.0+(1.0)i, 0.0+(2.0)i],\n[1.0+(0.0)i, 1.0+(1.0)i, 1.0+(2.0)i],\n[2.0+(0.0)i, 2.0+(1.0)i, 2.0+(2.0)i]]\n */\n\nmk.arange&lt;Long&gt;(10, 25, 5) // creare an array with elements in the interval [10, 25) with step 5\n/* [10, 15, 20] */\n\nmk.linspace&lt;Double&gt;(0, 2, 9) // create an array of 9 elements in the interval [0, 2]\n/* [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0] */\n\nval e = mk.identity&lt;Double&gt;(3) // create an identity array of shape (3, 3)\n/*\n[[1.0, 0.0, 0.0],\n[0.0, 1.0, 0.0],\n[0.0, 0.0, 1.0]]\n*/\n</code></pre>"},{"location":"multik/#array-properties","title":"Array properties","text":"<pre><code>a.shape // Array dimensions\na.size // Size of array\na.dim // object Dimension\na.dim.d // number of array dimensions\na.dtype // Data type of array elements\n</code></pre>"},{"location":"multik/#arithmetic-operations","title":"Arithmetic operations","text":"<pre><code>val f = b - d // subtraction\n/*\n[[0.5, 0.8, 0.0],\n[0.0, -4.5, 1.0]]\n*/\n\nd + f // addition\n/*\n[[1.5, 2.1, 3.0],\n[4.0, 5.0, 6.0]]\n*/\n\nb / d // division\n/*\n[[1.5, 1.6153846153846154, 1.0],\n[1.0, 0.5263157894736842, 1.2]]\n*/\n\nf * d // multiplication\n/*\n[[0.5, 1.04, 0.0],\n[0.0, -42.75, 5.0]]\n*/\n</code></pre>"},{"location":"multik/#array-mathematics","title":"Array mathematics","text":"<p>See documentation for other methods of mathematics, linear algebra, statistics.</p> <pre><code>a.sin() // element-wise sin, equivalent to mk.math.sin(a)\na.cos() // element-wise cos, equivalent to mk.math.cos(a)\nb.log() // element-wise natural logarithm, equivalent to mk.math.log(b)\nb.exp() // element-wise exp, equivalent to mk.math.exp(b)\nd dot e // dot product, equivalent to mk.linalg.dot(d, e)\n</code></pre>"},{"location":"multik/#aggregate-functions","title":"Aggregate functions","text":"<pre><code>mk.math.sum(c) // array-wise sum\nmk.math.min(c) // array-wise minimum elements\nmk.math.maxD3(c, axis=0) // maximum value of an array along axis 0\nmk.math.cumSum(b, axis=1) // cumulative sum of the elements\nmk.stat.mean(a) // mean\nmk.stat.median(b) // meadian\n</code></pre>"},{"location":"multik/#copying-arrays","title":"Copying arrays","text":"<pre><code>val f = a.copy() // create a copy of the array and its data\nval h = b.deepCopy() // create a copy of the array and copy the meaningful data\n</code></pre>"},{"location":"multik/#operations-of-iterable","title":"Operations of Iterable","text":"<pre><code>c.filter { it &lt; 3 } // select all elements less than 3\nb.map { (it * it).toInt() } // return squares\nc.groupNDArrayBy { it % 2 } // group elements by condition\nc.sorted() // sort elements\n</code></pre>"},{"location":"multik/#indexingslicingiterating","title":"Indexing/Slicing/Iterating","text":"<pre><code>a[2] // select the element at the 2 index\nb[1, 2] // select the element at row 1 column 2\nb[1] // select row 1 \nb[0..2, 1] // select elements at rows 0 and 1 in column 1\nb[0..1..1] // select all elements at row 0\n\nfor (el in b) {\n    print(\"$el, \") // 1.5, 2.1, 3.0, 4.0, 5.0, 6.0, \n}\n\n// for n-dimensional\nval q = b.asDNArray()\nfor (index in q.multiIndices) {\n    print(\"${q[index]}, \") // 1.5, 2.1, 3.0, 4.0, 5.0, 6.0, \n}\n</code></pre>"},{"location":"multik/#inplace","title":"Inplace","text":"<pre><code>val a = mk.linspace&lt;Float&gt;(0, 1, 10)\n/*\na = [0.0, 0.1111111111111111, 0.2222222222222222, 0.3333333333333333, 0.4444444444444444, 0.5555555555555556, \n0.6666666666666666, 0.7777777777777777, 0.8888888888888888, 1.0]\n*/\nval b = mk.linspace&lt;Float&gt;(8, 9, 10)\n/*\nb = [8.0, 8.11111111111111, 8.222222222222221, 8.333333333333334, 8.444444444444445, 8.555555555555555,\n8.666666666666666, 8.777777777777779, 8.88888888888889, 9.0]\n*/\n\na.inplace { \n    math { \n        (this - b) * b\n         abs()\n    }\n}\n// a = [64.0, 64.88888, 65.77778, 66.66666, 67.55556, 68.44444, 69.333336, 70.22222, 71.111115, 72.0]\n</code></pre>"},{"location":"multik/#building","title":"Building","text":"<p>To build the entire project, you need to set up an environment for building <code>multik-openblas</code>: * JDK 1.8 or higher * JAVA_HOME environment - to search for jni files * Compilers gcc, g++, gfortran version 8 or higher. It is important that they are of the same version.</p> <p>Run <code>./gradlew assemble</code> to build all modules. If you don't need to build <code>multik-openblas</code>, just disable the <code>cmake_build</code> task and build the module you need.</p>"},{"location":"multik/#contributing","title":"Contributing","text":"<p>There is an opportunity to contribute to the project: 1. Implement math, linalg, stat interfaces. 2. Create your own engine successor from Engine, for example - JvmEngine. 3. Use mk.addEngine and mk.setEngine to use your implementation.</p>"},{"location":"londogard-nlp-toolkit/","title":"londogard-nlp-toolkit","text":""},{"location":"londogard-nlp-toolkit/#londogard-nlp-toolkit","title":"londogard-nlp-toolkit","text":"<p>Londogard Natural Language Processing Toolkit written in Kotlin for the JVM. This toolkit will be used throughout Londogard libraries/products such as our Summarizer, Text-Generation &amp; more.</p> <p>The <code>LanguageSupport</code> enum is used to determine what support different tools like Embeddings or Stopwords have out-of-the-box.</p> Tool Info Docs Samples (Kotlin Notebook) Word Embeddings Word &amp; Subword Embeddings available in 157 (fastText.cc) &amp; 275 languages (bpemb) out-of-the-box. embeddings wordembeddings.ipynb Sentence Embeddings Average &amp; Unsupervised Random Walk Sentence Embeddings sentence-embeddings sentence-embeddings.ipynb Stopwords Supports 23 languages out-of-the-box through NLTK's list of stopword stopwords stopwords.ipynb Word Frequencies Supports 34 languages out-of-the-box through LuminosoInsight word frequency tables wordfrequency wordfreq.ipynb Stemming Supports 14 languages out-of-the-box using Snowball Stemmer under the hood stemming stemmer.ipynb Tokenizers Char, Word, Subword &amp; Sentence Tokenizer support! SentencePiece? HuggingFace? It's there! - tokenizers- sentence-tokenizers tokenizer.ipynb Vectorizers &amp; Encoders BagOfWords, TF-IDF, BM25 &amp; OneHot - vectorizers (TF-IDF, BM-25,..)- count-vectorizers (Count, Hash, ..)encoders (OneHot)- transforms (TF-IDF, BM-25,..) TODO Keyword Extractions CooccurenceKeywords based on algorithm proposed in DOI:10.1142/S0218213004001466 keywords.ipynb Machine Learning LogisticRegression Classifier (using Gradient Descent), Na\u00efveBayes (binary) &amp; Hidden Markov Model (HMM) as Sequence Classifier - classifiers (LogisticRegression, Na\u00efveBayes)regression (LinearRegression)- sequence classifier (HiddenMarkovModel) See e2e-examples Deep Learning (Transformers / HuggingFace) <code>ClassifierPipeline</code> and <code>TokenClassifierPipeline</code> which supports HuggingFace ONNX model-names &amp; PyTorch from local files transformers See e2e-examples spaCy-like API \ud83d\udea7WIP\ud83d\udea7"},{"location":"londogard-nlp-toolkit/#installation","title":"Installation","text":"<p>MavenCentral <pre><code>implementation(\"com.londogard:nlp:$version\")\n</code></pre></p>"},{"location":"londogard-nlp-toolkit/#guides","title":"Guides","text":"<p>Simple end-2-end guides available as notebooks via docs/samples.</p> <p>This includes: 1. IMDB Sentiment Analysis using Logistic Regression or Na\u00efve Bayes 2. IMDB Sentiment Analysis using HuggingFace Transformers, using <code>ClassifierPipeline.create(&lt;model-name&gt;)</code> 3. POS-Tagging using Hidden Markov Model 4. POS-Tagging using HuggingFace Transformers, using <code>TokenClassifierPipeline.create(&lt;model-name&gt;)</code></p> <p>&amp; potentially more.</p>"},{"location":"text-gen-kt/","title":"text-gen-kt","text":""},{"location":"text-gen-kt/#text-gen-kt","title":"text-gen-kt","text":"<p>Text Generation in Kotlin that's 'light' on resources. </p> <ul> <li>Pre-trained models (Shakespeare &amp; Cards Against Humanity)</li> <li>Easy-to-use API (training &amp; generating text)</li> <li>Customizable</li> </ul> <p>Possible to test on londogard.com </p>"},{"location":"text-gen-kt/#installation","title":"Installation","text":"Jitpack (the easiest)  Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above.  <pre>\nrepositories {\n  maven { url \"https://jitpack.io\" }\n}\ndependencies {\n  implementation 'com.londogard:text-gen-kt:$version'\n}        \n</pre> GitHub Packages  Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above.   The part with logging into github repository is how I understand that you need to login. If you know a better way please ping me in an issue.  <pre>\nrepositories {\n   maven {\n     url = uri(\"https://maven.pkg.github.com/londogard/smile-nlp-kt\")\n     credentials {\n         username = project.findProperty(\"gpr.user\") ?: System.getenv(\"GH_USERNAME\")\n         password = project.findProperty(\"gpr.key\") ?: System.getenv(\"GH_TOKEN\")\n     }\n}\n}\ndependencies {\n   implementation \"com.londogard:text-gen-kt:$version\"\n}   \n</pre>"},{"location":"text-gen-kt/#usage","title":"Usage","text":"<p>Only the simplest API-usages shown with no overrides. It should be straight-forward to override  different options.  </p> <p>Loading a Pretrained Model and Text Generation Find a few pre-trained models here. Includes Shakespeare, Cards Against Humanity (Black &amp; White Card versions). <pre><code>// Have a pretrained model locally, in say 'shakespeare.cbor'\nval absPathToModel = \"/path/to/shakespeare.cbor\"\nval languageModel = LanguageModel.loadPretrainedModel(absPathToModel)\n\n// There exists a lot configs to change if you'd like, but this is the simplest text generation.\nval generatedSentences: List&lt;String&gt; = SimpleTextGeneration.generateText(languageModel = languageModel)\ngeneratedSentences.foreach(::println)\n\nSimpleTextGeneration\n    .generateText(languageModel, seed = \"This is who I am\")\n    .foreach(::println)\n\n// Prints the generated sentences. All which starts with \"This is who I am\"\n</code></pre></p> <p>Training your own Model <pre><code>// Have some text you wish to run on\nval documents: List&lt;String&gt; = listOf(File('somePath').readText)\n\n// n selects how much you want the model to remember. We use default tokenizer here.\nval trainedModel = LanguageModel.trainModel(documents, n=3)\ntrainModel.serialize(\"/path/to/model.cbor\")\n\nval generatedSentences: List&lt;String&gt; = SimpleTextGeneration.generateText(languageModel = trainedModel)\ngeneratedSentences.foreach(::println)\n</code></pre></p>"},{"location":"text-gen-kt/#steps-in-text-generation","title":"Steps in text-generation","text":"<p>Search calls smoothing to retrieve tokens &amp; probabilities.  Smoothing access the Language Model to retrieve probabilities, and if they don't  exist smooth it out somehow, meaning that you find the closest match. </p> <p>Smoothing example [\"hej\", \"d\u00e4r\", \"borta\"] has never been seen in the data, then we don't know what to generate as  the next word. Simple back-off smoothing would then try to see if [\"d\u00e4r\", \"borta\"] exists in the data and try  to generate a word from that instead. There's different  ways to smooth data, but in its essence it's the idea of finding a value of something we've never  seen before.</p> <p>Smoothing then applies penalties and finally normalization.</p>"},{"location":"text-gen-kt/#structure","title":"Structure","text":"<p>There's a few different components</p> <ol> <li>Language Model</li> <li>Tokenizer</li> <li>Normalization</li> <li>Smoothing</li> <li>Search</li> <li>Penalties</li> </ol> <p>The idea is that the Language Model is basically a storage of probabilities. To generate text we somehow need to tap into this 'database' and fetch values  in a interesting way. This is done using the tools in 2-6. This division is done in a fashion were we actually don't care if it's word-level  or character-level text generation (or anything else really). The trained Language Model  can simply be used to generate text in a lot of different fashions, with different penalties  and a lot other!</p>"},{"location":"text-gen-kt/#language-model","title":"Language Model","text":"<p>The Language Model is basically just a storage, with some clever structure. There's two ways to get a Language Model, either load a pretrained model through  a config-file or train it yourself on some text!</p>"},{"location":"text-gen-kt/#tokenizer","title":"Tokenizer","text":"<p>Tokenizer is a tool to tokenize text into tokens. A simple tokenizer could be either  tokenize characters, i.e. one character per token. Another could be to split words, e.g.  <code>tokenize(\"vem kan hitta min keps?\") = [\"vem\", \"kan\", \"hitta\", \"min\", \"keps\", \"?\"]</code>. Clever approaches sometimes split words like <code>kasper's</code> into <code>kasper &amp; 's</code>, which  reduces the dimensionality a bit.</p>"},{"location":"text-gen-kt/#normalization","title":"Normalization","text":"<p>When all probabilities are retrieved they need to be normalized to be in <code>[0,1)</code> (0-100 %). This can be done in different ways, the simplest being to just divide all by the sum.</p>"},{"location":"text-gen-kt/#smoothing","title":"Smoothing","text":"<p>Smoothing in this case is to retrieve probabilities. If the Language Model does not contain  a word we still need to generate text, how is this done? Smoothing says how the probabilities  and tokens should be found. A simple method is to \"backoff\", that is if we don't find something for <code>\"who is there\"</code> the  model can still have <code>\"is that\"</code>, which we then want to return.</p>"},{"location":"text-gen-kt/#search","title":"Search","text":"<p>Search is basically how we should select the tokens received by the Smoothing. A greedy search is to just select the top probability each time.</p>"},{"location":"text-gen-kt/#penalties","title":"Penalties","text":"<p>Penalty is simply a way to penalize certain features. E.g. swear words might be off-limit, we  might not want to generate the same ngram again? It's up to you!</p>"},{"location":"text-gen-kt/#available-models","title":"Available Models","text":"<ul> <li>shakespeare_char.cbor (n=100, keepMinFreq=5)</li> <li>shakespeare_word.cbor (n=100, keepMinFreq=1)</li> <li>cardsagainst_white_char.cbor (n=100, keepMinFreq=1)</li> <li>cardsagainst_white_word.cbor (n=100, keepMinFreq=1)</li> <li>cardsagainst_black_char.cbor (n=100, keepMinFreq=1)</li> <li>cardsagainst_black_word.cbor (n=100, keepMinFreq=1)</li> </ul>"},{"location":"summarize-kt/","title":"summarize-kt","text":""},{"location":"summarize-kt/#summarize-kt","title":"summarize-kt","text":"<p>Summarization library with an easy-to-use API (pre-loaded models). Currently only extractive summarisation is supported.</p> <p>The layout:</p> <ol> <li>Usage<ol> <li>Simple example</li> </ol> </li> <li>Configurations</li> <li>Installation<ol> <li>Jitpack (the simple way)</li> <li>Github Packages</li> </ol> </li> </ol> <p>Possible to test on londogard.com. </p>"},{"location":"summarize-kt/#usage","title":"Usage","text":"<p>There's an interface named <code>Summarizer</code> that allows us to select the method of summarization through its <code>companion object</code>. Two variants are available:</p> <p>1) <code>Summarizer.tfIdfSummarizer</code>  2) <code>Summarizer.embeddingClusterSummarizer(threshold: Double = 0.2, simThreshold: Double = 0.95, scoreConfig: ScoringConfig = ScoringConfig.Ghalandari)</code></p> <p>Where we have two different scoring configurations for <code>embeddingClusterSummarizer</code>. Read more in this section.  </p> <p><code>Summarizer</code> has two important methods: <pre><code>fun summarize(text: String, lines: Int): String\nfun summarize(text: String, ratio: Double): String\n</code></pre> Both methods returns the summary of the text, the first one returns X number of sentences and the second returns approximate % reduction of the document (0.3 returns ~30% of the article).</p>"},{"location":"summarize-kt/#example-where-wed-return-30-of-the-content","title":"Example where we'd return ~30% of the content","text":"<pre><code>val summarizer: Summarizer = Summarizer.tfIdfSummarizer\nval fullText = \"\"\"\n...Plenty of text...\n\"\"\"\nval summary = summarizer.summarize(fullText, ratio = 0.3)\n</code></pre>"},{"location":"summarize-kt/#explanation-of-the-different-configs","title":"Explanation of the different configs","text":"<p><code>Summarizer</code> currently support two different versions, either <code>TfIdf</code> or <code>EmbeddingCluster</code> where the latter has two different configs.  </p>"},{"location":"summarize-kt/#term-frequency-inverse-document-frequency-tfidf","title":"Term Frequency-Inverse Document Frequency (TFIDF)","text":"<p><code>TfIdf</code> uses TfIdf to find the most important sentences and then retrieves those back.</p>"},{"location":"summarize-kt/#embedding-cluster","title":"Embedding Cluster","text":"<p><code>EmbeddingCluster</code> combines both TfIdf &amp; Word-Embeddings. In its essence a centroid of the full document is created where we only allow words above a certain TfIdf score to be  contained in the centroid. The centroid is created using Word Embeddings, we pick the words above the threshold   aggregate all their embedding vectors and then normalize - this is the centroid.  When this is done we either</p> <ol> <li>Find all the sentences that are closest to this centroid (not including sentences   that are too similar to an already included sentence, using the <code>similarityThreshold</code>)</li> <li>The same as above but instead of comparing the sentence to the centroid we compare the centroid of the current  summary (with the new sentence added) to the centroid. That is, we now compare our new summary in total with the document  so that the sentences plays well together.  </li> </ol> <p>The approach is chosen by the <code>ScoringConfig</code> where the first approach is based on  Rossiello's work and the second is based on  Ghalandari's.</p> <p>In addition one can also set the TfIdf-threshold mentioned using the <code>threshold</code> and similarity-threshold  using <code>similarityThreshold</code>.</p> <p>OBS if you want to use custom embeddings you'll currently have to fork the project. The emeddings should download if you don't have them (OBS: this takes ~1gb download, then 157mb on HDD).</p>"},{"location":"summarize-kt/#installation","title":"Installation","text":"<p>The code is uploaded to two different repositories, both Jitpack.io and GitHub Packages.</p>"},{"location":"summarize-kt/#jitpack-easiest","title":"Jitpack (easiest)","text":"<p>Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above. <pre><code>   repositories {\n        maven { url \"https://jitpack.io\" }\n   }\n   dependencies {\n         implementation 'com.londogard:summarize-kt:$version'\n   }\n</code></pre></p>"},{"location":"summarize-kt/#github-packages","title":"GitHub Packages","text":"<p>Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above. The part with logging into github repository is how I understand that you need to login. If you know a better way please ping me in an issue. <pre><code>repositories {\n   maven {\n     url = uri(\"https://maven.pkg.github.com/londogard/summarize-kt\")\n     credentials {\n         username = project.findProperty(\"gpr.user\") ?: System.getenv(\"GH_USERNAME\")\n         password = project.findProperty(\"gpr.key\") ?: System.getenv(\"GH_TOKEN\")\n     }\n}\n}\ndependencies {\n   implementation \"com.londogard:summarize-kt:$version\"\n}\n</code></pre></p>"},{"location":"smile-nlp-kt/","title":"smile-nlp-kt","text":""},{"location":"smile-nlp-kt/#smile-nlp-kt","title":"smile-nlp-kt","text":"<p>Kotlin extensions / Interfaces that extends the Java/Scala implementation/implicits of Smile NLP. Basically a simplification for kotlin (&amp; probably Java) users.</p>"},{"location":"smile-nlp-kt/#installation","title":"Installation","text":"Jitpack (the easiest)  Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above.  <pre>\nrepositories {\n  maven { url \"https://jitpack.io\" }\n}\ndependencies {\n  implementation 'com.londogard:smile-nlp-kt:$version'\n}        \n</pre> GitHub Packages  Add the following to your <code>build.gradle</code>. <code>$version</code> should be equal to the version supplied by tag above.   The part with logging into github repository is how I understand that you need to login. If you know a better way please ping me in an issue.  <pre>\nrepositories {\n   maven {\n     url = uri(\"https://maven.pkg.github.com/londogard/smile-nlp-kt\")\n     credentials {\n         username = project.findProperty(\"gpr.user\") ?: System.getenv(\"GH_USERNAME\")\n         password = project.findProperty(\"gpr.key\") ?: System.getenv(\"GH_TOKEN\")\n     }\n}\n}\ndependencies {\n   implementation \"com.londogard:smile-nlp-kt:$version\"\n}   \n</pre> <p>Installing Smile Smile-NLP is required to be installed, you can find the artifact here (installable by gradle). As you can see in the gradle file this is used in conjunction with <code>2.2.2</code>currently, but should work with newer versions too.</p>"},{"location":"smile-nlp-kt/#usage","title":"Usage","text":"<p>I'll go through the usage of the components, copying the structure from the homepage of Smile. Please make sure to read the official documentation for more context, I've tried to extract a short piece of text for  each chapter but cut out a lot of text.</p>"},{"location":"smile-nlp-kt/#normalization","title":"Normalization","text":"<p>The function normalize is a simple normalizer for processing Unicode text:</p> <ul> <li>Apply Unicode normalization form NFKC.</li> <li>Strip, trim, normalize, and compress whitespace.</li> <li>Remove control and formatting characters.</li> <li>Normalize dash, double and single quotes.</li> </ul> <pre><code>import com.londogard.smile.extensions.*\n\nval unicode = \"\u201cWildlife strikes to aircraft pose a significant safety hazard and cost the aviation industry hundreds of millions of dollars each year,\u201d department spokeswoman Meadow Bailey told the Associated Press. \u201cBirds make up over 90 percent of strikes in the U.S., while mammal strikes are rare.\u201d\"\nval text = unicode.normalize()\n</code></pre>"},{"location":"smile-nlp-kt/#sentence-breaking","title":"Sentence Breaking","text":"<p>Smile implement an efficient rule-based sentence splitter for English.</p> <pre><code>val sentences = text.sentences()\n</code></pre>"},{"location":"smile-nlp-kt/#word-segmentation","title":"Word Segmentation","text":"<p>The method words(filter) assumes that an English text has already been segmented into sentences and splits a sentence into tokens. This method includes a filter where we remove stop-words. Please read official docs for more info.</p> <pre><code>sentences.flatMap { sentence -&gt; sentence.words() }\n</code></pre>"},{"location":"smile-nlp-kt/#stemming","title":"Stemming","text":"<p>Stemming is a crude heuristic process that chops off the ends of words in the hope of achieving this goal correctly most of the time, and often includes the removal of derivational affixes.</p> <pre><code>import com.londogard.smile.SmileSingleton\n\nSmileSingleton.porter(\"democratization\") // \"democrat\"\nSmileSingleton.lancaster(\"democratization\") // \"democr\"\n</code></pre>"},{"location":"smile-nlp-kt/#bag-of-words","title":"Bag of Words","text":"<p>The bag-of-words model is a simple representation of text as the bag of its words, disregarding grammar and word order but keeping multiplicity.</p> <p>The method bag(stemmer) returns the map of word to frequency. By default, the parameter stemmer use Porter's algorithm. Passing None to disable stemming. There is a similar function bag2(stemmer) that returns a binary bag of words (Set[String]). That is, presence/absence is used instead of frequencies.</p> <pre><code>text.bag() // Map[String, Int], e.g. mapOf(\"move\" -&gt; 1, \"90\" -&gt; 1, ...)\n</code></pre> <p>The function vectorize(features, bag) converts a bag of words to a feature vector. The parameter features is the token list used as features in machine learning models. Generally it is not a good practice to use all tokens in the corpus as features.</p> <p>To use these functions we need to extend the interface <code>SmileOperators</code> found in <code>com.londogard.smile</code>.</p> <pre><code>val lines = File(\"data/...\").readLines()\nval corpus = lines.map(_.bag())\n\nval features = listOf(\"like\", \"good\", \"perform\", \"littl\", \"love\", \"bad\", \"best\")\nval bags = corpus.map { bag -&gt; vectorize(features, bag) }\nval data = tfidf(bags)\n</code></pre>"},{"location":"smile-nlp-kt/#phrase-collocation-extraction","title":"Phrase / Collocation Extraction","text":"<p>We got some other functions called bigram where we find bigrams.</p> <pre><code>bigram(10, 5, lines) // Array&lt;BigramCollocation&gt;((\"special effects\", 278, 3522.38), ...)\n</code></pre> <p>When we want more we can use the ngram function instead.</p> <pre><code>val phrase = ngram(4, 4, text)\nphrase[2] // returns all bigrams listOf((\"this\", \"is\"), (\"is\", \"a\"), ...)\nphrase[3] // returns all trigrams listOf((\"this\", \"is\", \"a\"), ...)\n</code></pre>"},{"location":"smile-nlp-kt/#keyword-extraction","title":"Keyword Extraction","text":"<p>Beyond finding phrases, keyword extraction is tasked with the automatic identification of terms that best describe the subject of a document, Keywords are the terms that represent the most relevant information contained in the document, i.e. characterization of the topic discussed in a document.</p> <p><pre><code>text.keywords(10) // returns a list of size 10, e.g. listOf(([storage, capacity], 11), ([machine], 197), ([think], 45),)\n</code></pre> This algorithm relies on co-occurrence probability and information theory. Therefore, the article should be long enough to contain sufficient statistical signals. In other words, it won't work on short text such as tweets.</p>"},{"location":"smile-nlp-kt/#part-of-speech-tagging","title":"Part-Of-Speech Tagging","text":"<p>A part of speech (PoS) is a category of words which have similar grammatical properties. Words that are assigned to the same part of speech generally display similar behavior in terms of syntax \u2013 they play similar roles within the grammatical structure of sentences \u2013 and sometimes in terms of morphology, in that they undergo inflection for similar properties.</p> <pre><code>val sentence = \"\"\"When airport foreman Scott Babcock went out onto the runway at Wiley Post-Will Rogers Memorial Airport in Utqiagvik, Alaska, on Monday to clear some snow, he was surprised to find a visitor waiting for him on the asphalt: a 450-pound bearded seal chilling in the milky sunshine.\"\"\"\nsentence.postag() // List&lt;Pair&lt;String, PennTreebankPOS&gt;&gt;, listOf(\"When\" to WRB, \"airport\" to NN, ...)\n</code></pre> <p>The rest of the methods supplied by Smile should be easy to use from Kotlin so they're not wrapped.</p> <p>Please read more in the official documentation.</p>"},{"location":"kotlingrad/","title":"Kotlin\u2207","text":""},{"location":"kotlingrad/#kotlin-type-safe-symbolic-differentiation-for-the-jvm","title":"Kotlin\u2207: Type-safe Symbolic Differentiation for the JVM","text":"<p>Kotlin\u2207 is a type-safe automatic differentiation framework written in Kotlin. It allows users to express differentiable programs with higher-dimensional data structures and operators. We attempt to restrict syntactically valid constructions to those which are algebraically valid and can be checked at compile-time. By enforcing these constraints in the type system, it eliminates certain classes of runtime errors that may occur during the execution of a differentiable program. Due to type-inference, most type declarations may be safely omitted by the end-user. Kotlin\u2207 strives to be expressive, safe, and notationally similar to mathematics.</p>"},{"location":"kotlingrad/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Supported features</li> <li>Usage</li> <li>Installation</li> <li>Notation</li> <li>Shape safety</li> <li>Higher-rank</li> <li>Higher-order</li> <li>Example</li> <li>Variable capture</li> <li>Visualization</li> <li>Dataflow graphs</li> <li>Plotting functions</li> <li>Loss curves</li> <li>Testing and gradient checking</li> <li>How does it work?</li> <li>Operator overloading</li> <li>First-class functions</li> <li>Multi-stage programming</li> <li>Extension functions</li> <li>Algebraic data types</li> <li>Multiple dispatch</li> <li>Shape-safe tensor operations</li> <li>Intermediate representation</li> <li>Property delegation</li> <li>Experimental ideas</li> <li>Church encoding</li> <li>Type classes</li> <li>Type arithmetic</li> <li>Formal grammar</li> <li>UML diagram</li> <li>Comparison to other frameworks</li> <li>References</li> <li>Acknowledgements</li> </ul>"},{"location":"kotlingrad/#introduction","title":"Introduction","text":"<p>Inspired by Stalin\u2207, Autograd, DiffSharp, Myia, Nexus, Tangent, Lantern et al., Kotlin\u2207 attempts to port recent advancements in automatic differentiation (AD) to the Kotlin language. AD is useful for gradient descent and has a variety of applications in numerical optimization and machine learning. Our implementation adds a number of experimental ideas, including compile-time shape-safety, algebraic simplification and numerical stability checking with property-based testing. We aim to provide an algebraically-grounded implementation of AD for shape-safe tensor operations. Tensors in Kotlin\u2207 are represented as multidimensional arrays.</p>"},{"location":"kotlingrad/#features","title":"Features","text":"<p>Kotlin\u2207 currently supports the following features:</p> <ul> <li>Arithmetical operations on scalars, vectors and matrices</li> <li>Shape-safe vector and matrix algebra</li> <li>Partial and higher-order differentiation on scalars</li> <li>Property-based testing for numerical gradient checking</li> <li>Recovery of symbolic derivatives from AD</li> </ul> <p>Additionally, it aims to support:</p> <ul> <li>PyTorch-style define-by-run semantics</li> <li>N-dimensional tensors and higher-order tensor operators</li> <li>Fully-general AD over control flow, variable reassignment (via delegation), and array programming, possibly using a typed IR such as Myia</li> </ul> <p>All of these features are implemented without access to bytecode or special compiler tricks - just using higher-order functions and lambdas as shown in Lambda the Ultimate Backpropogator, embedded DSLs a la Lightweight Modular Staging, and ordinary generics. Please see below for a more detailed feature comparison.</p>"},{"location":"kotlingrad/#usage","title":"Usage","text":""},{"location":"kotlingrad/#installation","title":"Installation","text":"<p>Kotlin\u2207 is hosted on Maven Central. An example project is provided here.</p>"},{"location":"kotlingrad/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n  implementation(\"ai.hypergraph:kotlingrad:0.4.7\")\n}\n</code></pre>"},{"location":"kotlingrad/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ai.hypergraph&lt;/groupId&gt;\n  &lt;artifactId&gt;kotlingrad&lt;/artifactId&gt;\n  &lt;version&gt;0.4.7&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"kotlingrad/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>To access Kotlin\u2207's notebook support, use the following line magic:</p> <pre><code>@file:DependsOn(\"ai.hypergraph:kotlingrad:0.4.7\")\n</code></pre> <p>For more information, explore the tutorial.</p>"},{"location":"kotlingrad/#notation","title":"Notation","text":"<p>Kotlin\u2207 operators are higher-order functions, which take at most two inputs and return a single output, all of which are functions with the same numerical type, and whose shape is denoted using superscript in the rightmost column below. </p> Math Infix <sup>\u2020</sup> Prefix Postfix<sup>\u2021</sup> Operator Type Signature \\(\\(\\mathbf{A}(\\mathbf{B})\\)\\)\\(\\(\\mathbf{A}\\circ\\mathbf{B}\\)\\) <code>a(b)</code><code>a of b</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{\u03c0}, \\texttt{b}: \u211d^{\u03bb} \u2192 \u211d^{\u03c4}) \u2192 (\u211d^{\u03bb}\u2192\u211d^{\u03c0})\\)\\) \\(\\(\\mathbf{A}\\pm\\mathbf{B}\\)\\) <code>a + b</code><code>a - b</code> <code>plus(a, b)</code><code>minus(a, b)</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{\u03c0}, \\texttt{b}: \u211d^{\u03bb} \u2192 \u211d^{\u03c0}) \u2192 (\u211d^{?}\u2192\u211d^{\u03c0})\\)\\) \\(\\(\\mathbf{A}\\mathbf{B}\\)\\) <code>a * b</code><code>a.times(b)</code> <code>times(a, b)</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7n}, \\texttt{b}: \u211d^{\u03bb}\u2192\u211d^{n\u00d7p}) \u2192 (\u211d^{?}\u2192\u211d^{m\u00d7p})\\)\\) \\(\\(\\frac{\\mathbf{A}}{\\mathbf{B}}\\)\\)\\(\\(\\mathbf{A}\\mathbf{B}^{-1}\\)\\) <code>a / b</code><code>a.div(b)</code> <code>div(a, b)</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7n}, \\texttt{b}: \u211d^{\u03bb}\u2192\u211d^{p\u00d7n}) \u2192 (\u211d^{?}\u2192\u211d^{m\u00d7p})\\)\\) \\(\\(\\pm\\mathbf{A}\\)\\) <code>-a</code><code>+a</code> <code>a.neg()</code><code>a.pos()</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{\u03c0}) \u2192 (\u211d^{\u03c4}\u2192\u211d^{\u03c0})\\)\\) \\(\\(\\sin{a}\\)\\)\\(\\(\\cos{a}\\)\\)\\(\\(\\tan{a}\\)\\) <code>sin(a)</code><code>cos(a)</code><code>tan(a)</code> <code>a.sin()</code><code>a.cos()</code><code>a.tan()</code> \\(\\((\\texttt{a}: \u211d\u2192\u211d) \u2192 (\u211d\u2192\u211d)\\)\\) \\(\\(\\ln{a}\\)\\) <code>ln(a)</code><code>log(a)</code> <code>a.ln()</code><code>a.log()</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7m}) \u2192 (\u211d^{\u03c4}\u2192\u211d^{m\u00d7m})\\)\\) \\(\\(\\log_{b}a\\)\\) <code>a.log(b)</code> <code>log(a, b)</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7m}, \\texttt{b}: \u211d^{\u03bb}\u2192\u211d^{m\u00d7m}) \u2192 (\u211d^{?}\u2192\u211d)\\)\\) \\(\\(\\mathbf{A}^b\\)\\) <code>a.pow(b)</code> <code>pow(a, b)</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7m}, \\texttt{b}: \u211d^{\u03bb}\u2192\u211d) \u2192 (\u211d^{?}\u2192\u211d^{m\u00d7m})\\)\\) \\(\\(\\sqrt{A}\\)\\)\\(\\(\\sqrt[3]{A}\\)\\) <code>a.pow(1.0/2)</code><code>a.root(3)</code> <code>sqrt(a)</code><code>cbrt(a)</code> <code>a.sqrt()</code><code>a.cbrt()</code> \\(\\((\\texttt{a}: \u211d^{\u03c4}\u2192\u211d^{m\u00d7m}) \u2192 (\u211d^{\u03c4}\u2192\u211d^{m\u00d7m})\\)\\) \\(\\(\\frac{da}{db},\\frac{\\partial{a}}{\\partial{b}}\\)\\) \\(\\(D_b{a}\\)\\) <code>a.d(b)</code><code>d(a) / d(b)</code> <code>grad(a)[b]</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d)^{*}, \\texttt{b}: C(\u211d^{\u03bb}\u2192\u211d)) \u2192 (\u211d^{?}\u2192\u211d)\\)\\) \\(\\(\\nabla{a}\\)\\) <code>grad(a)</code> <code>a.grad()</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d)) \u2192 (\u211d^{\u03c4}\u2192\u211d^{\u03c4})\\)\\) \\(\\(\\nabla_{\\mathbf{B}}a\\)\\) <code>a.d(b)</code><code>a.grad(b)</code> <code>grad(a, b)</code><code>grad(a)[b]</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d^{\u03c0}), \\texttt{b}: C(\u211d^{\u03bb}\u2192\u211d^{\u03c9})) \u2192 (\u211d^{?}\u2192\u211d^{\u03c0\u00d7\u03c9})\\)\\) \\(\\(\\nabla\\cdot{\\mathbf{A}}\\)\\) <code>divg(a)</code> <code>a.divg()</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d^{m})) \u2192 (\u211d^{\u03c4}\u2192\u211d)\\)\\) \\(\\(\\nabla\\times{\\mathbf{A}}\\)\\) <code>curl(a)</code> <code>a.curl()</code> \\(\\((\\texttt{a}: C(\u211d^{3}\u2192\u211d^{3})) \u2192 (\u211d^{3}\u2192\u211d^{3})\\)\\) \\(\\(\\mathcal{J}(\\mathbf{A})\\)\\) <code>grad(a)</code> <code>a.grad()</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d^{m})) \u2192 (\u211d^{\u03c4}\u2192\u211d^{m\u00d7\u03c4})\\)\\) \\(\\(\\mathbf{H}(a)\\)\\) <code>hess(a)</code> <code>a.hess()</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d)) \u2192 (\u211d^{\u03c4}\u2192\u211d^{\u03c4\u00d7\u03c4})\\)\\) \\(\\(\\Delta{a},\\nabla^{2}a\\)\\) <code>lapl(a)</code> <code>a.lapl()</code> \\(\\((\\texttt{a}: C(\u211d^{\u03c4}\u2192\u211d)) \u2192 (\u211d^{\u03c4}\u2192\u211d^{\u03c4})\\)\\) <p>\u211d can be a <code>Double</code>, <code>Float</code> or <code>BigDecimal</code>. Specialized operators are defined for subsets of \u211d, e.g., <code>Int</code>, <code>Short</code> or <code>BigInteger</code> for subsets of \u2124, however differentiation is only defined for continuously differentiable functions on \u211d.</p> <p><sup>\u2020</sup> <code>a</code> and <code>b</code> are higher-order functions. These may be constants (e.g., <code>0</code>, <code>1.0</code>), variables (e.g., <code>Var()</code>) or expressions (e.g., <code>x + 1</code>, <code>2 * x + y</code>).</p> <p><sup>\u2021</sup> For infix notation, <code>.</code> is optional. Parentheses are also optional depending on precedence.</p> <p><sup>\u00a7</sup> Matrix division is defined iff B is invertible, although it could be possible to redefine this operator using the Moore-Penrose inverse.</p> <p><sup>\u2217</sup> Where C(\u211d<sup>m</sup>) is the space of all continuous functions over \u211d. If the function is not over \u211d, it will fail at compile-time. If the function is over \u211d but not continuous differentiable at the point under consideration, it will fail at runtime.</p> <p><sup>?</sup> The input shape is tracked at runtime, but not at the type level. While it would be nice to infer a union type bound over the inputs of binary functions, it is likely impossible using the Kotlin type system without great effort. If the user desires type checking when invoking higher order functions with literal values, they will need to specify the combined input type explicitly or do so at runtime.</p> <p><sup>\u03c4, \u03bb, \u03c0, \u03c9</sup> Arbitrary products.</p>"},{"location":"kotlingrad/#higher-rank-derivatives","title":"Higher-Rank Derivatives","text":"<p>Kotlin\u2207 supports derivatives between tensors of up to rank 2. The shape of a tensor derivative depends on (1) the shape of the function under differentiation and (2) the shape of the variable with respect to which we are differentiating.</p> I/O Shape \\(\\(\u211d^{?}\u2192\u211d\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{m}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{j\u00d7k}\\)\\) \\(\\(\u211d^{?}\u2192\u211d\\)\\) \\(\\(\u211d^{?}\u2192\u211d\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{m}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{j\u00d7k}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{n}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{n}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{m\u00d7n}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{h\u00d7i}\\)\\) \\(\\(\u211d^{?}\u2192\u211d^{h\u00d7i}\\)\\) <p>Matrix-by-vector, vector-by-matrix, and matrix-by-matrix derivatives require rank 3+ tensors and are currently unsupported.</p>"},{"location":"kotlingrad/#higher-order-derivatives","title":"Higher-order derivatives","text":"<p>Kotlin\u2207 supports arbitrary order derivatives on scalar functions, and up to 2<sup>nd</sup> order derivatives on vector functions. Higher-order derivatives on matrix functions are unsupported.</p>"},{"location":"kotlingrad/#shape-safety","title":"Shape safety","text":"<p>Shape safety is an important concept in Kotlin\u2207. There are three broad strategies for handling shape errors:</p> <ul> <li>Hide the error somehow by implicitly reshaping or broadcasting arrays</li> <li>Announce the error at runtime, with a relevant message, e.g., <code>InvalidArgumentError</code></li> <li>Do not allow programs which can result in a shape error to compile</li> </ul> <p>In Kotlin\u2207, we use the last strategy to check the shape of tensor operations. Consider the following program:</p> <pre><code>// Inferred type: Vec&lt;Double, D2&gt;\nval a = Vec(1.0, 2.0)\n// Inferred type: Vec&lt;Double, D3&gt;\nval b = Vec(1.0, 2.0, 3.0)\n\nval c = b + b\n\n// Does not compile, shape mismatch\n// a + b\n</code></pre> <p>Attempting to sum two vectors whose shapes do not match will fail to compile, and they must be explicitly resized.</p> <pre><code>// Inferred type: Mat&lt;Double, D1, D4&gt;\nval a = Mat1x4(1.0, 2.0, 3.0, 4.0)\n// Inferred type: Mat&lt;Double, D4, D1&gt;\nval b = Mat4x1(1.0, 2.0, 3.0, 4.0)\n\nval c = a * b\n\n// Does not compile, inner dimension mismatch\n// a * a\n// b * b\n</code></pre> <p>Similarly, attempting to multiply two matrices whose inner dimensions do not match will fail to compile.</p> <pre><code>val a = Mat2x4( \n  1.0, 2.0, 3.0, 4.0,\n  5.0, 6.0, 7.0, 8.0\n)\n\nval b = Mat4x2( \n  1.0, 2.0,\n  3.0, 4.0,\n  5.0, 6.0,\n  7.0, 8.0\n)\n\n// Types are optional, but encouraged\nval c: Mat&lt;Double, D2, D2&gt; = a * b \n\nval d = Mat2x1(1.0, 2.0)\n\nval e = c * d\n\nval f = Mat3x1(1.0, 2.0, 3.0)\n\n// Does not compile, inner dimension mismatch\n// e * f\n</code></pre> <p>Explicit types are optional but encouraged. Type inference helps preserve shape information over long programs.</p> <pre><code>fun someMatFun(m: Mat&lt;Double, D3, D1&gt;): Mat&lt;Double, D3, D3&gt; = ...\nfun someMatFun(m: Mat&lt;Double, D2, D2&gt;) = ...\n</code></pre> <p>When writing a function, it is mandatory to declare the input type(s), but the return type may be omitted. Shape-safety is currently supported up to rank-2 tensors, i.e. matrices.</p>"},{"location":"kotlingrad/#example","title":"Example","text":"<p>The following example shows how to derive higher-order partials of a function <code>z</code> of type \u211d\u00b2\u2192\u211d:</p> <pre><code>val z = x * (-sin(x * y) + y) * 4  // Infix notation\nval `\u2202z\u2215\u2202x` = d(z) / d(x)          // Leibniz notation [Christianson, 2012]\nval `\u2202z\u2215\u2202y` = d(z) / d(y)          // Partial derivatives\nval `\u2202\u00b2z\u2215\u2202x\u00b2` = d(`\u2202z\u2215\u2202x`) / d(x)  // Higher-order derivatives\nval `\u2202\u00b2z\u2215\u2202x\u2202y` = d(`\u2202z\u2215\u2202x`) / d(y) // Higher-order partials\nval `\u2207z` = z.grad()                // Gradient operator\n\nval values = arrayOf(x to 0, y to 1)\n\nprintln(\"z(x, y) \\t= $z\\n\" +\n  \"z(${values.map { it.second }.joinToString()}) \\t\\t= ${z(*values)}\\n\" +\n  \"\u2202z/\u2202x \\t\\t= $`\u2202z\u2215\u2202x` \\n\\t\\t= \" + `\u2202z\u2215\u2202x`(*values) + \"\\n\" +\n  \"\u2202z/\u2202y \\t\\t= $`\u2202z\u2215\u2202y` \\n\\t\\t= \" + `\u2202z\u2215\u2202y`(*values) + \"\\n\" +\n  \"\u2202\u00b2z/\u2202x\u00b2 \\t= $`\u2202z\u2215\u2202y` \\n\\t\\t= \" + `\u2202\u00b2z\u2215\u2202x\u00b2`(*values) + \"\\n\" +\n  \"\u2202\u00b2z/\u2202x\u2202y \\t= $`\u2202\u00b2z\u2215\u2202x\u2202y` \\n\\t\\t= \" + `\u2202\u00b2z\u2215\u2202x\u2202y`(*values) + \"\\n\" +\n  \"\u2207z \\t\\t= $`\u2207z` \\n\\t\\t= [${`\u2207z`[x]!!(*values)}, ${`\u2207z`[y]!!(*values)}]\u1d40\")\n</code></pre> <p>Any backticks and unicode characters above are simply for readability and have no effect on the behavior. Running this program via <code>./gradlew HelloKotlingrad</code> should produce the following output:</p> <pre><code>z(x, y)         = ((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)\nz(0, 1)         = 0.0\n\u2202z/\u2202x           = d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(x) \n                = 4.0\n\u2202z/\u2202y           = d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(y) \n                = 0.0\n\u2202\u00b2z/\u2202x\u00b2         = d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(y) \n                = 4.0\n\u2202\u00b2z/\u2202x\u2202y        = d(d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(x)) / d(y) \n                = 4.0\n\u2207z              = {y=d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(y), x=d(((x) * ((- (sin((x) * (y)))) + (y))) * (4.0)) / d(x)} \n                = [4.0, 0.0]\u1d40\n</code></pre>"},{"location":"kotlingrad/#variable-capture","title":"Variable capture","text":"<p>Not only does Kotlin\u2207's type system encode output shape, it is also capable of tracking free and bound variables, for order-independent name binding and partial application. Expressions inhabited by free variables are typed as functions until fully bound, at which time they return a concrete value. Consider the following example:</p> <pre><code>val q = X + Y * Z + Y + 0.0\nval p0 = q(X to 1.0, Y to 2.0, Z to 3.0) // Name binding\nval p1 = q(X to 1.0, Y to 1.0)(Z to 1.0) // Variadic currying\nval p3 = q(Z to 1.0)(X to 1.0, Y to 1.0) // Any order is possible\nval p4 = q(Z to 1.0)(X to 1.0)(Y to 1.0) // Proper currying\nval p5 = q(Z to 1.0)(X to 1.0) // Returns a partially applied function\nval p6 = (X + Z + 0)(Y to 1.0) // Does not compile\n</code></pre> <p>This feature is made possible by encoding a type-level Hasse diagram over a small set of predefined variable names, with skip-connections for variadic combination and partial application. Curious readers may glean further details by referring to the implementation and usage example.</p>"},{"location":"kotlingrad/#visualization-tools","title":"Visualization tools","text":"<p>Kotlin\u2207 provides various graphical tools that can be used for visual debugging.</p>"},{"location":"kotlingrad/#dataflow-graphs","title":"Dataflow graphs","text":"<p>Kotlin\u2207 functions are a type of directed acyclic graph, called dataflow graphs (DFGs). For example, running the expression <code>((1 + x * 2 - 3 + y + z / y).d(y).d(x) + z / y * 3 - 2).render()</code> will display the following DFG:</p> <p></p> <p>Red and blue edges indicate the right and left inputs to a binary operator, respectively. Consider the DFG for a batch of stochastic gradients on linear regression, which can be written in matrix form as :</p> <p></p> <p>Thetas represent the hidden parameters under differentiation and the constants are the batch inputs (X) and targets (Y). When all the free variables are bound to numerical values, the graph collapses into a single node, which can be unwrapped into a Kotlin <code>Number</code>.</p>"},{"location":"kotlingrad/#plotting","title":"Plotting","text":"<p>To generate the sample 2D plots below, run <code>./gradlew Plot2D</code>.</p> <p></p> <p></p> <p>Plotting is also possible in higher dimensions, for example in 3D via <code>./gradlew Plot3D</code>:</p> <p> </p>"},{"location":"kotlingrad/#loss-curves","title":"Loss curves","text":"<p>Gradient descent is one application for Kotlin\u2207. Below, is a typical loss curve of SGD on a multilayer perceptron:</p> <p></p> <p>To train the model, execute <code>./gradlew MLP</code> from within the parent directory.</p>"},{"location":"kotlingrad/#testing","title":"Testing","text":"<p>To run the tests, execute <code>../gradlew allTests</code> from the <code>core</code> directory.</p> <p>Kotlin\u2207 claims to eliminate certain runtime errors, but how do we know the proposed implementation is not incorrect? One method, borrowed from the Haskell community, is called property-based testing (PBT), closely related to metamorphic testing. Notable implementations include QuickCheck, Hypothesis and ScalaTest (ported to Kotlin in Kotest). PBT uses algebraic properties to verify the result of an operation by constructing semantically equivalent but syntactically distinct expressions, which should produce the same answer. Kotlin\u2207 uses two such equivalences to validate its AD implementation:</p> <ul> <li>Analytic differentiation: manually differentiate and compare the values returned on a subset of the domain with AD.</li> <li>Finite difference approximation: sample space of symbolic (differentiable) functions, comparing results of AD to FD.</li> </ul> <p>For example, consider the following test, which checks whether the analytical derivative and the automatic derivative, when evaluated at a given point, are equal to each other within the limits of numerical precision:</p> <pre><code>val x by Var()\nval y by Var()\n\nval z = y * (sin(x * y) - x)            // Function under test\nval `\u2202z\u2215\u2202x` = d(z) / d(x)               // Automatic derivative\nval manualDx = y * (cos(x * y) * y - 1) // Analytical derivative \n\n\"\u2202z/\u2202x should be y * (cos(x * y) * y - 1)\" {\n  NumericalGenerator.assertAll { \u1e8b, \u1e8f -&gt;\n    // Evaluate the results at a given seed\n    val autoEval = `\u2202z\u2215\u2202x`(x to \u1e8b, y to \u1e8f) \n    val manualEval = manualDx(x to \u1e8b, y to \u1e8f)\n    // Should pass iff \u0394(adEval, manualEval) &lt; \u0190\n    autoEval shouldBeApproximately manualEval\n  }\n}\n</code></pre> <p>PBT will search the input space for two numerical values <code>\u1e8b</code> and <code>\u1e8f</code>, which violate the specification, then \"shrink\" them to discover pass-fail boundary values. We can construct a similar test using finite differences:</p> <pre><code>\"d(sin x)/dx should be equal to (sin(x + dx) - sin(x)) / dx\" {\n  NumericalGenerator.assertAll { \u1e8b -&gt;\n    val f = sin(x)\n\n    val `df\u2215dx` = d(f) / d(x)\n    val adEval = `df\u2215dx`(\u1e8b) \n\n    val dx = 1E-8\n    // Since \u1e8b is a raw numeric type, sin =&gt; kotlin.math.sin\n    val fdEval = (sin(\u1e8b + dx) - sin(\u1e8b)) / dx\n    adEval shouldBeApproximately fdEval\n  }\n}\n</code></pre> <p></p> <p>Above, we compare numerical errors for three types of computational differentiation against infinite precision symbolic differentiation (IP):</p> <ol> <li>Finite precision automatic differentiation (AD)</li> <li>Finite precision symbolic differentiation (SD)</li> <li>Finite precision finite differences (FD)</li> </ol> <p>AD and SD both exhibit relative errors (i.e. with respect to each other) several orders of magnitude lower than their absolute errors (i.e. with respect to IP), which roughly agree to within numerical precision. As expected, FD exhibits numerical error significantly higher than AD and SD due to the inaccuracy of floating-point division.</p> <p>There are many other ways to independently verify the numerical gradient, such as dual numbers or the complex step derivative. Another method is to compare the numerical output against a well-known implementation, such as TensorFlow. We plan to conduct a more thorough comparison of numerical accuracy and performance.</p>"},{"location":"kotlingrad/#how","title":"How?","text":"<p>To understand the core of Kotlin\u2207's AD implementation, please refer to the scalar example.</p> <p>This project relies on a few Kotlin-specific language features, which together enable a concise, flexible and type-safe user interface. The following features have proven beneficial to the development of Kotlin\u2207:</p>"},{"location":"kotlingrad/#operator-overloading","title":"Operator overloading","text":"<p>Operator overloading enables concise notation for arithmetic on abstract types, where the types encode algebraic structures, e.g., <code>Group</code>, <code>Ring</code>, and <code>Field</code>. These abstractions are extensible to other kinds of mathematical structures, such as complex numbers and quaternions.</p> <p>For example, suppose we have an interface <code>Group</code>, which overloads the operators <code>+</code> and <code>*</code>, and is defined like so:</p> <pre><code>interface Group&lt;T: Group&lt;T&gt;&gt; {\n  operator fun plus(addend: T): T\n\n  operator fun times(multiplicand: T): T\n}\n</code></pre> <p>Here, we specify a recursive type bound using a method known as F-bounded quantification to ensure that operations return the concrete type variable <code>T</code>, rather than something more abstract like <code>Group</code>. Imagine a class <code>Fun</code> that has implemented <code>Group</code>. It can be used as follows:</p> <pre><code>fun &lt;T: Group&lt;T&gt;&gt; cubed(t: T): T = t * t * t\n\nfun &lt;T: Group&lt;T&gt;&gt; twiceCubed(t: T): T = cubed(t) + cubed(t)\n</code></pre> <p>Like Python, Kotlin supports overloading a limited set of operators, which are evaluated using a fixed precedence. In the current version of Kotlin\u2207, operators do not perform any computation, they simply construct a directed acyclic graph representing the symbolic expression. Expressions are only evaluated when invoked as a function.</p>"},{"location":"kotlingrad/#first-class-functions","title":"First-class functions","text":"<p>With higher-order functions and lambdas, Kotlin treats functions as first-class citizens. This allows us to represent mathematical functions and programming functions with the same underlying abstractions (typed FP). Several recent papers have demonstrated the expressiveness of this paradigm for automatic differentiation.</p> <p>In Kotlin\u2207, all expressions can be treated as functions. For example:</p> <pre><code>fun &lt;T: Group&lt;T&gt;&gt; makePoly(x: Var&lt;T&gt;, y: Var&lt;T&gt;) = x * y + y * y + x * x\nval x by Var()\nval y by Var()\nval f = makePoly(x, y)\nval z = f(1.0, 2.0) // Returns a value\nprintln(z) // Prints: 7\n</code></pre> <p>Additionally, it is possible to build functions consisting of varying dimensional inputs:</p> <pre><code>fun &lt;T: Fun&lt;T&gt;&gt; mlp(p1: VFun&lt;T, D3&gt;, p2: MFun&lt;T, D3, D3&gt;, p3: T) =\n  ((p1 * p2 + p1 * p2 * p2 dot p1 + p1) - p3) pow p3\n</code></pre>"},{"location":"kotlingrad/#multi-stage-programming","title":"Multi-stage programming","text":"<p>Kotlin\u2207 uses operator overloading in the host language to first construct a dataflow graph, but evaluates the graph lazily. Called \"multi-stage programming\", or staging, this is a metaprogramming technique from the ML community which enables type-safe runtime code translation and compilation. More recently, staging has been put to effective use for compiling embedded DSLs similar to Kotlin\u2207.</p> <p>In its current form, Kotlin\u2207 takes a \"shallow embedding\" approach. Similar to an interpreter, it adheres closely to the user-defined program and does not perform much code specialization or rewriting for optimization purposes. Unlike an interpreter, it postpones evaluation until all free variables in an expression have been bound. Consider the following snippet, which decides when to evaluate an expression:</p> <pre><code>var EAGER = false\noperator fun invoke(newBindings: Bindings&lt;X&gt;): Fun&lt;X&gt; =\n    Composition(this, newBindings).run { if (bindings.complete || EAGER) evaluate() else this }\n</code></pre> <p>If <code>bindings</code> are <code>complete</code>, this means there are no unbound variables remaining (implementation omitted for brevity), and we can evaluate the expression to obtain a numerical result. Suppose we have the following user code:</p> <pre><code>val x = Var()\nval y = Var()\nval z = Var()\nval f0 = x + y * z\nvar f1 = f0(x to 1).also { println(it) } // Prints: (x + y * z)(x=1)\nvar f2 = f1(y to 2).also { println(it) } // Prints: (x + y * z)(x=1)(y=2)\nvar f3 = f2(z to 3).also { println(it) } // Prints: 7\n</code></pre> <p>Once the last line is reached, all variables are bound, and instead of returning a <code>Composition</code>, Kotlin\u2207 evaluates the function, returning a constant. Alternatively, if <code>EAGER</code> mode is enabled, each invocation is applied as early as possible:</p> <pre><code>EAGER = true\nf1 = f0(x to 1).also { println(it) } // Prints: 1 + y * z\nf2 = f1(y to 2).also { println(it) } // Prints: 1 + 2 * z\nf3 = f2(z to 3).also { println(it) } // Prints: 7\n</code></pre> <p>In the following section, we describe how evaluation works.</p>"},{"location":"kotlingrad/#algebraic-data-types","title":"Algebraic data types","text":"<p>Algebraic data types (ADTs) in the form of sealed classes (a.k.a. sum types) facilitate a limited form of pattern matching over a closed set of subclasses. By using these, the compiler forces us to provide an exhaustive control flow when type checking a sealed class. Consider the following classes:</p> <pre><code>class Const&lt;T: Fun&lt;T&gt;&gt;(val number: Number) : Fun&lt;T&gt;()\nclass Sum&lt;T: Fun&lt;T&gt;&gt;(val left: Fun&lt;T&gt;, val right: Fun&lt;T&gt;) : Fun&lt;T&gt;()\nclass Prod&lt;T: Fun&lt;T&gt;&gt;(val left: Fun&lt;T&gt;, val right: Fun&lt;T&gt;) : Fun&lt;T&gt;()\nclass Var&lt;T: Fun&lt;T&gt;&gt;: Fun&lt;T&gt;() { override val variables: Set&lt;Var&lt;X&gt;&gt; = setOf(this) }\nclass Zero&lt;T: Fun&lt;T&gt;&gt;: Const&lt;T&gt;(0.0)\nclass One&lt;T: Fun&lt;T&gt;&gt;: Const&lt;T&gt;(1.0)\n</code></pre> <p>When checking the type of a sealed class, consumers must explicitly handle every case, as incomplete control flow will produce a compiler error rather than fail at runtime. Consider a simplified definition of the superclass <code>Fun</code>, which defines invocation and differentiation using a restricted form of pattern matching:</p> <pre><code>sealed class Fun&lt;X: Fun&lt;X&gt;&gt;(open val variables: Set&lt;Var&lt;X&gt;&gt; = emptySet()): Group&lt;Fun&lt;X&gt;&gt; {\n    constructor(vararg fns: Fun&lt;X&gt;): this(fns.flatMap { it.variables }.toSet())\n\n    // Since the subclasses of Fun are a closed set, no `else  ...` is required.\n    operator fun invoke(map: Bindings&lt;X&gt;): Fun&lt;X&gt; = when (this) {\n        is Const -&gt; this\n        is Var -&gt; map.getOrElse(this) { this } // Partial application is permitted\n        is Prod -&gt; left(map) * right(map) // Smart casting implicitly casts after checking\n        is Sum -&gt; left(map) + right(map)\n    }\n\n    fun d(variable: Var&lt;X&gt;): Fun&lt;X&gt; = when(this) {\n       is Const -&gt; Zero\n       is Var -&gt; if (variable == this) One else Zero\n       // Product rule: d(u*v)/dx = du/dx * v + u * dv/dx\n       is Prod -&gt; left.d(variable) * right + left * right.d(variable)\n       is Sum -&gt; left.d(variable) + right.d(variable)\n    }\n\n    operator fun plus(addend: Fun&lt;T&gt;) = Sum(this, addend)\n\n    operator fun times(multiplicand: Fun&lt;T&gt;) = Prod(this, multiplicand)\n}\n</code></pre> <p>Symbolic differentiation as implemented by Kotlin\u2207 has two distinct passes, one for differentiation and one for evaluation. Differentiation constitutes a top-down substitution process on the computation graph and evaluation propagates the values from the bottom, up. This reduction semantics for this procedure are described more precisely in the specification.</p> <p></p> <p>Kotlin\u2207 functions are not only data structures, but Kotlin functions which can be invoked by passing a <code>Bindings</code> instance (effectively, a <code>Map&lt;Fun&lt;X&gt;, Fun&lt;X&gt;&gt;</code>). To enable this functionality, we overload the <code>invoke</code> operator, then recurse over the graph, using <code>Bindings</code> as a lookup table. If a matching subexpression is found, we propagate the bound value instead of the matching function. This is known as the interpreter pattern.</p> <p>Kotlin's smart casting is an example of flow-sensitive type analysis where the abstract type <code>Fun</code> can be treated as <code>Sum</code> after performing an <code>is Sum</code> check. Without smart casting, we would need to write <code>(this as Sum).left</code> to access the member, <code>left</code>, causing a potential <code>ClassCastException</code> if the cast were mistaken.</p>"},{"location":"kotlingrad/#extension-functions","title":"Extension functions","text":"<p>By using extension functions, users can convert between numerical types in the host language and our eDSL, by augmenting classes with additional operators. Context-oriented programming, allows users to define custom extensions without requiring subclasses or inheritance.</p> <pre><code>data class Const&lt;T: Group&lt;T&gt;&gt;(val number: Double) : Fun()\ndata class Sum&lt;T: Group&lt;T&gt;&gt;(val e1: Fun, val e2: Fun) : Fun()\ndata class Prod&lt;T: Group&lt;T&gt;&gt;(val e1: Fun, val e2: Fun) : Fun()\n\nclass Fun&lt;T: Group&lt;T&gt;&gt;: Group&lt;Fun&lt;T&gt;&gt; {\n  operator fun plus(addend: Fun&lt;T&gt;) = Sum(this, addend)\n\n  operator fun times(multiplicand: Fun&lt;T&gt;) = Prod(this, multiplicand)\n}\n\nobject DoubleContext {\n  operator fun Number.times(expr: Fun&lt;Double&gt;) = Const(toDouble()) * expr\n}\n</code></pre> <p>Now, we can use the context to define another extension, <code>Fun.multiplyByTwo</code>, which computes the product inside a <code>DoubleContext</code>, using the operator overload we defined above:</p> <pre><code>fun Fun&lt;Double&gt;.multiplyByTwo() = with(DoubleContext) { 2 * this } // Uses `*` operator in DoubleContext\n</code></pre> <p>Extensions can also be defined in another file or context and imported on demand. For example, Kotlin\u2207 also uses extensions to define shape-safe constructors and operators for vector and matrix arithmetic.</p>"},{"location":"kotlingrad/#multiple-dispatch","title":"Multiple dispatch","text":"<p>In conjunction with ADTs, Kotlin\u2207 also uses multiple dispatch to instantiate the most specific result type of applying an operator based on the type of its operands. While multiple dispatch is not an explicit language feature, it can be emulated using inheritance.</p> <p>Building on the previous example, a common task in AD is to simplify a graph. This is useful in order to minimize the total number of calculations required, improving numerical stability. We can eagerly simplify expressions based on algebraic rules of replacement. Smart casting allows us to access members of a class after checking its type, without explicitly casting it:</p> <pre><code>override fun times(multiplicand: Function&lt;X&gt;): Function&lt;X&gt; = when {\n  this == zero -&gt; this\n  this == one -&gt; multiplicand\n  multiplicand == one -&gt; this\n  multiplicand == zero -&gt; multiplicand\n  this == multiplicand -&gt; pow(two)\n  this is Const &amp;&amp; multiplicand is Const -&gt; const(value * multiplicand.value)\n  // Further simplification is possible using rules of replacement\n  else -&gt; Prod(this, multiplicand)\n}\n\nval result = Const(2.0) * Sum(Var(2.0), Const(3.0)) // Sum(Prod(Const(2.0), Var(2.0)), Const(6.0))\n</code></pre> <p>This allows us to put all related control flow on a single abstract class which is inherited by subclasses, simplifying readability, debugging and refactoring.</p>"},{"location":"kotlingrad/#shape-safe-tensor-operations","title":"Shape-safe tensor operations","text":"<p>While first-class dependent types are useful for ensuring arbitrary shape safety (e.g., when concatenating and reshaping matrices), they are unnecessary for simple equality checking (such as when multiplying two matrices). When the shape of a tensor is known at compile-time, it is possible to encode this information using a less powerful type system*, as long as it supports subtyping and parametric polymorphism (a.k.a. generics). In practice, we can implement a shape-checked tensor arithmetic in languages like Java, Kotlin, C++, C# or Typescript, which accept generic type parameters. In Kotlin, whose type system is less expressive than Java, we use the following strategy.</p> <p>Shape safety is currently supported up to rank-2 tensors, i.e. matrices. To perform dimension checking in our type system, we first enumerate a list of integer type literals as a chain of subtypes, <code>C &lt;: C - 1 &lt;: C - 2 &lt;: ... &lt;: 1 &lt;: 0</code>, where <code>C</code> is the largest fixed-length dimension we wish to represent, which can be specified by the user prior to compilation. This guarantees linear space and time complexity for subtype checking, with a constant upper bound.</p> <pre><code>@file:Suppress(\"ClassName\")\ninterface Nat&lt;T: D0&gt; { val i: Int } // Used for certain type bounds\nsealed class D0(open val i: Int = 0) { companion object: D0(), Nat&lt;D0&gt; }\nsealed class D1(override val i: Int = 1): D0(i) { companion object: D1(), Nat&lt;D1&gt; }\nsealed class D2(override val i: Int = 2): D1(i) { companion object: D2(), Nat&lt;D2&gt; }\nsealed class D3(override val i: Int = 3): D2(i) { companion object: D3(), Nat&lt;D3&gt; }\n//... \u2020 Automatically generated\n</code></pre> <p>Next, we overload the call operator to emulate instantiating a collection literal, using arity to infer its dimensionality. Consider the rank-1 case for length inference on vector literals:</p> <pre><code>open class Vec&lt;E, Len: D1&gt;(val contents: List&lt;E&gt;)\nfun &lt;T&gt; Vec(t1: T): Vec&lt;T, D1&gt; = Vec(listOf(t1))\nfun &lt;T&gt; Vec(t1: T, t2: T): Vec&lt;T, D2&gt; = Vec(listOf(t1, t2))\nfun &lt;T&gt; Vec(t1: T, t2: T, t3: T): Vec&lt;T, D3&gt; = Vec(listOf(t1, t2, t3))\n//... \u2020 Automatically generated\n</code></pre> <p>Finally, we encode length as a parameter of the operand type. Since integer literals are a chain of subtypes, we need only define one operator using the highest literal, and can rely on Liskov substitution to preserve shape safety for all subtypes.</p> <pre><code>infix operator fun &lt;C: D1, V: Vec&lt;Int, C&gt;&gt; V.plus(v: V): Vec&lt;Int, C&gt; =\n  Vec(contents.zip(v.contents).map { it.first + it.second })\n</code></pre> <p>The operator <code>+</code> can now be used like so. Incompatible operands will cause a type error:</p> <pre><code>val one = Vec(1, 2, 3) + Vec(1, 2, 3)          // Always runs safely\nval add = Vec(1, 2, 3) + Vec(listOf(/*...*/))  // May fail at runtime\nval sum = Vec(1, 2) + add                      // Does not compile\n</code></pre> <p>A similar syntax is available for matrices and higher-rank tensors. For example, Kotlin\u2207 can infer the shape of multiplying two matrices, and will not compile if their inner dimensions do not match:</p> <pre><code>open class Mat&lt;X, R: D1, C: D1&gt;(vararg val rows: Vec&lt;X, C&gt;)\nfun &lt;X&gt; Mat1x2(d0: X, d1: X): Mat&lt;X, D1, D2&gt; = Mat(Vec(d0, d1))\nfun &lt;X&gt; Mat2x1(d0: X, d1: X): Mat&lt;X, D2, D1&gt; = Mat(Vec(d0), Vec(d1))\n//... \u2020 Automatically generated\noperator fun &lt;Q: D1, R: D1, S: D1&gt; Mat&lt;Int, Q, R&gt;.times(m: Mat&lt;Int, R, S&gt;): Mat&lt;Int, Q, S&gt; = TODO()\n\n// Inferred type: Mat&lt;Int, D4, D4&gt;\nval l = Mat4x4(\n  1, 2, 3, 4,\n  5, 6, 7, 8,\n  9, 0, 0, 0,\n  9, 0, 0, 0\n)\n\n// Inferred type: Mat&lt;Int, D4, D3&gt;\nval m = Mat4x3(\n  1, 1, 1,\n  2, 2, 2,\n  3, 3, 3,\n  4, 4, 4\n)\n\n// Inferred type: Mat&lt;Int, D4, D3&gt;\nval lm = l * m\n// m * m // Compile error: Expected Mat&lt;3, *&gt;, found Mat&lt;4, 3&gt;\n</code></pre> <p>Further examples are provided for shape-safe matrix operations such as addition, subtraction and transposition.</p> <p>A similar technique is possible in Haskell, which is capable of a more powerful form of type-level computation, type arithmetic. Type arithmetic makes it easy to express convolutional arithmetic and other arithmetic operations on shape variables (say, splitting a vector in half), which is currently not possible, or would require enumerating every possible combination of type literals.</p> <p><sup>\u2217</sup> Many type systems are still capable of performing arbitrary computation in the type checker. As specified, Java's type system is known to be Turing Complete. It may be possible to emulate a limited form of dependent types in Java by exploiting this property, although this may not be computationally tractable due to the practical limitations noted by Grigore.</p> <p><sup>\u2020</sup> Statically generated code, shipped within the library. To regenerate these methods (e.g., using larger dimensions), a code generator is provided.</p>"},{"location":"kotlingrad/#intermediate-representation","title":"Intermediate representation","text":"<p>Kotlin\u2207 programs are staged into Kaliningraph, an experimental IR for graph computation. As written by the user, many graphs are computationally suboptimal due to expression swell and parameter sharing. To accelerate forward- and backpropagation, it is often advantageous to simplify the graph by applying the reduction semantics in a process known as graph canonicalization. Kaliningraph enables compiler-like optimizations over the graph such as expression simplification and analytic root-finding, and supports features for visualization and debugging, e.g., in computational notebooks.</p>"},{"location":"kotlingrad/#property-delegation","title":"Property delegation","text":"<p>Property delegation is a reflection feature in the Kotlin language which lets us access properties to which an instance is bound. For example, we can read the property name like so:</p> <pre><code>class Var(val name: String?) {\n  operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;) = Var(name ?: property.name)\n}\n</code></pre> <p>This feature allows consumers to instantiate variables e.g., in an embedded DSL without redeclaring their names:</p> <pre><code>val x by Var()   // With property delegation\nval x = Var(\"x\") // Without property delegation\n</code></pre> <p>Without property delegation, users would need to repeat the property name in the constructor.</p>"},{"location":"kotlingrad/#experimental-ideas","title":"Experimental ideas","text":"<p>The current API is stable but can be improved in many ways. Currently, Kotlin\u2207 does not infer a function's input dimensionality (i.e. free variables and their corresponding shape). While it is possible to perform variable capture over a small alphabet using type safe currying, this technique incurs a large source code overhead. It may be possible to reduce the footprint using phantom types or some form of union type bound (cf. Kotlin, Java).</p> <p>When the shape of an N-dimensional array is known at compile-time, we can use type-level integers to ensure shape conforming tensor operations (inspired by Nexus and others).</p> <p>Allowing users to specify a matrix's structure in its type signature, (e.g., <code>Singular</code>, <code>Symmetric</code>, <code>Orthogonal</code>, <code>Unitary</code>, <code>Hermitian</code>, <code>Toeplitz</code>) would allow us to specialize derivation over such matrices (cf. section 2.8 of The Matrix Cookbook).</p>"},{"location":"kotlingrad/#church-encoding","title":"Church encoding","text":"<p>Computers appear to be very complicated machines. Beneath this complexity lies a remarkably simple idea: many apparently complex routines can be rewritten in terms of function composition. Consider the binary operator <code>^</code>, which can be lowered as follows:</p> <p><pre><code>a ^ b :=  a * ... * a \n          \\_________/\n            b times\na * b :=  a + ... + a \n          \\_________/\n            b times\na + b :=  a + 1 + ... + 1\n              \\_________/\n                b times\na := next*(next(...next(1)...))\n     \\________________/\n          a times\n</code></pre> \u2217 <code>next</code> is also called <code>S</code> in Peano arithmetic.</p> <p>By using the \u03bb-calculus, Church tells us, we can lower a large portion of mathematics onto a single operator: function application. Curry, by way of Sch\u00f6nfinkel, gives us combinatory logic, a kind of Rosetta stone for deciphering and translating between a host of cryptic languages. These two ideas, \u03bb-calculus and combinators, are keys to unlocking many puzzles in computer science and mathematics.</p> <p>Though mathematically elegant, Church numerals are not particularly efficient or pleasant to read. One discovers that trying to encode Church arithmetic in a language without dependent types grows quickly impractical. By selecting a higher radix, however, it is possible to reduce spatial complexity and improve readability, albeit at the cost of increased temporal complexity on certain operations (e.g., <code>+</code> and <code>-</code>). Kotlin\u2207 uses a binary encoding by default, however generators for other bases are also provided for convenience.</p>"},{"location":"kotlingrad/#type-classes","title":"Type classes","text":"<p>The trouble with numerical towers is that they assume all inheritors are aware of the tower. In practice, many types we would like to reuse are entirely oblivious to our DSL. How do we allow users to bring in existing types without needing to modify their source code? This kind of ad hoc polymorphism can be achieved using a pattern called the type class. While the JVM does not allow multiple inheritance on classes, it does support multiple inheritance and default methods on interfaces, allowing users to implement an interface via delegation rather than inheritance.</p> <p>Suppose we have a base type, <code>Nat</code> defined as an interface with a unitary member, <code>nil</code>, and its successor function, <code>next</code>, representing the Church encoding for natural numbers. To emulate instantiation, we can provide a nested class equipped with a constructor overriding <code>nil</code> and <code>next</code> as follows:</p> <pre><code>interface Nat&lt;T&gt; {\n  val nil: T\n  val one: T get() = nil.next()\n  fun T.next(): T\n\n  class of&lt;T&gt;(\n    override val nil: T,\n    val vnext: T.() -&gt; T\n  ): Nat&lt;T&gt; {\n    override fun T.next(): T = vnext()\n  }\n}\n</code></pre> <p>Now, if we wanted to wrap an external type, such as <code>Double</code>, inside our tower, we could do so as follows:</p> <pre><code>val doubleNat = Nat.of(nil = 0.0) { this + 1.0 }\n</code></pre> <p>Although the <code>Nat</code> interface is very expressive, evaluating arithmetic expressions on <code>Nat</code>s can be computationally expensive. For instance, we could define the first three hyperoperations na\u00efvely as follows:</p> <pre><code>tailrec fun &lt;T&gt; Nat&lt;T&gt;.plus(l: T, r: T, acc: T = l, i: T = nil): T =\n  if (i == r) acc else plus(l, r, acc.next(), i.next())\n\ntailrec fun &lt;T&gt; Nat&lt;T&gt;.times(l: T, r: T, acc: T = nil, i: T = nil): T =\n  if (i == r) acc else times(l, r, acc + l, i.next())\n\ntailrec fun &lt;T&gt; Nat&lt;T&gt;.pow(base: T, exp: T, acc: T = one, i: T = one): T =\n  if (i == exp) acc else pow(base, exp, acc * base, i.next())\n</code></pre> <p>However, we note that computing <code>pow(a, b)</code> using this representation requires \ud835\udcde(a\u2191b) operations using Knuth notation. Clearly, we must do better if this encoding is to be usable. We can make <code>Nat</code> more efficient by introducing a subtype, <code>Group</code>, which forces implementors to define a native addition operator:</p> <pre><code>interface Group&lt;T&gt;: Nat&lt;T&gt; {\n  override fun T.next(): T = this + one\n  override fun T.plus(t: T): T\n\n  class of&lt;T&gt;(\n    override val nil: T, override val one: T,\n    val plus: (T, T) -&gt; T\n  ): Group&lt;T&gt; {\n    override fun T.plus(t: T) = plus(this, t)\n  }\n}\n</code></pre> <p>Given a <code>Group</code>, we can now define a more efficient implementation of Fibonacci. This will use the group-specific addition operator:</p> <pre><code>tailrec fun &lt;T&gt; Nat&lt;T&gt;.fibonacci(\n  n: T,\n  seed: Pair&lt;T, T&gt; = nil to one,\n  fib: (Pair&lt;T, T&gt;) -&gt; Pair&lt;T, T&gt; = { (a, b) -&gt; b to a + b },\n  i: T = nil,\n): T =\n  if (i == n) fib(seed).first\n  else fibonacci(n = n, seed = fib(seed), i = i.next())\n\nval doubleGroup = Group.of(one = 1.0, plus = { a, b -&gt; a + b })\nprintln(doubleGroup.fibonacci(10.0)) // Prints: 233.0\n</code></pre> <p>We could further extend this chain by introducing a subtype called <code>Ring</code>, which overrides <code>+</code> and requires implementors to define a native <code>*</code> operator. <code>Ring</code>s and their relatives are known to have many useful applications in graph theory and statistics:</p> <pre><code>interface Ring&lt;T&gt;: Group&lt;T&gt; {\n  override fun T.plus(t: T): T\n  override fun T.times(t: T): T\n\n  class of&lt;T&gt;(\n    override val nil: T, override val one: T,\n    val plus: (T, T) -&gt; T,\n    val times: (T, T) -&gt; T\n  ): Ring&lt;T&gt; {\n    override fun T.plus(t: T) = plus(this, t)\n    override fun T.times(t: T) = times(this, t)\n  }\n}\n\nval doubleRing = Ring.of(one = 1.0, plus = { a, b -&gt; a + b }, times = { a, b -&gt; a * b })\n</code></pre> <p>Since differentiation is a linear map between function spaces, we now have the primitives necessary to build a fully-generic AD system, and could easily implement the sum and product rules. To view the above example in full, see <code>Types.kt</code>.</p> <p>What benefit does this abstraction provide to the end user? By parameterizing over primitive operators, Kotlin\u2207 consumers can easily swap out a tensor backend without needing to alter or recompile any upstream dependencies. This feature makes multiplatform development a breeze: wherever a type class operator (e.g., <code>+</code> or <code>*</code>) with matching signature is encountered across a project, it will be dispatched to the user-supplied lambda delegate for specialized execution on custom hardware. Runtime indirection can be elided with proper compiler inlining for zero-cost abstraction.</p>"},{"location":"kotlingrad/#type-arithmetic","title":"Type arithmetic","text":"<p>By default, Kotlin\u2207 supports compile time type arithmetic in the following domain:</p> <ul> <li>Fully symmetric arithmetic: <code>{ a \u235f b \u03f5 [0..16){+,-,*}[0..16) | 0 \u2264 a \u235f b }</code></li> <li>Asymmetric arithmetic: <code>{ a \u235f b \u03f5 [0..512){+,-}[0..16) | 0 \u2264 a \u235f b &lt; 512 }</code></li> <li>Semi-symmetric arithmetic: <code>{ a / b = c, a = b * c | a, b, c \u03f5 [0..128) &amp; a % b = 0 }</code></li> </ul> <p>Arithmetic outside this domain is checked at runtime, prior to evaluation.</p> <p>Compile time type arithmetic is achieved by generating a type-level representation of the Church encoding. A usage example is shown in <code>ChurchArithmeticTest.kt</code>, which may be run with the following command:</p> <pre><code>./gradlew :kotlingrad:cleanJvmTest :kotlingrad:jvmTest --tests \"ai.hypergraph.kotlingrad.typelevel.church.ChurchArithmeticTest\"\n</code></pre> <p>Extensions to other bases, including binary and decimal are also provided, which may be used as follows:</p> <pre><code>// Boolean arithmetic\nval b32 = T.F\n  .let { it + T.F }   // B_4&lt;\u00d8&gt;\n  .let { it + T.F.F } // B_8&lt;\u00d8&gt;\n  .let { it + T.T }   // T&lt;T&lt;F&lt;T&lt;\u00d8&gt;&gt;&gt;&gt;\n  .let { it + T.F }   // T&lt;F&lt;T&lt;T&lt;\u00d8&gt;&gt;&gt;&gt;\n  .let { it - T.F }   // T&lt;T&lt;F&lt;T&lt;\u00d8&gt;&gt;&gt;&gt;\n  .let { it + T.F }   // T&lt;F&lt;T&lt;T&lt;\u00d8&gt;&gt;&gt;&gt;\n  .let { it + T.F }   // T&lt;T&lt;T&lt;T&lt;\u00d8&gt;&gt;&gt;&gt;\n  .let { it + T }     // T&lt;F&lt;F&lt;F&lt;\u00d8&gt;&gt;&gt;&gt;\n\nassertEquals(T.F.F.F.F, b32)\n\n// Chinese arithmetic\nval \u56db\u5341\u4e8c = (\u5341\u4e03 \u51cf \u4e5d)\n  .let { it \u52a0 it }        // \u516d&lt;\u4e00&lt;\u65e0&gt;&gt;\n  .let { (it \u52a0 \u516b) \u52a0 \u516d } // \u96f6&lt;\u4e09&lt;\u65e0&gt;&gt;\n  .let { (it \u51cf \u4e09) \u52a0 \u4e5d } // \u516d&lt;\u4e09&lt;\u65e0&gt;&gt;\n  .let { (it \u52a0 \u516d) \u9664 \u516d } // \u4e03&lt;\u65e0&gt;\n  .let { (it \u4e58 \u516d) \u52a0 \u4e94 } // \u4e03&lt;\u56db&lt;\u65e0&gt;&gt;\n  .let { (it \u51cf \u4e09) \u51cf \u4e5d } // \u4e94&lt;\u4e09&lt;\u65e0&gt;&gt;\n  .let { (it \u52a0 \u4e94) \u52a0 \u4e8c } // \u4e8c&lt;\u56db&lt;\u65e0&gt;&gt;\n  .also { assertEquals(\u516d \u4e58 \u4e03, it) }\n\nassertEquals(42, \u56db\u5341\u4e8c.toInt())\n</code></pre> <p>To alter the arithmetic domain, edit the file <code>BinGen.kt</code>/<code>\u7b97\u76d8\u5382.kt</code>, then use the following command to regenerate <code>Arithmetic.kt</code>/<code>\u7b97\u76d8.kt</code>:</p> <pre><code>./gradlew genShapes\n</code></pre> <p>In practice, compile time type arithmetic may struggle to compute numbers in excess of <code>4095</code>. The Kotlin team has been informed of these issues:</p> <ul> <li>KT-30040</li> <li>KT-50466</li> <li>KT-50533</li> <li>KT-50553</li> <li>KT-50617</li> </ul> <p>This API is experimental and subject to change without notice. In the future, it will be used to statically type check tensor functions whose output shape is an arithmetic function of the input shapes, e.g., concatenation, splitting and convolution.</p>"},{"location":"kotlingrad/#grammar","title":"Grammar","text":"<p>For a detailed grammar and semantics, please refer to the Kotlin\u2207 specification.</p>"},{"location":"kotlingrad/#uml-diagram","title":"UML Diagram","text":"<p>The following graph depicts the subtyping relation between classes and interfaces in Kotlin\u2207.</p> <p></p>"},{"location":"kotlingrad/#comparison","title":"Comparison","text":"<p>Unlike certain frameworks which simply wrap an existing AD library in a type-safe DSL, Kotlin\u2207 contains a fully shape-safe implementation of algorithmic differentiation, written in pure Kotlin. By doing so, it can leverage Kotlin language features such as typed functional programming, as well as interoperability with other languages on the JVM platform. Furthermore, it implements symbolic differentiation, which unlike Wengert tape or dual-number based ADs, allows it to calculate derivatives of arbitrarily high order with zero extra engineering required. Further details can be found below.</p> Framework Language SD\u00b9 AD\u00b2 HD\u00b3 DP\u2074 FP\u2075 TS\u2076 SS\u2077 DT\u2078 MP\u2079 Kotlin\u2207 Kotlin DiffSharp F# TensorFlow.FSharp F# shapesafe Scala Nexus Scala Lantern Scala Hipparchus Java JAutoDiff Java Eclipse DL4J Java SICMUtils Clojure Halide C++ Tensor Safe Haskell HaskTorch Haskell Dex Haskell Grenade Haskell Stalin\u2207 Scheme Myia Python Autograd Python JAX Python Tangent Python Analitik Analitik <p>\u00b9 Symbolic differentiation, \u00b2 Automatic differentiation, \u00b3 Higher-order/rank differentiation, \u2074 Differentiable programming*, \u2075 Functional programming, \u2076 Compile-time type safety, \u2077 Compile-time shape safety, \u2078 Dependently Typed, \u2079 Multiplatform</p> <p><sup>\u2217</sup> Although we do not distinguish between AD and SD, here we adopt the authors' preferred nomenclature. We do make a distinction between differentiable programming libraries and those which simply construct neural networks. The  symbol indicates work in progress.</p>"},{"location":"kotlingrad/#references","title":"References","text":"<p>To the author's knowledge, Kotlin\u2207 is the first AD implementation in native Kotlin. While the particular synthesis of these ideas (i.e. shape-safe, functional AD, using generic types) is unique, it has been influenced by a long list of prior work in AD. Below is a list of projects and publications that helped inspire this work.</p>"},{"location":"kotlingrad/#automatic-differentiation","title":"Automatic differentiation","text":"<ul> <li>The Simple Essence of Automatic Differentiation</li> <li>Reverse-Mode AD in a Functional Framework: Lambda the Ultimate Backpropagator</li> <li>Automatic differentiation in ML: Where we are and where we should be going</li> <li>A Leibniz Notation for Automatic Differentiation</li> <li>First-Class Automatic Differentiation in Swift: A Manifesto</li> <li>The (JAX) Autodiff Cookbook</li> <li>Automatic Differentiation in PyTorch</li> <li>Automatic Differentiation in Machine Learning: a Survey</li> <li>Complexity of Derivatives Generated by Symbolic Differentiation</li> <li>Eigen-AD: Algorithmic Differentiation of the Eigen Library</li> </ul>"},{"location":"kotlingrad/#complexity","title":"Complexity","text":"<ul> <li>Fast parallel computation of polynomials using few processors, Valiant and Skyum (1983)</li> <li>The complexity of partial derivatives, Baur and Strassen (1983)</li> <li>Lower Bounds on Arithmetic Circuits via Partial Derivatives</li> <li>Learning Restricted Models of Arithmetic Circuits</li> </ul>"},{"location":"kotlingrad/#differentiable-programming","title":"Differentiable programming","text":"<ul> <li>Neural Networks, Types, and Functional Programming</li> <li>Backpropagation with Continuation Callbacks: Foundations for Efficient and Expressive Differentiable Programming</li> <li>Backprop as Functor: A compositional perspective on supervised learning</li> <li>Demystifying Differentiable Programming: Shift/Reset the Penultimate Backpropagator</li> <li>Efficient Differentiable Programming in a Functional Array-Processing Language</li> <li>Operational Calculus for Differentiable Programming</li> <li>Differentiable Functional Programming</li> <li>Differentiable Programming for Image Processing and Deep Learning in Halide</li> <li>Software 2.0</li> </ul>"},{"location":"kotlingrad/#calculus","title":"Calculus","text":"<ul> <li>The Matrix Calculus You Need For Deep Learning, Parr and Howard (2018)</li> <li>Backpropagation in matrix notation, Mishachev (2017)</li> <li>Matrix derivatives, from the Matrix Cookbook</li> <li>Div, Grad, Curl and All That, Petersen and Pedersen (2012)</li> <li>Matrix Differentiation (and some other stuff), Barnes (2006)</li> <li>Symbolic Matrix Derivatives, Dwyer and Macphail (1948)</li> </ul>"},{"location":"kotlingrad/#computer-algebra","title":"Computer algebra","text":"<ul> <li>Towards an API for the real numbers, Boehm (2020)</li> <li>miniKanren as a Tool for Symbolic Computation in Python, Willard (2020)</li> <li>A Design Proposal for an Object Oriented Algebraic Library, Niculescu (2003)</li> <li>On Using Generics for Implementing Algebraic Structures, Niculescu (2011)</li> <li>How to turn a scripting language into a domain-specific language for computer algebra, Jolly and Kredel (2008)</li> <li>Evaluation of a Java Computer Algebra System, Kredel (2007)</li> <li>Typesafe Abstractions for Tensor Operations, Chen (2017)</li> <li>Einstein Summation in Numpy, Bilaniuk (2016)</li> <li>Issues in Computer Algebra, Nunes-Harwitt</li> <li>Term Rewriting and All That, Baader and Nipkow (1998)</li> <li>Describing the syntax of programming languages using conjunctive and Boolean grammars, Okhotin (2016)</li> <li>Formal languages over GF(2), Okhotin (2019)</li> </ul>"},{"location":"kotlingrad/#symbolic-mathematics","title":"Symbolic mathematics","text":"<ul> <li>KMath - Kotlin mathematics extensions library</li> <li>SymJa - Computer algebra language &amp; symbolic math library for Android</li> <li>tensor - Linear algebra for tensors with symbolic and numeric scalars</li> <li>Hipparchus - An efficient, general-purpose mathematics components library in the Java programming language</li> <li>miniKanren - A tool for symbolic computation and logic programming</li> <li>SymJava - A Java library for fast symbolic-numeric computation</li> <li>JAS - Java Algebra System</li> <li>jalgebra - An abstract algebra library for Java</li> <li>COJAC - Numerical sniffing tool and Enriching number wrapper for Java</li> <li>chebfun - Allows representing functions as Chebyshev polynomials, for easy symbolic differentiation (or integration)</li> <li>horeilly1101/deriv - Open source derivative calculator REST API (and Java library)</li> </ul>"},{"location":"kotlingrad/#neural-networks","title":"Neural networks","text":"<ul> <li>Hacker's Guide to Neural Networks, Karpathy (2014)</li> <li>Tricks from Deep Learning, Baydin et al. (2016)</li> <li>Practical Dependent Types in Haskell: Type-Safe Neural Networks, Le (2016)</li> <li>A guide to convolutional arithmetic for deep learning, Dumoulin and Visin (2018)</li> </ul>"},{"location":"kotlingrad/#type-systems","title":"Type systems","text":"<ul> <li>Generalized Algebraic Data Types and Object-Oriented Programming, Kennedy and Russo (2005)</li> <li>Java Generics are Turing Complete, Grigore (2016)</li> <li>Dimension Types, Kennedy (2004)</li> <li>An algebraic view of dimension types, Kennedy (1996)</li> <li>Type Inference and Unification</li> <li>Constructive mathematics and computer programming, Martin-Lof (1984)</li> <li>Programming in Martin-L\u00f6f's Type Theory, Nordstrom et al. (1990)</li> </ul>"},{"location":"kotlingrad/#domain-specific-languages","title":"Domain-specific languages","text":"<ul> <li>Compiling Embedded Languages, Elliott et al. (2003)</li> <li>Implicit Staging of EDSL Expressions: A Bridge between Shallow and Deep Embedding, Scherr and Chiba (2014)</li> <li>DSL Implementation Using Staging and Monads Sheard et al. (1999)</li> <li>Deeply Reifying Running Code for Constructing a Domain-Specific Language, Chiba et al. (2016)</li> <li>Staged Abstract Interpreters, Wei et al. (2019)</li> <li>Generating Fluent Embedded Domain-Specific Languages with Subchaining, Nakamaru et al. (2019)</li> <li>Generating a Generic Fluent API in Java, Nakamarua and Chiba (2020)</li> <li>Fling \u2013 A Fluent API Generator, Gil and Roth (2019)</li> <li>Scripting an IDE for EDSL awareness, Sergey et al. (2011)</li> </ul>"},{"location":"kotlingrad/#automated-testing","title":"Automated testing","text":"<ul> <li>DeepTest: Automated Testing of Deep-Neural-Network-driven Autonomous Cars, Tian et al. (2018)</li> <li>QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs, Claessen and Hughes (2000)</li> <li>Learning to Discover Efficient Mathematical Identities, Zaremba et al. (2014)</li> </ul>"},{"location":"kotlingrad/#ad-libraries","title":"AD libraries","text":"<ul> <li>TensorFlow.FSharp: An eDSL for writing numerical models in F# with support for interactive tensor shape-checking</li> <li>Stalin\u2207, a brutally optimizing compiler for the VLAD language, a pure dialect of Scheme with first-class automatic differentiation operators</li> <li>Autograd - Efficiently computes derivatives of NumPy code</li> <li>Myia - SCT based AD, adapted from Pearlmutter &amp; Siskind's \"Reverse Mode AD in a functional framework\"</li> <li>JAX - Composable transformations of Python+NumPy programs: differentiate, vectorize, JIT to GPU/TPU, and more</li> <li>Dex -  Research language for array processing in the Haskell/ML family</li> <li>Nexus - Type-safe tensors, deep learning and probabilistic programming in Scala</li> <li>Tangent - \"Source-to-Source Debuggable Derivatives in Pure Python\"</li> <li>Grenade - composable, dependently typed, practical, and fast RNNs in Haskell</li> <li>Lantern - a framework in Scala, based on delimited continuations and multi-stage programming</li> <li>JAutoDiff - An Automatic Differentiation Library</li> <li>DiffSharp, a functional AD library implemented in the F# language</li> <li>Analitik - Algebraic language for the description of computing processes using analytical transformations</li> </ul>"},{"location":"kotlingrad/#special-thanks","title":"Special thanks","text":"<p>The following individuals have helped shape this project through their enthusiasm and thoughtful feedback. Please check out their work.</p> <ul> <li>Liam Paull</li> <li>Michalis Famelis</li> <li>Marc Feeley</li> <li>Eugene Syriani</li> <li>Hanneli Tavante</li> <li>Stefan Monnier</li> <li>Alexander Nozik</li> <li>Erik Meijer</li> <li>Krishna Murthy</li> <li>Maxime Chevalier-Boisvert</li> <li>Kiran Gopinathan</li> <li>Jacob Miller</li> <li>Adam Pocock</li> <li>Torsten Scholak</li> </ul>"},{"location":"kotlingrad/latex/cser/","title":"Consortium for Software Engineering Research","text":"<p>Kotlin\u2207 was accepted to CSER '19! </p>"},{"location":"kotlingrad/latex/cser/#schedule","title":"Schedule","text":"<p>Wednesday, May 22<sup>nd</sup>, 2019 from 14:20\u201314:40.</p>"},{"location":"kotlingrad/latex/cser/#location","title":"Location","text":"<p>Pavillon Lassonde, \u00c9cole Polytechnique de Montr\u00e9al, Montr\u00e9al, Canada.</p>"},{"location":"kotlingrad/latex/kotlinconf/","title":"KotlinConf","text":"<p>Kotlin\u2207 was accepted to KotlinConf '19! </p>"},{"location":"kotlingrad/latex/kotlinconf/#schedule","title":"Schedule","text":"<p>Thursday, December 5<sup>th</sup> from 17:15-18:00. </p>"},{"location":"kotlingrad/latex/kotlinconf/#location","title":"Location","text":"<p>Aud 11, Bella Center, Copenhagen, Denmark.</p>"},{"location":"kotlingrad/latex/lafi19/","title":"Languages for Inference Workshop at POPL 19","text":"<p>Kotlin\u2207 was accepted to LAFI '19! </p>"},{"location":"kotlingrad/latex/lafi19/#scheudle","title":"Scheudle","text":"<p>Tuesday, January 15<sup>th</sup>, 2019 from 14:30-15:00.</p>"},{"location":"kotlingrad/latex/lafi19/#location","title":"Location","text":"<p>Sala IV, Hotel Cascais Miragem, Cascais, Portugal.</p>"},{"location":"kotlingrad/latex/mais/","title":"Montreal Artificial Intelligence Sympoisum","text":"<p>Kotlin\u2207 was accepted to MAIS '19! </p>"},{"location":"kotlingrad/latex/mais/#live-code","title":"Live Code","text":"<p>Presentation materials can be found here.</p>"},{"location":"kotlingrad/latex/mais/#scheudle","title":"Scheudle","text":"<p>Friday, September 6<sup>th</sup>, 2019 from 14:10\u201314:30.</p>"},{"location":"kotlingrad/latex/mais/#location","title":"Location","text":"<p>K-500, Pavillon Roger-Gaudry, Universit\u00e9 de Montr\u00e9al, Montr\u00e9al, Canada.</p>"},{"location":"kotlingrad/latex/ptml/","title":"Program Transformations for Machine Learning","text":"<p>Kotlin\u2207 has been accepted to PTML '19! </p>"},{"location":"kotlingrad/latex/ptml/#peer-reviews","title":"Peer Reviews","text":"<p>https://openreview.net/forum?id=SkluMSZ08H</p>"},{"location":"kotlingrad/latex/ptml/#schedule","title":"Schedule","text":"<p>Saturday, December 14<sup>th</sup> from 12-2pm.</p>"},{"location":"kotlingrad/latex/ptml/#location","title":"Location","text":"<p>West Level 1, Room 114+115, Vancouver Convention Center, Vancouver, Canada.</p>"},{"location":"kotlingrad/latex/thesis/","title":"Master's Thesis","text":"<p>Archival version: http://hdl.handle.net/1866/24310</p>"},{"location":"kotlingrad/latex/thesis/#abstract","title":"Abstract","text":"<p>Programming tools are computer programs which help humans program computers. Tools come in all shapes and forms, from editors and compilers to debuggers and profilers. Each of these tools facilitates a core task in the programming workflow which consumes cognitive resources when performed manually. In this thesis, we explore several tools that facilitate the process of building intelligent systems, and which reduce the cognitive effort required to design, develop, test and deploy intelligent software systems. First, we introduce an integrated development environment (IDE) for programming Robot Operating System (ROS) applications, called Hatchery. Second, we describe Kotlin\u2207, a language and type system for differentiable programming, an emerging paradigm in machine learning. Third, we propose a new algorithm for automatically testing differentiable programs, drawing inspiration from techniques in adversarial and metamorphic testing, and demonstrate its empirical efficiency in the regression setting. Fourth, we explore a container infrastructure based on Docker, which enables reproducible deployment of ROS applications on the Duckietown platform. Finally, we reflect on the current state of programming tools for these applications and speculate what intelligent systems programming might look like in the future.</p>"},{"location":"kotlingrad/latex/thesis/#building","title":"Building","text":"<p>To build this thesis, a TeX Live distribution is required. Run the following command from the parent directory:</p> <pre><code>xelatex -file-line-error -interaction=nonstopmode -synctex=1 --shell-escape -output-directory=$(pwd) thesis\n</code></pre>"},{"location":"kotlingrad/latex/thesis/#teletype-font","title":"Teletype Font","text":"<p>A custom typeface, JetBrains Mono is needed to render source code listings and inline code tokens.</p>"},{"location":"kotlingrad/latex/thesis/#rail-diagrams","title":"Rail diagrams","text":"<p>Parts of this document were built with a non-standard package called rail. To modify the rail diagrams, install the package like so:</p> <pre><code>$ curl -L https://github.com/Holzhaus/latex-rail/archive/v1.2.1.tar.gz | tar xzvf -\n\n$ cd latex-rail-1.2.1\n\n$ make\nbison -y  -dv gram.y\ngram.y: warning: 2 reduce/reduce conflicts [-Wconflicts-rr]\ncmp -s gram.c y.tab.c || cp y.tab.c gram.c\ncmp -s gram.h y.tab.h || cp y.tab.h gram.h\ngcc -DYYDEBUG -O   -c -o rail.o rail.c\ngcc -DYYDEBUG -O   -c -o gram.o gram.c\nflex  -t lex.l &gt; lex.c\ngcc -DYYDEBUG -O   -c -o lex.o lex.c\ngcc -DYYDEBUG -O rail.o gram.o lex.o -o rail\n\n$ sudo make PREFIX=/usr install\n$ sudo mktexlsr\n</code></pre> <p>When the rail has been installed, the following steps will regenerate the diagram.</p> <ol> <li>Run <code>xelatex ... thesis</code>, which will create <code>thesis.rai</code>.</li> <li>Run <code>rail thesis</code> to generate <code>thesis.rao</code> from <code>thesis.rai</code>.</li> <li>Run <code>xelatex ... thesis</code> to generate the final document.</li> </ol>"},{"location":"kotlingrad/latex/thesis_fr/","title":"Th\u00e8se de ma\u00eetrise","text":""},{"location":"kotlingrad/latex/thesis_fr/#resume","title":"R\u00e9sum\u00e9","text":"<p>Les outils de programmation sont des programmes informatiques qui aident les humains \u00e0 programmer des ordinateurs. Les outils sont de toutes formes et tailles, par exemple les \u00e9diteurs, les compilateurs, les d\u00e9bogueurs et les profileurs. Chacun de ces outils facilite une t\u00e2che principale dans le flux de travail de programmation qui consomme des ressources cognitives lorsqu'il est effectu\u00e9 manuellement. Dans cette th\u00e8se, nous explorons plusieurs outils qui facilitent le processus de construction de syst\u00e8mes intelligents et qui r\u00e9duisent l'effort cognitif requis pour concevoir, d\u00e9velopper, tester et d\u00e9ployer des syst\u00e8mes logiciels intelligents. Tout d'abord, nous introduisons un environnement de d\u00e9veloppement int\u00e9gr\u00e9 (EDI) pour la programmation d'applications Robot Operating System (ROS), appel\u00e9 Hatchery. Deuxi\u00e8mement, nous d\u00e9crivons Kotlin\\(\\nabla\\), un syst\u00e8me de langage et de type pour la programmation diff\u00e9rentiable, un paradigme \u00e9mergent dans l'apprentissage automatique. Troisi\u00e8mement, nous proposons un nouvel algorithme pour tester automatiquement les programmes diff\u00e9rentiables, en nous inspirant des techniques de tests contradictoires et m\u00e9tamorphiques, et d\u00e9montrons son efficacit\u00e9 empirique dans le cadre de la r\u00e9gression. Quatri\u00e8mement, nous explorons une infrastructure de conteneurs bas\u00e9e sur Docker, qui permet un d\u00e9ploiement reproductible des applications ROS sur la plate-forme Duckietown. Enfin, nous r\u00e9fl\u00e9chissons \u00e0 l'\u00e9tat actuel des outils de programmation pour ces applications et sp\u00e9culons \u00e0 quoi pourrait ressembler la programmation de syst\u00e8mes intelligents \u00e0 l'avenir.</p>"},{"location":"kotlingrad/latex/thesis_fr/#construire","title":"Construire","text":"<p>Pour construire cette th\u00e8se, une distribution TeX Live est n\u00e9cessaire. Ex\u00e9cutez la commande suivante \u00e0 partir du r\u00e9pertoire parent:</p> <pre><code>xelatex -file-line-error -interaction=nonstopmode -synctex=1 --shell-escape -output-directory=$(pwd) thesis\n</code></pre>"},{"location":"kotlingrad/latex/thesis_fr/#police-de-teletype","title":"Police de t\u00e9l\u00e9type","text":"<p>Une police de caract\u00e8res personnalis\u00e9e, JetBrains Mono est n\u00e9cessaire pour rendre les listes de code source et les jetons de code en ligne.</p>"},{"location":"kotlingrad/latex/thesis_fr/#diagrammes-de-rail","title":"Diagrammes de rail","text":"<p>Certaines parties de ce document ont \u00e9t\u00e9 construites avec un package non standard appel\u00e9 rail. Pour modifier les sch\u00e9mas de rails, installez le package comme ceci:</p> <pre><code>$ curl -L https://github.com/Holzhaus/latex-rail/archive/v1.2.1.tar.gz | tar xzvf -\n\n$ cd latex-rail-1.2.1\n\n$ make\nbison -y  -dv gram.y\ngram.y: warning: 2 reduce/reduce conflicts [-Wconflicts-rr]\ncmp -s gram.c y.tab.c || cp y.tab.c gram.c\ncmp -s gram.h y.tab.h || cp y.tab.h gram.h\ngcc -DYYDEBUG -O   -c -o rail.o rail.c\ngcc -DYYDEBUG -O   -c -o gram.o gram.c\nflex  -t lex.l &gt; lex.c\ngcc -DYYDEBUG -O   -c -o lex.o lex.c\ngcc -DYYDEBUG -O rail.o gram.o lex.o -o rail\n\n$ sudo make PREFIX=/usr install\n$ sudo mktexlsr\n</code></pre> <p>Une fois le rail install\u00e9, les \u00e9tapes suivantes r\u00e9g\u00e9n\u00e9reront le diagramme.</p> <ol> <li>Lancez <code>xelatex ... thesis</code>, qui cr\u00e9era<code>thesis.rai</code>.</li> <li>Ex\u00e9cutez <code>rail thesis</code> pour g\u00e9n\u00e9rer<code>thesis.rao</code> \u00e0 partir de <code>thesis.rai</code>.</li> <li>Ex\u00e9cutez <code>xelatex ... thesis</code> pour g\u00e9n\u00e9rer le document final.</li> </ol>"},{"location":"kaliningraph/","title":"Kaliningraph: A Type Family of Algebraic Graphs","text":"<p>This library implements a new computational model which we call graph computation. In contrast with prior work, e.g., Turing's machine and Church's \u03bb-calculus, the advantage of this model is that it can be directly translated to iterated matrix multiplication on GPUs and has many desirable algebraic properties. Furthermore, it offers a natural way to express algebraic circuits, neural networks, factor graphs, proof networks, and enjoys many connections to programming language theory, automata theory and category theory.</p> <p>Kaliningraph currently supports backpropagation in Kotlin\u2207. Efforts to lower other propagation schemes, e.g., belief propagation, uncertainty propagation, unit propagation, survey propagation and constraint propagation are ongoing. All of these schemes operate according to a principle known as message passing and are in general known to be Turing complete. This unification allows us to study many common problems in related domains using well-studied tools from arithmetic circuit complexity, to spectral and algebraic graph theory.</p>"},{"location":"kaliningraph/#installation","title":"Installation","text":"<p>Kaliningraph is hosted on Maven Central.</p>"},{"location":"kaliningraph/#gradle","title":"Gradle","text":"<pre><code>dependencies {\n    implementation(\"ai.hypergraph:kaliningraph:0.1.8\")\n}\n</code></pre>"},{"location":"kaliningraph/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;ai.hypergraph&lt;/groupId&gt;\n  &lt;artifactId&gt;kaliningraph&lt;/artifactId&gt;\n  &lt;version&gt;0.1.8&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"kaliningraph/#jupyter-notebook","title":"Jupyter notebook","text":"<p>To access notebook support, use the following line magic:</p> <pre><code>@file:DependsOn(\"ai.hypergraph:kaliningraph:0.1.8\")\n</code></pre> <p>For more information, explore our tutorials:</p> <ul> <li>Hello Kaliningraph.ipynb</li> <li>Program Graphs.ipynb</li> </ul>"},{"location":"kaliningraph/#graphs-inductively","title":"Graphs, inductively","text":"<p>What are graphs? A graph is a (possibly empty) set of vertices.</p> <p>What are vertices? A vertex is a unique label with neighbors (possibly containing itself).</p> <p>What are neighbors? Neighbors are a graph.</p>"},{"location":"kaliningraph/#circuits-inductively","title":"Circuits, inductively","text":"<p>What is a circuit? A circuit is either:</p> <ul> <li>A Boolean logic gate (e.g., <code>and</code>, <code>or</code>, <code>not</code>)</li> <li>A circuit that takes two inputs and swaps them <code>(a, b) -&gt; (b, a)</code></li> <li>A circuit that takes one input and gives one output <code>a -&gt; b</code></li> <li>The serial composition of two circuits <code>(a-&gt;c, c-&gt;d) -&gt; (a-&gt;d)</code></li> <li>The parallel composition of two circuits <code>(a-&gt;b, c-&gt;d) -&gt; (a, b) -&gt; (c, d)</code></li> </ul>"},{"location":"kaliningraph/#getting-started","title":"Getting started","text":"<p>Run the demo via <code>./gradlew jvmTest --tests \"ai.hypergraph.kaliningraph.HelloKaliningraph\"</code> to get started.</p>"},{"location":"kaliningraph/#usage","title":"Usage","text":"<p>Kaliningraph treats string adjacency and graph adjacency as the same. To construct a graph, simply enumerate walks. </p> <p>This can be done using a raw string, in which case unique characters will form the vertex set. Whitespace delimits walks:</p> <pre><code>val graph = LabeledGraph { \"abcde ace\" }\n</code></pre> <p>Vertices can also be linked via the <code>-</code> operator. The graph builder DSL provides a small alphabet:</p> <pre><code>val graph = LabeledGraph { a - b - \"c\" - d - e; a - c - e }\n</code></pre> <p>This is equivalent to:</p> <pre><code>val abcde = LabeledGraph { a - b - c - d - e }\nval ace = LabeledGraph { a - \"c\" - e }\nval graph = abcde + ace\n</code></pre> <p>Equality is supported using the Weisfeiler-Lehman test:</p> <pre><code>val x = LabeledGraph { a - b - c - d - e; a - c - e }\nval y = LabeledGraph { b - c - d - e - f; b - d - f }\nassertEquals(x == y) // true\n</code></pre>"},{"location":"kaliningraph/#visualization","title":"Visualization","text":"<p>Kaliningraph supports a number of graph visualizations.</p>"},{"location":"kaliningraph/#graphviz","title":"Graphviz","text":"<p>Graph visualization is made possible thanks to KraphViz.</p> <pre><code>val de = LabeledGraph { d - e }\nval dacbe = LabeledGraph { d - a - c - b - e }\nval dce = LabeledGraph { d - c - e }\n\nval abcd = LabeledGraph { a - b - c - d }\nval cfde = LabeledGraph { c - \"a\" - f - d - e }\n\nval dg = LabeledGraph(dacbe, dce, de) + Graph(abcd, cfde)\ndg.show()\n</code></pre> <p>Running the above snippet will cause the following figure to be rendered in the browser:</p> <p></p>"},{"location":"kaliningraph/#matrix-form","title":"Matrix form","text":"<p>Graph visualization in both DOT and adjacency matrix format is supported.</p> DOT Graph Matrix <p>It is also possible to visualize the state and transition matrices and step through the graph (<code>./gradlew jsBrowserRun --continuous</code>).</p>"},{"location":"kaliningraph/#computation-graph","title":"Computation graph","text":"<p>Computational notebooks prototyping is also supported.</p> <pre><code>Notebook {\n  a = b + c\n  f = b - h\n}.show()\n</code></pre> <p>The above snippet should display something like the following:</p> <p></p>"},{"location":"kaliningraph/#translation","title":"Translation","text":"<p>Bidirectional translation to various graph formats, including Graphviz, JGraphT, Tinkerpop and RedisGraph is supported:</p> <pre><code>val g = LabeledGraph { a - b - c - a }\n        .toJGraphT().toKaliningraph()\n        .toTinkerpop().toKaliningraph()\n        .toGraphviz().toKaliningraph()\n</code></pre>"},{"location":"kaliningraph/#code2vec","title":"Code2Vec","text":"<p>Code2Vec generation and visualization is supported. The following demo was generated using message passing on the adjacency matrix, for graphs of varying height. The technique to create the embeddings is described here. We use TSNE to visualize the resulting vectors in 2D, and can clearly distinguish the clusters.</p> <p></p>"},{"location":"kaliningraph/#automata-based-regex","title":"Automata-based RegEx","text":"<p>A regex to NFA compiler is provided. To run the demo, run <code>./gradlew RegexDemo</code>. You should see something like this:</p> <p></p>"},{"location":"kaliningraph/#research-questions","title":"Research questions","text":"<ul> <li>What is the best way to represent a graph?</li> <li>Type family</li> <li>Matrix semiring</li> <li>Kernel embedding</li> <li>Is it possible to statically check tensor arithmetic in the Kotlin type system?</li> <li>Church arithmetic</li> <li>Binary arithmetic</li> <li>Decimal arithmetic</li> <li>Multidimensional arrays</li> <li>How computationally powerful is matrix multiplication?</li> <li>Can we do SAT/SMT solving using a matrix semiring?</li> <li>What does asymptotically optimal CFG parsing look like? (e.g., Valiant)</li> <li>Can we simulate finite automata / regular expressions?</li> <li>Is subgraph isomorphism feasible using random walks?</li> <li>Treat graph as a sequence and run string convolution</li> <li>Generate lazy random walk and halt after K steps</li> <li>Convolve permuted variants of query in parallel</li> <li>Need some kind of label permutation / edit distance metric</li> <li>How do we represent a tensor/hypergraph?</li> <li>Naperian functor</li> <li>Sparse recursive dictionary</li> <li>How could we implement graph grammars/rewriting?</li> <li>Rewrites as string substitution on the random walk sequence</li> <li>Reconstruct graph from rewritten string using adjacency matrix</li> <li>Is there an algebraic definition for graph grammars?</li> <li>Maybe graph convolution. How to encode rewrites as a kernel?</li> <li>Rectangular matrix multiplication or square with upper bound?</li> <li>May be possible to represent using tensor contraction</li> <li>Need to look into hyperedge replacement grammars</li> <li>How do we identify confluent rewrite systems?</li> <li>What are the advantages and disadvantages of graph rewriting?</li> <li>Graphs as vertices and rewrites as edges in a nested graph?</li> <li>Reduction/canonicalization versus expansion graph grammar</li> <li>What happens if we represent the graph as a symbolic matrix?</li> <li>Could we propagate functions instead of just values?</li> <li>What if matrix elements were symbolic expressions? (cf. KeOps)</li> <li>Should we represent the whole matrix as a big bold symbol?</li> <li>Is there an efficient way to parallelize arithmetic circuits?</li> <li>Translate formula graph to matrix using Miller's evaluator</li> <li>How to distribute the work evenly across sparse matrices</li> <li>What are some good way to visualize random walks?</li> <li>Display states, transitions and graph occupancy side-by-side</li> <li>Is there a connection between linear algebra and \u03bb-calculus?</li> <li>\u03bb expressions can be represented as a graph/matrix</li> <li>Maybe Arrighi and Dowek (2017) have the answer?</li> <li>Look into optimal beta reduction and Lamping's optimal reduction algorithm</li> </ul>"},{"location":"kaliningraph/#references","title":"References","text":""},{"location":"kaliningraph/#knowledge-graphs","title":"Knowledge graphs","text":"<ul> <li>Organizing Math as a Rule-based Decision Tree, Rich et al. (2018)</li> <li>GOOL: a generic object-oriented language, Carette et al. (2020)</li> <li>ProbOnto 2.5: Ontology and Knowledge Base of Probability Distributions, Maciej et al. (2016)</li> <li>Metamath Proof Explorer, Megill (2006)</li> <li>The Empirical Metamathematics of Euclid and Beyond, Wolfram (2020)</li> <li>Metafore della Matematica, Bo (2014)</li> </ul>"},{"location":"kaliningraph/#graph-theory","title":"Graph theory","text":"<ul> <li>Solutio problematis ad geometriam situs pertinentis, Euler (1741)</li> <li>Account of the Icosian Calculus, Hamilton (1858)</li> <li>Mathematical Foundations of the GraphBLAS, Kepner et al. (2016)</li> <li>Graph Algorithms in the Language of Linear Algebra, Kepner and Gilbert (2011)</li> <li>Graphs, Dioids and Semirings. New Models and Algorithms, Gondran and Minoux (2008)</li> <li>Path Problems in Networks, Baras and Theodorakopoulos (2010)</li> <li>Parallel Matrix and Graph Algorithms, Dekel et al. (1981)</li> </ul>"},{"location":"kaliningraph/#graph-learning","title":"Graph learning","text":"<ul> <li>Graph Representation Learning, Hamilton (2020)</li> <li>Spectral Graph Theory with Applications to ML, Miller (2020)</li> <li>Neural Execution of Graph Algorithms, Veli\u010dkovi\u0107 et al. (2020)</li> </ul>"},{"location":"kaliningraph/#functional-graphs","title":"Functional graphs","text":"<ul> <li>Functional programming with structured graphs, Oliveira and Cook (2012)</li> <li>Think Like a Vertex, Behave Like a Function! A Functional DSL for Vertex-Centric Big Graph Processing, Emoto et al. (2016)</li> <li>Inductive Graphs and Functional Graph Algorithms, Erwig (2001)</li> <li>Fully Persistent Graphs \u2013 Which One To Choose?, Erwig (1997)</li> <li>The Program Dependence Graph and its Use for Optimization, Ferrante et al. (1987)</li> </ul>"},{"location":"kaliningraph/#graph-rewriting","title":"Graph rewriting","text":"<ul> <li>Factor Graph Grammars, Chiang and Riley (2020)</li> <li>Seam: Provably Safe Local Edits on Graphs, Papadakis et al. (2017)</li> <li>Equational term graph rewriting, Ariola and Klop (1997)</li> <li>Bisimilarity in Term Graph Rewriting, Ariola et al. (2000)</li> <li>LEAN: An intermediate language based on graph rewriting, Barendregt et al. (1988)</li> <li>An Algorithm for Optimal Lambda Calculus Reduction, Lamping (1990)</li> <li>A New Implementation Technique for Applicative Languages, Turner (1979)</li> <li>A Reformulation of Matrix Graph Grammars with Boolean Complexes, Velasco and de Lara (2009)</li> <li>Towards a GPU-based implementation of interaction nets, Jiresch (2012)</li> </ul>"},{"location":"kaliningraph/#unification","title":"Unification","text":"<ul> <li>A Catalogue of Canonical Term Rewriting Systems, Hullot (1980)</li> <li>Graph Unification and Matching, Plump and Habel (1996)</li> <li>Unification with Drags, Jouannaud and Orejas (2020)</li> <li>The identity problem for elementary functions and constants, Richardson and Fitch (1994)</li> <li>Duplicate code detection using anti-unification, Bulychev and Minea (2008)</li> </ul>"},{"location":"kaliningraph/#termination-checking","title":"Termination checking","text":"<ul> <li>Proving Termination of Graph Transformation Systems using Weighted Type Graphs over Semirings, Bruggink (2015)</li> <li>Termination of string rewriting with matrix interpretations, Hofbauer (2006)</li> <li>Matrix Interpretations for Proving Termination of Term Rewriting, Endrullis et al. (2007)</li> <li>Graph Path Orderings, Dershowitz and Jouannaud (2019)</li> </ul>"},{"location":"kaliningraph/#algebra","title":"Algebra","text":"<ul> <li>Algebraic Property Graphs, Shinavier and Wisnesky (2020)</li> <li>Algebraic Graphs with Class (Functional Pearl), Mokhov (2017)</li> <li>Algebra of Parameterised Graphs, Mokov and Khomenko (2014)</li> <li>Fun with Semirings, Dolan (2013)</li> <li>Introduction to Algebraic Theory of Graph Grammars, Erhig (1978)</li> <li>Drags: A Simple Algebraic Framework For Graph Rewriting, Dershowitz and Jouannaud (2018)</li> <li>An Algebraic Theory of Graph Reduction, Arnborg (1993)</li> <li>Lineal: A linear-algebraic \u03bb-calculus, Arrighi and Dowek (2017)</li> <li>Graph products, Wikipedia</li> <li>Graphs and Geometry, Lov\u00e1sz (2019)</li> </ul>"},{"location":"kaliningraph/#circuits","title":"Circuits","text":"<ul> <li>Reductions between Families of Polynomials in   Theory and in Practice, Valiant, Hyafil et al.</li> <li>Efficient parallel evaluation of straight-line code and arithmetic circuits, Miller (1986)</li> <li>Algebraic Decision Diagrams and Their Applications, Bahar et al. (1997)</li> <li>Arithmetic Circuit Verification Based on Word-Level Decision Diagrams, Chen (1998)</li> <li>An Efficient Graph Representation for Arithmetic Circuit Verification, Chen and Bryant (2001)</li> <li>A Top-Down Compiler for Sentential Decision Diagrams, Oztok and Darwiche (2015)</li> <li>Representations of Elementary Functions Using Edge-Valued MDDs, Nagayama and Sasao (2007)</li> <li>Complexities of Graph-Based Representations for Elementary Functions, Nagayama and Sasao (2008)</li> <li>Numerical Function Generators Using LUT Cascades, Sasao and Nagayama (2007)</li> </ul>"},{"location":"kaliningraph/#propagation","title":"Propagation","text":"<ul> <li>Unifying Graph Convolutional Neural Networks and Label Propagation, Wang and Leskovec (2020)</li> <li>Equilibrium Propagation: Bridging the Gap between Energy-Based Models and Backpropagation Scellier and Bengio (2017)</li> <li>Expectation Propagation for Approximate Bayesian Inference, Minka (2001)</li> <li>Propagation Networks: A Flexible and Expressive Substrate for Computation, Radul (2009)</li> <li>The Art of the Propagator, Radul and Sussman (2009)</li> <li>Fusion, propagation, and structuring in belief networks, Pearl (1986)</li> </ul>"},{"location":"kaliningraph/#random-walks","title":"Random walks","text":"<ul> <li>Random Walks on Graphs: A Survey, Lov\u00e1sz (1993)</li> <li>String Edit Distance, Random Walks and Graph Matching, Kelly and Hancock (2002)</li> <li>Exact and Approximate Graph Matching Using Random Walks, Gori and Maggini (2005)</li> <li>Reweighted random walks for graph matching, Cho and Lee (2010)</li> <li>Small Subgraphs in the trace of a random walk, Krivelevich and Michaeli (2018)</li> <li>Biased random walk on the trace of a biased random walk on the trace of..., Crydon and Holmes (2019)</li> <li>KnightKing: A Fast Distributed Graph Random Walk Engine, Yang et al. (2019)</li> <li>Graph Learning with 1D Convolutions on Random Walks, Toenshoff et al. (2021)</li> </ul>"},{"location":"kaliningraph/#software-engineering","title":"Software engineering","text":"<ul> <li>Getting F-Bounded Polymorphism into Shape, Tate (2014)</li> <li>Frequent Subgraph Analysis and its Software Engineering Applications, Henderson (2017)</li> <li>Semantic Enrichment of Data Science Code, Patterson (2020)</li> <li>Finally, a Polymorphic Linear Algebra Language, Shaikhha and Parreaux (2019)</li> <li>Towards an API for the Real Numbers, Boehm (2020)</li> </ul>"},{"location":"kaliningraph/#proof-search","title":"Proof search","text":"<ul> <li>Generative Language Modeling for Automated Theorem Proving, Polu et al. (2020)</li> <li>Towards Proof Synthesis Guided by Neural Machine Translation for Intuitionistic Propositional Logic, Sekiyama et al. (2020)</li> <li>Can Neural Networks Learn Symbolic Rewriting?, Piotrowski et al. (2020)</li> <li>Tree Neural Networks in HOL4, Gauthier (2020)</li> <li>Modelling High-Level Mathematical Reasoning in Mechanised Declarative Proofs, Li et al. (2020)</li> </ul>"},{"location":"kaliningraph/#code-search","title":"Code search","text":"<ul> <li>Approximate Online Pattern Matching in Sub-linear Time, Chakraborty et al. (2018)</li> <li>Improved online algorithms for jumbled matching, Ghuman et al. (2018)</li> <li>Parallelizing Exact and Approximate String Matching via Inclusive Scan on a GPU, Mitani et al. (2017)</li> <li>A Novel Algorithm for Online Inexact String Matching and its FPGA Implementation, Cinti et al. (2019)</li> <li>Context-Free Path Querying by Matrix Multiplication, Azimov and Grigorev (2018)</li> <li>Code Search on Bytecode for Mobile App Development, Nguyen et al. (2019)</li> <li>Uses a HMM to model transitions between method calls</li> </ul>"},{"location":"kaliningraph/#word-problems","title":"Word problems","text":"<ul> <li>The problem of solvability of equations in a free semigroup, Makanin (1977)</li> <li>Word equations with length constraints: what\u2019s decidable?, Ganesh et al. (2012)</li> <li>On Solving Word Equations Using SAT, Day et al. (2019)</li> <li>TRAU: SMT solver for string constraints, Abdulla et al. (2018)</li> <li>A Survey on String Constraint Solving, Amadini (2021)</li> </ul>"},{"location":"kaliningraph/#software","title":"Software","text":""},{"location":"kaliningraph/#graphs","title":"Graphs","text":"<ul> <li>KeOps - Dense, sparse and symbolic tensor library</li> <li>Alga - a library for algebraic construction and manipulation of graphs in Haskell</li> <li>Bifurcan - high-quality JVM implementations of immutable data structures</li> <li>Kraphviz - Graphviz with pure Java</li> <li>JGraLab - a Java graph library implementing TGraphs: typed, attributed, ordered, and directed graphs (paper)</li> <li>GraphBLAS - open effort to define standard building blocks for graph algorithms in the language of linear algebra</li> <li>GraphBLAST - High-Performance Linear Algebra-based Graph Primitives on GPUs</li> </ul>"},{"location":"kaliningraph/#rewriting","title":"Rewriting","text":"<ul> <li>Grez - graph transformation termination checker (manual)</li> <li>GP2 - Rule-based graph programming language</li> <li>AGG - development environment for attributed graph transformation systems supporting an algebraic approach to graph transformation (manual)</li> <li>Henshin - an IDE for developing and simulating triple graph grammars (TGGs) (manual)</li> <li>JavaSMT - Unified Java API for SMT solvers</li> </ul>"},{"location":"kaliningraph/#automata","title":"Automata","text":"<ul> <li>roll-library</li> <li>dk.brics.automata</li> <li>LearnLib</li> </ul>"},{"location":"kaliningraph/#special-thanks","title":"Special thanks","text":"<p>The following individuals have helped inspire this project through their enthusiasm and thoughtful feedback. Please check out their work.</p> <ul> <li>Jin Guo</li> <li>Xujie Si</li> <li>Andrey Mokhov</li> <li>Fabian Muehlboeck</li> <li>Ben Greenman</li> <li>Dave Keenan</li> <li>John Tromp</li> </ul>"}]}